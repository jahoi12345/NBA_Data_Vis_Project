const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/imageryUtils-CQQnUiLM.js","assets/utils-DsS75j59.js","assets/jsonMap-Bs3hmeCU.js","assets/originUtils-CPX8CCAY.js","assets/multiOriginJSONSupportUtils-C0wm8_Yw.js","assets/collectionUtils-yEu3-UXw.js","assets/index-CAyy5ces.js","assets/index-DmB13pS_.css","assets/Point-B6yFWNoR.js","assets/reader-DcGs6kKN.js","assets/reactiveUtils-SO2Ko3sy.js","assets/Extent-D4kxmHSf.js","assets/SimpleObservable-CvFyr0NA.js","assets/PortalItem-eLNwGntE.js","assets/jsonContext-BoQRWgP_.js","assets/portalItemUtils-CbcnnyPk.js","assets/projectionUtils-DIbtnzb-.js","assets/Polyline-CiznIgZG.js","assets/Polygon-BUi4eoGW.js","assets/aaBoundingRect-F1Nk1aID.js","assets/mathUtils-PIGhLnI9.js","assets/saveUtils-BuwGvqWP.js","assets/Layer-B6AWeI6O.js","assets/date-IqUzANpt.js","assets/datasetUtils-DdDUWBI2.js"])))=>i.map(i=>d[i]);
import{_ as Se}from"./index-CAyy5ces.js";import{s as k,g as he,i as te,_ as $,m as D,a as ge,ah as $e,f as De}from"./jsonMap-Bs3hmeCU.js";import{q as Te}from"./getPopupProvider-mvkAgiBn.js";import{l as Le}from"./collectionUtils-yEu3-UXw.js";import{l as Re}from"./MultiOriginJSONSupport-Bd1TKmh_.js";import{l as Pe}from"./reactiveUtils-SO2Ko3sy.js";import{s as Ae,o as Ee}from"./GraphicOrigin-uE6TDXc9.js";import{b as Oe}from"./Layer-B6AWeI6O.js";import{p as Me}from"./BlendLayer-DxqnW4p3.js";import{s as Ne}from"./CustomParametersMixin-Dshqz1Zp.js";import{e as w,t as y,l as O,n as A,r as S,i as P,c as ve,X as Ve,a as ke}from"./xmlUtilities-BVR84Lkk.js";import{b as Fe,d as _e,l as Ge}from"./OperationalLayer-D4DfJ3fu.js";import{j as We}from"./PortalLayer-CLS9WSYs.js";import{U as ne,w as je,a as Be,m as qe}from"./RasterJobHandlerMixin-1Y3gc98f.js";import{f as Ue}from"./RefreshableLayer-B3raWpbw.js";import{t as He}from"./ScaleRangeLayer-DQr2T3Hh.js";import{l as ze}from"./TemporalLayer-B5LqtNmo.js";import{m as ce}from"./Field-Cm_ZejYW.js";import{o as Ye,p as Xe}from"./rasterFieldUtils-0bNK-dHZ.js";import{z as B}from"./Extent-D4kxmHSf.js";import{o as ye}from"./crsUtils-DAndLU68.js";import{H as se}from"./Point-B6yFWNoR.js";import{P as Ze}from"./Polygon-BUi4eoGW.js";import{m as re,I as Ke,L as Je}from"./RasterSymbolizer-Bq7g5nVi.js";import{d as Qe}from"./popupUtils-B84-ajB1.js";import"./reader-DcGs6kKN.js";import"./lengthUtils-BsZbNiqt.js";import"./date-IqUzANpt.js";import"./Color-CERqXxxY.js";import"./mathUtils-PIGhLnI9.js";import"./SimpleObservable-CvFyr0NA.js";import"./layerContainerType-CSXZNpHb.js";import"./jsonUtils-giWL1Yhg.js";import"./screenUtils-BitdhK1O.js";import"./mat4f32-Djp3mnm5.js";import"./mat4-DMghHRAg.js";import"./TileInfo-Ed-RyvGY.js";import"./TileKey-BVNpatnV.js";import"./aaBoundingRect-F1Nk1aID.js";import"./datasetUtils-DdDUWBI2.js";import"./QueueProcessor-D8z0mMzA.js";import"./Queue-CYlrXMwB.js";import"./ReactiveMap-B0by2bYu.js";import"./signal-BX9ezF8a.js";import"./Polyline-CiznIgZG.js";import"./projectionUtils-DIbtnzb-.js";import"./PixelBlock-Bg1BzNRo.js";import"./rasterProjectionHelper-CAUugH5r.js";import"./rasterFunctionHelper-BlokZcOM.js";import"./colorUtils-CQgSrs28.js";import"./vec42-Cr02Pi7P.js";import"./vec4f64-DPb6J-GU.js";import"./jsonUtils-BGiBUdmT.js";import"./typeUtils-BzzgRKyX.js";import"./colorRamps-DswZzxkO.js";import"./FeatureSet-BuKEbgxR.js";import"./Graphic-B5lJuCvi.js";import"./createFeatureId-CVwTD0fV.js";import"./typeUtils-cI568bV6.js";import"./lineMarkers-CDwLe3J6.js";import"./PolygonSymbol3D-DuQ13Get.js";import"./ExtrudeSymbol3DLayer-DSc1ou2x.js";import"./opacityUtils-DuFH0EC9.js";import"./aaBoundingBox-CVMQtR0c.js";import"./DoubleArray-DExKNiTh.js";import"./mat4f64-q_b6UJoq.js";import"./Font-DF-HycCW.js";import"./SimpleFillSymbol-CDawtd9z.js";import"./SimpleMarkerSymbol-BGAFRS9_.js";import"./PictureMarkerSymbol-_eQf1cyL.js";import"./TextSymbol-BjfCHbpC.js";import"./ElevationInfo-DevipqE4.js";import"./unitConversionUtils-BhI4jDV1.js";import"./asyncUtils-w6KfWU41.js";import"./layerUtils-CIRkC1pU.js";import"./PortalItem-eLNwGntE.js";import"./portalItemUtils-CbcnnyPk.js";import"./ClassBreaksRenderer-CTDQ9WEt.js";import"./commonProperties-CBXa9rSu.js";import"./ColorStop-De5gQTjr.js";import"./visualVariableUtils-CxWcPx-y.js";import"./jsonUtils-ChUQi1qs.js";import"./defaults3D-BRy__GLn.js";import"./defaults-CGwYBJxE.js";import"./defaultsJSON-GKolV7NZ.js";import"./RendererLegendOptions-BsbaFpgh.js";import"./UniqueValueRenderer-BqMY2rMI.js";import"./diffUtils-DQV540Nb.js";import"./styleUtils-iSHk-Q5b.js";import"./workers-CpwSXy88.js";import"./intl-BY86zs1L.js";import"./normalizeUtils-9qNRso4M.js";import"./Cyclical-BLSxUpe7.js";import"./normalizeUtilsCommon-C6mtpeei.js";import"./utils-CIVJ4xuJ.js";import"./utils-CMK6z7yl.js";import"./utils-CKIa5ouR.js";import"./cimSymbolUtils-DOGwV0lV.js";import"./utils-DX2muIr3.js";import"./LRUCache-fy84PBMi.js";import"./ClassBreaksDefinition-BGOzyovZ.js";import"./dataUtils-BLtGt23U.js";import"./TimeInfo-CvpvGoQ_.js";import"./timeZoneUtils-BSc7-7qA.js";import"./fieldType-DVUzXtk_.js";import"./_commonjsHelpers-DCkdB7M8.js";const et=Symbol("isWCSGraphicOrigin");var me;class tt extends Ae{get[(me=et,Ee)](){return this.layer}constructor(t){super(),this[me]=!0,this.type="wcs",this.layer=t}get id(){return this.layer.id}}function Z(e){return e.endsWith("?")?e.slice(0,-1):e}function oe(e){return e.filter(({coverageSubType:t})=>t==null||t===""||/^rectified(grid|dataset)/i.test(t))}function it(e){const t=y(e,"Service/name"),i=w(e,"Capability"),r=w(i,"GetCapabilities/Get/OnlineResource")?.getAttribute("xlink:href")??"",n=w(i,"DescribeCoverage/Get/OnlineResource")?.getAttribute("xlink:href")??"",o=w(i,"GetCoverage/Get/OnlineResource")?.getAttribute("xlink:href")??"",s={getCapabilities:Z(r),describeCoverage:Z(n),getCoverage:Z(o)},a=A(e,"CoverageOfferingBrief"),c=[];for(let l=0;l<a.length;l++){const u=a[l],m=y(u,"name"),p=A(u,"pos"),d=S(p[0]),f=S(p[1]),h=new B({xmin:d[0],ymin:d[1],xmax:f[0],ymax:f[1],spatialReference:{wkid:4326}});c.push({id:m,lonLatEnvelope:h})}return{name:t,onlineResources:s,coverages:c,gridCoverages:oe(c),supportedVersions:["1.0.0"],version:"1.0.0"}}function be(e){const t={};for(let i=0;i<e.childNodes.length;i++){const r=e.childNodes[i];if(r.nodeType!==1)continue;const n=ve(r).toLowerCase();switch(n){case"title":case"abstract":t[n]=y(r);break;case"identifier":t.id=y(r);break;case"wgs84boundingbox":{const o=S(r,"LowerCorner"),s=S(r,"UpperCorner");t.lonLatEnvelope=new B({xmin:o[0],ymin:o[1],xmax:s[0],ymax:s[1],spatialReference:{wkid:4326}})}break;case"coveragesummary":t.coverageSummaries=t.coverageSummaries||[],t.coverageSummaries.push(be(r))}}return t}function we(e,t){if(e.coverageSummaries)for(let i=0;i<e.coverageSummaries.length;i++)e.coverageSummaries[i].abstract=e.coverageSummaries[i].abstract||e.abstract,e.coverageSummaries[i].lonLatEnvelope=e.coverageSummaries[i].lonLatEnvelope||e.lonLatEnvelope,e.coverageSummaries[i].title=e.coverageSummaries[i].title||e.title,we(e.coverageSummaries[i],t);e.id!=null&&t.push(e)}function xe(e){const t=w(e.querySelector("Operation[name=GetCapabilities]"),"Get")?.getAttribute("xlink:href")||"",i=w(e.querySelector("Operation[name=DescribeCoverage]"),"Get")?.getAttribute("xlink:href")||"",r=w(e.querySelector("Operation[name=GetCoverage]"),"Get")?.getAttribute("xlink:href")||"";return{getCapabilities:Z(t),describeCoverage:Z(i),getCoverage:Z(r)}}function nt(e){const t=y(e,"ServiceIdentification/Title"),i=O(e,"ServiceIdentification/ServiceTypeVersion"),r=xe(w(e,"OperationsMetadata")),n=[],o=w(e,"Contents");for(let a=0;a<o.childNodes.length;a++){const c=o.childNodes[a];c.nodeType===1&&P(c,"CoverageSummary")&&we(be(c),n)}const s=O(o,"SupportedFormat");return{name:t,onlineResources:r,coverages:n,gridCoverages:oe(n),supportedVersions:i,supportedFormats:s,version:"1.1.0"}}function st(e){const t=w(e,"ServiceIdentification"),i=y(t,"Title"),r=O(t,"ServiceTypeVersion"),n=O(t,"Profile"),o=xe(w(e,"OperationsMetadata")),s=A(e,"Contents/CoverageSummary"),a=[];for(let l=0;l<s.length;l++){const u=s[l],m=y(u,"CoverageId"),p=w(u,"WGS84BoundingBox");let d;if(p){const h=S(p,"LowerCorner"),g=S(p,"UpperCorner");d=new B({xmin:h[0],ymin:h[1],xmax:g[0],ymax:g[1],spatialReference:{wkid:4326}})}const f=y(u,"CoverageSubtype")||"RectifiedGridCoverage";a.push({id:m,lonLatEnvelope:d,coverageSubType:f})}const c=w(e,"ServiceMetadata");return{name:i,supportedVersions:r,supportedFormats:O(c,"formatSupported"),supportedInterpolations:O(c,"interpolationSupported").concat(O(c,"InterpolationSupported")),onlineResources:o,profiles:n,coverages:a,gridCoverages:oe(a),version:"2.0.1"}}function rt(e){let t=null;typeof e=="string"?t=new DOMParser().parseFromString(e,"text/xml"):t=e;const i=t.documentElement.getAttribute("version"),r=i?.slice(0,3);return r!=null&&r<"2.1"}function ot(e,t=null){let i=null;typeof e=="string"?i=new DOMParser().parseFromString(e,"text/xml"):i=e;let r=i.documentElement.getAttribute("version");r==="1.0"?r="1.0.0":r==="1.1"&&(r="1.1.0");const n=r||t||"1.0.0",o=n.slice(0,3);let s;if(o==="2.0")s=st(i);else if(o==="1.1")s=nt(i);else{if(o!=="1.0")throw new k("wcsraster:parsecapabilities","the capabilities version is not supported");s=it(i)}return s.version=n,s}function ae(e){e.variables.forEach(t=>t.dimensions.forEach(i=>i.values??=je(i)))}function at(e){return{requestResponseCRSs:O(e,"requestResponseCRSs").map(t=>t.split(":")[1]),nativeCRSs:O(e,"nativeCRSs").map(t=>t.split(":")[1])}}function Ce(e,t){const i=O(e,t==="1.0.0"?"interpolationMethod":"InterpolationMethod"),r=t==="1.0.0"?e.getAttribute("default"):y(e,"InterpolationMethods/Default");return r!=null?[r].concat(i.filter(n=>n.toLowerCase()!==r.toLowerCase())):i}function le(e){return e==null?["nearest"]:e.map(t=>{const i=t.toLowerCase();return i.includes("nearest")?"nearest":i.includes("linear")?"bilinear":i.includes("cubic")?"cubic":null}).filter(t=>!!t)}function lt(e){const t=A(e,"pos"),i=S(t[0]),r=S(t[1]);return new B({xmin:i[0],ymin:i[1],xmax:r[0],ymax:r[1],spatialReference:{wkid:4326}})}function pe(e,t){const i=O(e,t);return i?.length&&i[0]!==""&&!isNaN(Number(i[0]))?i.map(r=>Number(r)):null}function pt(e){const t=S(e,"MinimumValue"),i=S(e,"MaximumValue");return t.length&&i.length?t.map((r,n)=>({min:r,max:i[n],avg:-1,stddev:-1})):null}function ue(e){return e==null?null:e.every(t=>t===e[0])?e[0]:e}function ut(e){const t=[],i=A(e,"RangeSet");let r=[];for(let n=0;n<i.length;n++){const o=y(i[n],"name"),s=y(i[n],"label"),a=[],c=pe(i[n],"nullValues/singleValue"),l=A(i[n],"AxisDescription");for(let u=0;u<l.length;u++){const m=y(l[u],"name"),p=y(l[u],"label"),d=O(l[u],"singleValue");if(d.length===0){const f=y(l[u],"min"),h=y(l[u],"max"),g=Number(y(l[u],"res"))||1;if(f!==null&&h!==null)for(let v=parseInt(f,10);v<=parseInt(h,10);v+=g)d.push(v.toString())}m.toLowerCase()==="band"&&(r=d),a.push({name:m,label:p,values:d})}t.push({name:o,label:s,nullValues:c,axis:a})}return{rangeSet:t,bandNames:r}}function ct(e=null){if(!e)return{resolution:null,units:null};let t=e.toUpperCase();const i=["Y","M","D"],r=["H","M","S"],n=["Years","Months","Days","Hours","Minutes","Seconds"];let o,s,a;return t.includes("PT")?(t=t.slice(2),a=r.findIndex(c=>t.includes(c)),o=n[3+a],s=parseFloat(t.slice(0,-1))):(t=t.slice(1),a=i.findIndex(c=>t.includes(c)),a>-1&&(o=n[a]),s=parseFloat(t.slice(0,-1))),{resolution:s,units:o}}function ee(e){const t=A(e,"timeposition");if(t.length>0){const r=[];for(let n=0;n<t.length;n++)r.push(new Date(y(t[n])));return{begin:r[0],end:r[r.length-1],values:r}}const i=w(e,"timePeriod")||w(e,"TimePeriod");return i?{begin:new Date(y(i,"beginPosition")||y(i,"BeginPosition")),end:new Date(y(i,"endPosition")||y(i,"EndPosition")),...ct(y(i,"timeResolution")||y(i,"TimeResolution"))}:null}function mt(e){const t=w(e,"spatialDomain"),i=w(t,"Envelope")||w(t,"EnvelopeWithTimePeriod"),r=i.getAttribute("srsName").split(":"),n=r[r.length-1],o=A(i,"pos"),s=S(o[0]),a=S(o[1]),c=parseInt(n,10),l=isNaN(c)?null:{wkid:c},u=new B({xmin:s[0],ymin:s[1],xmax:a[0],ymax:a[1],spatialReference:l}),m=w(t,"RectifiedGrid"),p=y(m,"low").split(" "),d=y(m,"high").split(" "),f=parseInt(d[0],10)-parseInt(p[0],10)+1,h=parseInt(d[1],10)-parseInt(p[1],10)+1,g=S(t,"origin/pos"),v=A(t,"offsetVector"),b={envelope:u,columns:f,rows:h,offset:{x:parseFloat(y(v[0]).split(" ")[0]),y:parseFloat(y(v[1]).split(" ")[1])},origin:{x:g[0],y:g[1]}},C=w(e,"temporalDomain")||w(e,"TemporalDomain");return{spatialDomain:b,temporalDomain:C?ee(C):null}}function dt(e){const t={version:"1.0"};let i,r=[];for(let f=0;f<e.childNodes.length;f++){const h=e.childNodes[f];if(h.nodeType===1)if(P(h,"description"))t.description=y(h);else if(P(h,"name"))t.name=y(h);else if(P(h,"label"))t.label=y(h);else if(P(h,"supportedFormats"))t.supportedFormats=O(h,"formats");else if(P(h,"supportedCRSs"))t.supportedCRSs=at(h);else if(P(h,"supportedInterpolations"))t.supportedInterpolations=Ce(h,"1.0.0");else if(P(h,"lonLatEnvelope"))t.lonLatEnvelope=lt(h);else if(P(h,"rangeSet")){const g=ut(h);t.rangeSet=g.rangeSet,r=g.bandNames;const v=g.rangeSet[0].nullValues;v?.length&&(i=ue(v))}else P(h,"domainSet")&&(t.domainSet=mt(h))}const n=le(t.supportedInterpolations),{name:o,description:s,label:a,lonLatEnvelope:c,supportedFormats:l}=t,{spatialDomain:u}=t.domainSet,m={x:Math.abs(u.offset.x),y:Math.abs(u.offset.y)},p=ft(t.domainSet),d=new re({width:u.columns,height:u.rows,pixelSize:m,pixelType:"unknown",extent:u.envelope,spatialReference:u.envelope.spatialReference,bandCount:r.length||1,noDataValue:i,multidimensionalInfo:p});return{id:o,title:t.name,description:s||a,lonLatEnvelope:c,rasterInfo:d,bandNames:r,supportedFormats:l,supportedInterpolations:n,coverageDescription:t,version:"1.0.0",useEPSGAxis:!1}}function ft(e){if(!e.temporalDomain)return null;const{begin:t,end:i,values:r,units:n,resolution:o}=e.temporalDomain,s={variables:[{name:"default",description:"",dimensions:[{name:"StdTime",description:"",unit:"ISO8601",values:r?.map(a=>a.getTime()),hasRegularIntervals:!r,interval:o,intervalUnit:n,extent:[t.getTime(),i.getTime()]}]}]};return ae(s),s}function ht(e,t){const i=[],r=A(e,"Field");let n,o=[];for(let s=0;s<r.length;s++){const a=y(r[s],"Identifier"),c=y(r[s],"Description"),l=y(r[s],"Definition"),u=y(r[s],"Abstract"),m=y(r[s],"Title"),p=pe(r[s],"NullValue"),d=w(r[s],"AllowedValues"),f=d?pt(d):null,h=Ce(r[s],"1.1.0"),g=[],v=A(r[s],"Axis");for(let b=0;b<v.length;b++){const C=v[b].getAttribute("identifier"),I=y(v[b],"UOM"),L=y(v[b],"DataType"),q=O(v[b],"Key");t&&!C.toLowerCase().includes("band")||(o=q,n=p),g.push({identifier:C,uom:I,dataType:L,values:q,bandNoDataValues:n})}i.push({identifier:a,description:c,definition:l,abstract:u,title:m,supportedInterpolations:h,axis:g,nullValues:p,statistics:f})}return{rangeSet:i,bandNames:o,bandNoDataValues:n,statistics:i[0].statistics}}function gt(e,t){if(!t.temporalDomain)return null;const i=e.filter(n=>!n.identifier.toLowerCase().includes("field_1")&&!n.axis.some(o=>o.identifier.includes("band"))),r=[];if(i.length&&i.forEach(n=>{const o=n.axis.map(s=>{const a=s.values.map(l=>s.uom==="ISO8601"?(l=l.trim()).toLowerCase().includes("z")?new Date(l).getTime():new Date(l+"Z").getTime():parseFloat(l.trim())),c=[Math.min.apply(null,a),Math.max.apply(null,a)];return{name:s.identifier.trim(),description:"",field:s.identifier.trim(),unit:s.uom?s.uom.trim():"",hasRegularIntervals:!1,values:a,extent:c}});r.push({name:n.identifier.trim(),description:n.description?.trim()??"",unit:"",dimensions:o,statistics:n.statistics})}),t.temporalDomain){const{begin:n,end:o,values:s,units:a,resolution:c}=t.temporalDomain;r.some(l=>l.dimensions.some(u=>u.name.toLowerCase()==="stdtime"))||r.forEach(l=>{l.dimensions.push({name:"StdTime",description:"",unit:"ISO8601",values:s?.map(u=>u.getTime()),hasRegularIntervals:!s,interval:c,intervalUnit:a,extent:[n.getTime(),o.getTime()]})})}if(r.length){const n={variables:r};return ae(n),n}return null}function vt(e){const t=w(e,"SpatialDomain"),i=w(t,"GridCRS"),r=y(i,"GridBaseCRS"),n=y(i,"GridOrigin"),o=n?.split(" ").map(v=>parseFloat(v))??[0,0],s=S(i,"GridOffsets"),a=A(t,"BoundingBox");let c,l,u,m;for(let v=0;v<a.length;v++){const b=a[v].getAttribute("crs")?.toLowerCase();if(b!=null){if(b.includes("imagecrs")){const C=S(a[v],"LowerCorner"),I=S(a[v],"UpperCorner");c=I[0]-C[0]+1,l=I[1]-C[1]+1}else if(b.indexOf("epsg")>0){const C=b.split(":");u=parseInt(C[C.length-1],10);const I=S(a[v],"LowerCorner"),L=S(a[v],"UpperCorner");m=new B({xmin:I[0],ymin:I[1],xmax:L[0],ymax:L[1],spatialReference:{wkid:u}})}}}const p=c>l,d=m.xmax-m.xmin>m.ymax-m.ymin;let f=!1;ye(u)&&(p===d?f=!1:(f=!0,m=new B({xmin:m.ymin,ymin:m.xmin,xmax:m.ymax,ymax:m.xmax,spatialReference:{wkid:u}})));const h={columns:c,rows:l,origin:{x:o[0],y:o[1]},offset:{x:s[0],y:s[s.length-1]},gridBaseCRS:r,envelope:m,useEPSGAxis:f},g=w(e,"temporalDomain")||w(e,"TemporalDomain");return{spatialDomain:h,temporalDomain:g?ee(g):null}}function yt(e,t){const i=[],r=[],n={supportedFormats:i,supportedCRSs:r,version:"1.1"};let o,s,a=[];for(let v=0;v<e.childNodes.length;v++){const b=e.childNodes[v];if(b.nodeType!==1)continue;const C=ve(b).toLowerCase();switch(C){case"title":case"abstract":case"identifier":n[C]=y(b);break;case"supportedformat":{const I=y(b);i.includes(I)||i.push(I)}break;case"supportedcrs":{const I=y(b);r.includes(I)||r.push(I)}break;case"range":{const I=ht(b,!!n.domain?.temporalDomain);n.range=I.rangeSet,a=I.bandNames;const{bandNoDataValues:L}=I;L?.length&&(o=ue(L)),s=I.statistics}break;case"domain":n.domain=vt(b)}}const c=le(n.range[0].supportedInterpolations),{identifier:l,abstract:u,title:m,domain:p,range:d}=n,f={x:Math.abs(p.spatialDomain.offset.x),y:Math.abs(p.spatialDomain.offset.y)},h=gt(d,p);h&&(o=d[0].nullValues,o?.length===1&&(o=o[0]));const g=new re({width:p.spatialDomain.columns,height:p.spatialDomain.rows,pixelSize:f,pixelType:"unknown",extent:p.spatialDomain.envelope,spatialReference:p.spatialDomain.envelope.spatialReference,bandCount:a.length||1,noDataValue:o,statistics:s,multidimensionalInfo:h});return{id:l,title:n.title,description:u||m,bandNames:a,rasterInfo:g,supportedFormats:i,supportedInterpolations:c,coverageDescription:n,version:t,useEPSGAxis:p.spatialDomain.useEPSGAxis}}function bt(e){const t=w(e,"Envelope")||w(e,"EnvelopeWithTimePeriod"),i=t.getAttribute("srsName"),r=i.slice(i.lastIndexOf("/")+1),n=t.getAttribute("axisLabels").split(" ").map(h=>h.trim()).filter(h=>h.trim()!==""),o=S(t,"lowerCorner"),s=S(t,"upperCorner"),a=!["y","lat","latitude","north","nor","n","b"].includes(n[0].toLowerCase());let c;const l=parseInt(r,10),u=isNaN(l)?null:{wkid:l};c=new B(a?{xmin:o[0],ymin:o[1],xmax:s[0],ymax:s[1],spatialReference:u}:{xmin:o[1],ymin:o[0],xmax:s[1],ymax:s[0],spatialReference:u});const m={mins:o,maxs:s},p=t.getAttribute("uomLabels").trim().split(" ");let d,f;if(P(t,"EnvelopeWithTimePeriod")){d=new Date(y(e,"beginPosition")||y(e,"BeginPosition")),f=new Date(y(e,"endPosition")||y(e,"EndPosition"));const h=p?.findIndex(g=>g?.toLowerCase()==="oledatetime");h>-1&&(p[h]="ISO8601")}return{envelope:c,axisLabels:n,uomLabels:p.length?p:null,envelopeAllDims:m,beginPosition:d,endPosition:f,isEastFirst:a}}function wt(e,t){const i=[],r=A(e,"DataRecord"),n=[];let o,s=[];for(let a=0;a<r.length;a++){const c=A(r[a],"field"),l=[];for(let u=0;u<c.length;u++){const m=c[u].getAttribute("name"),p=y(c[u],"description")||"",d=w(c[u],"uom")?.getAttribute("code")||"",f=S(c[u],"interval"),h=pe(c[u],"nilValue")?.[0];t&&!m.toLowerCase().includes("band")||(n.push(m),f?.length&&(o=o||[],o.push({min:f[0],max:f[1],avg:-1,stddev:-1})),s.push(h)),l.push({name:m,description:p,uom:d,allowedValues:f,nilValue:h})}i.push(l)}return s.some(a=>a!=null)||(s=null),{rangeType:i,bandNames:n,bandStats:o,bandNoDataValues:s}}function xt(e){let t=1,i="";const r=.01;return Math.abs(e-1/24)<1/24*r?i="Hours":Math.abs(e-1)<1*r?i="Days":e<1?(t=Math.round(24*e),i="Hours"):e>28-r&&e<31+r||Math.round(e/30)<12?i="Months":e>365-r&&e<366+r&&(i="Years"),{interval:t,intervalUnit:i}}function Ct(e,t,i){if(i.axisLabels.length<=2)return null;const r=[];for(let o=0;o<e.length;o++){const s=e[o];for(let a=0;a<s.length;a++)s[a].name.toLowerCase().includes("band")||r.push(s[a])}const n=[];if(r.length){const o=[];for(let s=2;s<i.axisLabels.length;s++){const a=t.uomLabels?.[s]?.trim()??"",c=i.axisLabels[s].toLowerCase().includes("time")||a.toLowerCase()==="iso8601"||a.toLowerCase()==="oledatetime";let l,u;if(c){const p=xt(i.offset[s]);l=p.interval,u=p.intervalUnit}else l=i.offset[s],u=a;const m=[];c?(m.push(ne(t.envelopeAllDims.mins[s])),m.push(ne(t.envelopeAllDims.maxs[s]))):(m.push(t.envelopeAllDims.mins[s]),m.push(t.envelopeAllDims.maxs[s])),o.push({name:i.axisLabels[s].trim(),description:i.axisLabels[s].trim(),unit:c?"ISO8601":a,hasRegularIntervals:!0,extent:m,interval:l,intervalUnit:u})}if(r.forEach(s=>{const{allowedValues:a}=s,c=a?.length===2?[{min:a[0],max:a[1],avg:-1,stddev:-1}]:null;n.push({name:s.name.trim(),description:s.description?.trim()??"",unit:s.uom.trim(),statistics:c,dimensions:[...o]})}),n.length){const s={variables:n};return ae(s),s}}return null}function It(e,t){const i=w(e,"RectifiedGrid"),r=S(i,"low"),n=S(i,"high"),o=[];for(let g=0;g<r.length;g++)o.push(n[g]-r[g]+1);const s=y(i,"axisLabels").split(" "),a=S(i,"origin/pos"),c=A(i,"offsetVector"),l=[];for(let g=0;g<c.length;g++){const v=S(c[g]),b=v.findIndex(C=>C!==0);l[b]=v[b]}const u=["y","lat","latitude","north","nor","n","b"];let m=!1;t?.length&&s?.length&&(m=[...t].sort((g,v)=>g<v?-1:1).join(",")===[...s].sort((g,v)=>g<v?-1:1).join(","));const p=m?s:t;let d,f,h;return u.includes(p[0].toLowerCase())?(d=o[1],f=o[0],h={y:Math.abs(l[0]),x:Math.abs(l[1])}):(d=o[0],f=o[1],h={x:Math.abs(l[0]),y:Math.abs(l[1])}),{columns:d,rows:f,origin:a,offset:l,resolution:h,gridSamples:o,axisLabels:s,hasSameAxisLabelsAsBoundedBy:m}}function St(e){const t=w(e,"EarthObservation");if(!t)return null;const i=w(t,"phenomenonTime"),r=i?ee(i):null,n=w(t,"phenomenonTime"),o=n?ee(n):null,s=y(t,"featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");let a=null;if(s){const c=s.split(" ").map(l=>l.trim()).filter(l=>l!=null&&l!=="").map(Number);if(c.length){const l=[];for(let u=0;u<c.length/2;u+=2)l.push(c[u],c[u+1]);a=new Ze({rings:[[l]]})}}return{observation:{phenomenonTime:r,resultTime:o,footprint:a,identifier:y(e,"metaDataProperty/EarthObservationMetaData/identifier"),acquisitionType:y(e,"metaDataProperty/EarthObservationMetaData/acquisitionType"),status:y(e,"metaDataProperty/EarthObservationMetaData/status")}}}function $t(e){const t={version:"2.0"};let i,r,n=[];for(let m=0;m<e.childNodes.length;m++){const p=e.childNodes[m];if(p.nodeType===1){if(P(p,"coverageId"))t.coverageId=y(p);else if(P(p,"ServiceParameters"))t.serviceParameters={supportedFormats:O(p,"nativeFormat")};else if(P(p,"boundedBy"))t.boundedBy=bt(p);else if(P(p,"rangeType")){const d=wt(p,t.boundedBy?.axisLabels.length>2||t.domainSet?.axisLabels.length>2);t.rangeType=d.rangeType,n=d.bandNames,i=d.bandStats;const{bandNoDataValues:f}=d;f?.length&&(r=ue(f))}else if(P(p,"domainSet"))t.domainSet=It(p,t.boundedBy?.axisLabels);else if(P(p,"metadata")){const d=w(p,"EOMetadata");t.eoMetadata=d?St(d):null}}}const{coverageId:o,boundedBy:s,domainSet:a,rangeType:c,serviceParameters:l}=t,u=Ct(c,s,a);return!i&&u&&(i=u?.variables[0].statistics),u!=null&&(r=c[0][0].nilValue),{id:o,title:o,description:o,bandNames:n,rasterInfo:new re({width:a.columns,height:a.rows,pixelSize:a.resolution,pixelType:"unknown",extent:s.envelope,spatialReference:s.envelope.spatialReference,bandCount:n.length||1,statistics:i,noDataValue:r,multidimensionalInfo:u}),supportedFormats:l.supportedFormats,coverageDescription:t,version:"2.0.1",useEPSGAxis:!1}}function Dt(e,t){let i=null;if(typeof e=="string"?i=new DOMParser().parseFromString(e,"text/xml"):i=e,t==="1.0.0")return A(i,"CoverageOffering").map(n=>dt(n));const r=A(i,"CoverageDescription");return t==="1.1.0"||t==="1.1.1"||t==="1.1.2"?r.map(n=>yt(n,t)):r.map(n=>$t(n))}async function Tt(e,t){const{version:i,customParameters:r,signal:n}=t??{},o=i?.startsWith("1.0")?"version":"acceptVersions",s={service:"WCS",request:"GetCapabilities",[o]:i,...r};try{let{data:a}=await se(e,{query:s,responseType:"xml",signal:n});return t?.version||rt(a)||(s[o]="2.0.1",{data:a}=await se(e,{query:s,responseType:"xml",signal:n})),ot(a)}catch(a){throw he(a)?a:new k("wcslayer:open","wcs capabilities is not valid or supported")}}async function ie(e,t){const{coverageIds:i,version:r,customParameters:n,signal:o}=t,s=r.slice(0,3),a=s==="1.0"?"coverage":s==="1.1"?"identifiers":"coverageId",c={service:"WCS",request:"DescribeCoverage",version:r,[a]:i.join(","),...n};try{const{data:l}=await se(e,{query:c,responseType:"xml",signal:o});return Dt(l,r)}catch(l){throw he(l)?l:new k("wcslayer:open","wcs coverage description is not valid or supported")}}function Lt(e){const t=Pt(e);return t?{isMultipart:!0,data:t.boundary?Rt(e.data,t,0):null}:{isMultipart:!1,data:null}}function Rt(e,t,i=0){const r="--"+t.boundary,n=[];for(let g=0;g<r.length;g++)n.push(r.charCodeAt(g));const o=[],s=`
--`+t.boundary+"--";for(let g=0;g<s.length;g++)o.push(s.charCodeAt(g));const a=[10],c=[13,10],l=[],u=n.length,m=new Uint8Array(e,i),p=m.length-u;let d=0,f=0;for(let g=0;g<p;g++){for(f=0;f<u&&m[g+f]===n[f];f++);if(f!==u)continue;let v=!1;if(d){const b=de(m.subarray(d,g),t);l.push(b),v=!!b.isValidImage}if(g+=u-1,m[g+1]===a[0]?g+=1:m[g+1]===c[0]&&m[g+2]===c[1]&&(g+=2),d=g+1,v)break}const h=o.length;for(let g=m.length-h-10;g<m.length-h;g++){for(f=0;f<h&&m[g+f]===o[f];f++);if(f===h){l.push(de(m.subarray(d,g),t));break}}return l}function Pt(e){const t=e.getHeader?.("Content-Type")?.split(";");if(!t||!(t[0].trim()??"").startsWith("multipart/"))return null;const i={boundary:"",start:"",type:""};for(let r=1;r<t.length;r++){const n=t[r].indexOf("=");if(n>0){const o=t[r].slice(0,n).trim(),s=t[r].slice(n+1).trim();i[o]=s.startsWith('"')?s.slice(1,-1):s}}return i}function de(e,t){const i=String.fromCharCode.apply(null,e.subarray(0,Math.min(300,e.length))).split(`
`),r=Math.min(i.length,7),n={contentDisposition:"inline"};let o=0;for(let s=0;s<r;s++)if(i[s].length<4)o=o+i[s].length+1;else if(i[s].slice(0,7).toLowerCase()==="content"){o=o+i[s].length+1;const a=i[s].indexOf(":");if(a===-1)continue;const c=i[s].slice(0,a).trim(),l=i[s].slice(a+1).trim();switch(c.toLowerCase()){case"content-type":n.contentType=l;break;case"content-description":n.contentDescription=l;break;case"content-transfer-encoding":n.contentTransferEncoding=l;break;case"content-id":n.contentID=l;break;case"content-disposition":n.contentDisposition=l;break;case"content-location":n.contentLocation=l}}else{if(n.contentDisposition.toLowerCase().includes("inline")&&i[s].length>=4&&n.contentType?.toLowerCase().includes("image")){let a=!0,c=e.subarray(o,e.length);if(n.contentType.toLowerCase().indexOf("tif")>0){if(n.contentTransferEncoding==="base64"){let l="";const u=c;for(let p=0;p<u.length;p+=65535){const d=u.subarray(p,p+65535>u.length-1?u.length-1:p+65535);l+=String.fromCharCode.apply(null,d)}const m=atob(l);c=new Uint8Array(m.length);for(let p=0;p<c.length;p++)c[p]=m.charCodeAt(p)}a=c[0]===73&&c[1]===73||c[0]===77&&c[1]===77}if(a){let l=c.buffer;n.contentTransferEncoding!=="base64"&&(l=new ArrayBuffer(e.length-o),c=new Uint8Array(l),c.set(e.subarray(o,e.length))),n.contentData=l,n.isValidImage=!0}break}if((t.start===""||n.contentID===t.start)&&n.contentType){if(n.contentType.includes("text")||n.contentType.includes("xml")){n.contentData=String.fromCharCode.apply(null,e.subarray(o,e.length));break}n.contentData=e.subarray(o,e.length)}}return n}const At=["nearest neighbor","bilinear","bicubic"],Et=["nearest","linear","cubic"],fe="response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode",Ot="response is not a supported multipart mediaType with inline tiff",Mt="response is base64 encoded which may impact layer display performance",Nt="server returns an exception",J=new Set(["1.0.0","1.1.0","1.1.1","1.1.2","2.0.1"]);let z=class extends Ve{constructor(){super(...arguments),this.datasetFormat="WCSServer",this.tileType="Raster"}get rasterId(){return`${this.url}-${this.coverageId}-${this.version}`}async fetchRawTile(e,t,i,r={}){if(this.isBlockOutside(e,t,i))return null;const{nativePixelSize:n,spatialReference:o}=this.rasterInfo,s=2**e,a=n.x*s,c=n.y*s,{blockWidth:l,blockHeight:u}=this.getBlockWidthHeight(e),{origin:m}=this.rasterInfo.storageInfo.tileInfo,p=this.getTileExtent({x:a,y:c},t,i,m,o,[l,u]),d=this.rasterInfo.extent,f=p.xmax>d.xmax,h=p.ymin<d.ymin,g=f||h;let v=p,b=l,C=u;if(g&&(v=p.clone().intersection(d),v!=null&&(f&&(b=Math.floor((v.xmax-v.xmin)/a),v.xmax=v.xmin+a*b),h&&(C=Math.floor((v.ymax-v.ymin)/c),v.ymin=v.ymax-c*C))),v==null||b<=1||C<=1)return null;const I=await this._getCoverage(v,b,C,s,r);if(!I)return null;const{coverageDescription:L}=this.coverageInfo,{noDataValue:q,multidimensionalInfo:M}=this.rasterInfo,{multidimensionalDefinition:U}=r;let j;if(M!=null&&U!=null&&U.length){const Y=U[0].variableName;L.version==="2.0"?j=L.rangeType[0].find(x=>x.name===Y)?.nilValue:L.version==="1.1"&&(j=L.range.find(x=>x.identifier===Y)?.nullValues)}const H=j??q,N=await this.decodePixelBlock(I,{width:b,height:C,planes:null,pixelType:null,tiffNoDataValue:Array.isArray(H)?H[0]:H,matchAllNoData:!0});if(N==null)return null;if(N&&(N.width!==b||N.height!==C))throw new k("wcsraster-fetch",`the response has unexpected dimension width: ${N.width}, height: {pixelBlock.height}`);return g?Ke(N,{x:0,y:0},{width:u,height:u}):N}async _open(e){const{customFetchParameters:t}=this.ioConfig,i=e?.signal,r=await Tt(this.url,{version:t?.version??this.version,customParameters:t,signal:i});if(this.capabilities=r,!this.version){let p=r.version.slice(0,3);p==="2.0"||p==="1.1"||p==="1.0"?this.version=r.version:(p=r.supportedVersions.find(d=>d==="2.0.1")||r.supportedVersions.find(d=>d.startsWith("2.0"))||r.supportedVersions.find(d=>d.startsWith("1.1"))||r.supportedVersions.find(d=>d.startsWith("1.0"))||"1.0.0",this.version=p)}const{version:n}=this;if(!J.has(n))throw new k("wcsraster-open",`unsupported WCS version ${n}`);const{gridCoverages:o}=r;if(!o.length)throw new k("wcsraster-open","cannot find rectified grid coverages");this.coverageId??=o[0].id;const{coverageId:s}=this,a=o.find(p=>p.id===s);if(a==null)throw new k("wcsraster-open",`the coverageId ${s} does not exist in capabilities`);const c=await ie(this.url,{coverageIds:[s],version:n,customParameters:t,signal:i});if(this.coverageInfo=c[0],n.startsWith("2.0")){const{coverageInfo:p}=this;p.lonLatEnvelope=a.lonLatEnvelope,p.supportedInterpolations=le(r.supportedInterpolations),this._patchDimensionValues201(s,i)}this.datasetName=this.coverageInfo.title;const{rasterInfo:l}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(l,512,512),this._set("rasterInfo",l),l.spatialReference==null)throw new k("wcsraster-open",`coverage without spatial reference is not supported: ${s}`);const{pixelType:u,bandCount:m}=await this._getPixelTypeAndBandCount(i);l.pixelType=u,l.bandCount===1&&m>1&&(l.bandCount=m),this.updateTileInfo()}async _patchDimensionValues201(e,t){const{coverageInfo:i}=this,r=i.rasterInfo.multidimensionalInfo?.variables,n=J.has("1.1.2")?"1.1.2":J.has("1.1.1")?"1.1.1":J.has("1.1.0")?"1.1.0":null,{customFetchParameters:o}=this.ioConfig;if(r&&n)try{const s=this.url.includes("/ImageServer/"),a=e.length>8&&e.startsWith("Coverage")&&s?e.slice(8):e,c=await ie(this.url,{coverageIds:[a??e],version:n,customParameters:o,signal:t}).catch(()=>{if(a)return ie(this.url,{coverageIds:[e],version:n,customParameters:o,signal:t})}),l=c?.[0].rasterInfo.multidimensionalInfo?.variables;if(l)for(const u of r){const m=l.find(({name:p})=>p===u.name);if(m?.dimensions?.length)for(let p=u.dimensions.length-1;p>=0;p--){const d=u.dimensions[p],f=m.dimensions.find(({name:h})=>h===d.name);f?f.values&&f.extent?.join(",")===d.extent?.join(",")&&(u.dimensions[p]={...d,values:f.values}):s&&u.dimensions.splice(p,1)}}}catch{}}async _getPixelTypeAndBandCount(e){const{pixelSize:t,extent:i,multidimensionalInfo:r}=this.rasterInfo,n=i.center,o=new B({xmin:n.x-t.x,xmax:n.x+t.x,ymin:n.y-t.y,ymax:n.y+t.y,spatialReference:i.spatialReference});let s=[];if(r!=null){const f=r.variables[0];s=[],f.dimensions.forEach(h=>{s.push(new Be({variableName:f.name,dimensionName:h.name,values:h.hasRegularIntervals?h.extent?.[0]:h.values?.[0],isSlice:!0}))})}const{coverageDescription:a}=this.coverageInfo,c={interpolation:"nearest",multidimensionalDefinition:s,signal:e},{version:l}=a,{ioConfig:u}=this,m=l==="2.0"&&u.allowAnyMediaType==null||l==="1.1"&&u.use2GridOffsets==null;let p;try{p=await this._getCoverage(o,2,2,1,c,!0)}catch(f){if(!m)throw f;if(l==="1.1"){if(!f.details?.isResolutionMismatch)throw f;u.use2GridOffsets=!0}}if(!p&&m&&(l==="2.0"&&(u.allowAnyMediaType=!0),p=await this._getCoverage(o,2,2,1,c),p&&te.getLogger(this).warn("wcsraster:getcoverage",fe)),!p)throw new k("wcsraster-open","unable to determine pixel type");const d=await this.decodePixelBlock(p,{width:2,height:2,planes:null,pixelType:null});if(d==null)throw new k("wcsraster-open","unable to determine pixel type");return{pixelType:d.pixelType,bandCount:d.getPlaneCount()??0}}async _getCoverage(e,t,i,r,n,o=!1){const{coverageDescription:s}=this.coverageInfo,{version:a}=s,c=a==="2.0"?this._getCoverage201Parameters(e,t,i,r,n,s):a==="1.1"?this._getCoverage110Parameters(e,t,i,n,s):this._getCoverage100Parameters(e,t,i,n),l=a==="2.0"?await this.request(this._constructWCS201Url(c),{signal:n.signal,responseType:"array-buffer"}):await this.request(this.url,{query:c,signal:n.signal,responseType:"array-buffer"});if(a==="1.0")return l.data;if(a==="2.0"&&this.ioConfig.allowAnyMediaType!==!1&&Je(l.data)==="tiff")return o&&(this.ioConfig.allowAnyMediaType=!0,te.getLogger(this).warn("wcsraster:getcoverage",fe)),l.data;const u=Lt(l);if(u.isMultipart&&u.data){const f=u.data.find(h=>h.isValidImage);return o&&f?.contentTransferEncoding==="base64"&&te.getLogger(this).warn("wcsraster:getcoverage",Mt),f?.contentData}const m=new Uint8Array(l.data,0,Math.min(l.data.byteLength,2e3)),p=String.fromCharCode.apply(null,m).toLowerCase().includes("exception"),d=p&&String.fromCharCode.apply(null,m).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");throw p?new k("wcsraster:getcoverage",Nt,{isResolutionMismatch:d}):new k("wcsraster:getcoverage",Ot)}_getInterpolationIndex(e){return e&&this.coverageInfo.supportedInterpolations?.includes(e)?e==="nearest"?0:e==="bilinear"?1:e==="cubic"?2:0:0}_getCoverage100Parameters(e,t,i,r){const n=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,o=e.spatialReference.wkid,s=(this.coverageInfo.supportedFormats||[]).find(f=>f.toLowerCase().includes("tiff"))||"GEOTIFF",{bandIds:a,interpolation:c}=r,l=this._getInterpolationIndex(c),u=a?a.map(f=>this.coverageInfo.bandNames[f]):null,m=At[l],{multidimensionalDefinition:p}=r;let d;if(p!=null&&this.rasterInfo.multidimensionalInfo!=null){let h=p.find(g=>g.dimensionName==="StdTime")?.values;h&&h.length>0&&(Array.isArray(h[0])&&(h=h[0]),d=h.map(g=>Q(g)).join(","))}return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:s,crs:`EPSG:${o}`,bbox:n,width:t,height:i,time:d,interpolation:m,band:u?.join(",")}}_getCoverage110Parameters(e,t,i,r,n){const{multidimensionalDefinition:o,bandIds:s,interpolation:a}=r,c=e.spatialReference.wkid,l=`urn:ogc:def:crs:EPSG::${c}`,u=(this.coverageInfo.supportedFormats||[]).find(R=>R.toLowerCase().includes("tiff"))||"image/tiff",m=this._getInterpolationIndex(a),p=Et[m],d=a==null||this.coverageInfo.supportedInterpolations?.indexOf(a)===0,f=n.domain.spatialDomain,h=f.origin.x<=f.envelope.xmin&&f.origin.y<=f.envelope.ymin,g=e.width/t,v=e.height/i*(h?1:-1),b=h?[e.xmin,e.ymin]:[e.xmin,e.ymax],C=f.useEPSGAxis&&ye(c),I=C?`${b[1]},${b[0]}`:`${b[0]},${b[1]}`,L=this.ioConfig.use2GridOffsets,q=C?L?`${v},${g}`:`${v},0,0,${g}`:L?`${g},${v}`:`${g},0,0,${v}`,M=g/2,U=e.xmin+M,j=e.xmax-M,H=Math.abs(v)/2,N=e.ymin+H,Y=e.ymax-H,K=C?`${N},${U},${Y},${j},${l}`:`${U},${N},${j},${Y},${l}`,x=n.range.find(R=>R.axis.some(F=>F.identifier.toLowerCase().includes("band")));let G,E=x&&p&&s?d?`${x.identifier}[${x.axis[0].identifier}[${s.join(",")}]]`:`${x.identifier}:${p}[${x.axis[0].identifier}[${s.join(",")}]]`:null;if(o!=null&&o.length)for(let R=0;R<o.length;R++){let F=o[R].values;const V=o[R].dimensionName?.toLowerCase(),X=o[R].variableName?.toLowerCase(),_=n.range.find(W=>W.identifier.toLowerCase()===X);if(F.length>0){if(Array.isArray(F[0])&&(F=F[0]),V==="stdtime")G=F.map(W=>Q(W)).join(",");else if(_){const W=_.axis.find(Ie=>Ie.identifier.toLowerCase()===V);W&&(E=d?_.identifier+"["+W.identifier+"["+F.join(",")+"]]":_.identifier+":"+p+"["+W.identifier+"["+F.join(",")+"]]")}}R===o.length-1&&_&&!E&&(E=d?_.identifier:_.identifier+":"+p)}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:u,crs:`EPSG:${c}`,boundingbox:K,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:I,gridOffsets:q,gridBaseCRS:l,timeSequence:G,rangeSubset:E}}_getCoverage201Parameters(e,t,i,r,n,o){const{multidimensionalDefinition:s,interpolation:a}=n,c=this._getInterpolationIndex(a);let l=null;const{supportedInterpolations:u}=this.capabilities;if(u?.length)switch(c){case 0:l=u.find(x=>x.toLowerCase().includes("nearest"));break;case 1:l=u.find(x=>x.toLowerCase().includes("linear"));break;case 2:l=u.find(x=>x.toLowerCase().includes("cubic")||x.toLowerCase().includes("quadratic"))}const m=(this.coverageInfo.supportedFormats||[]).find(x=>x.toLowerCase().includes("tiff"))||"image/tiff",{bandNames:p}=this.coverageInfo,{boundedBy:d,domainSet:f,rangeType:h}=o,g=d.isEastFirst?0:1,v=1-g,{axisLabels:b}=d,C=b[g],I=b[v],L=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,q=L,M=[];M.push(`${C}(${e.xmin},${e.xmax})`),M.push(`${I}(${e.ymin},${e.ymax})`);const U=[];if(b.length>2)for(let x=2;x<b.length;x++){const G=f.origin[x];if(b[x].toLowerCase().includes("time")){let E=G.toString();d.uomLabels?.[x].toLowerCase().includes("ole")&&(U.push(b[x]),E=Q(G,!0)),M.push(b[x]+",http://www.opengis.net("+E+")")}else M.push(b[x]+",http://www.opengis.net("+G+")")}let j=null;if(s!=null&&s.length){const x=[];h.forEach(E=>E.forEach(R=>x.push(R.name)));const G=[];for(let E=0;E<s.length;E++){const R=b.find(V=>V===s[E].dimensionName),F=x.find(V=>V===s[E].variableName);if(G.includes(F)||G.push(F),R){let V=s[E].values;if(V.length>0){Array.isArray(V[0])&&(V=V[0]);let X="";X=R.toLowerCase().includes("time")?V.map(W=>Q(W)).join(","):V.join(",");const _=M.findIndex(W=>W.startsWith(R+",http://www.opengis.net"));_===-1&&M.push(R+",http://www.opengis.net("+X+")"),_===-1||M[_].includes("("+X+")")||M.splice(_,1,R+",http://www.opengis.net("+X+")")}}}G.length&&(j=G.join(","))}else p?.length>=2&&(j=(n.bandIds?n.bandIds.map(x=>p[x]):p).join(","));const H=M.join("&subset="),N=!o.domainSet.hasSameAxisLabelsAsBoundedBy&&this.ioConfig.allowScaleFactor!==!1,Y=N?null:`${C}(${t}),${I}(${i})`,K=N?1/r:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:j,interpolation:l,scaleSize:Y,scaleFactor:K,subset:H,format:m,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:L,subsettingcrs:q}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},i=[];return Object.keys(t).forEach(r=>{const n=t[r];n!=null&&(r==="subset"?typeof n=="string"&&n.split("&subset=").forEach(o=>{o&&i.push(`subset=${encodeURIComponent(o)}`)}):i.push(`${r}=${encodeURIComponent(n)}`))}),`${encodeURI(this.url)}?${i.join("&")}`}};function Q(e,t=!1){return(t?new Date(ne(e)):new Date(e)).toISOString()}$([D({type:String,json:{write:!0}})],z.prototype,"datasetFormat",void 0),$([D({readOnly:!0})],z.prototype,"tileType",void 0),$([D({type:String,json:{write:!0}})],z.prototype,"version",void 0),$([D({type:String,json:{write:!0}})],z.prototype,"coverageId",void 0),$([D({readOnly:!0})],z.prototype,"rasterId",null),z=$([ge("esri.layers.support.rasterDatasets.WCSRaster")],z);const Vt=new Set(["milliseconds","seconds","minutes","hours","days","weeks","months","years","decades","centuries"]);let T=class extends Me(He(Fe(We(Ne(ke(qe(ze(Ue(Re(Le(Oe))))))))))){constructor(...e){super(...e),this.coverageId=null,this.version=null,this.isReference=null,this.graphicOrigin=new tt(this),this.legendEnabled=!0,this.noData=0,this.operationalLayerType="WCS",this.type="wcs",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this._debouncedSaveOperations=$e(async(t,i,r)=>{const{save:n,saveAs:o}=await Se(()=>import("./imageryUtils-CQQnUiLM.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]));switch(t){case 0:return n(this,i);case 1:return o(this,r,i)}})}normalizeCtorArgs(e,t){return typeof e=="string"?{url:e,...t}:e}load(e){const t=e!=null?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["WCS"]},e).catch(De).then(()=>this._openRaster(t))),Promise.resolve(this)}get renderer(){return super.renderer}set renderer(e){super.renderer=e}get coverageInfo(){return this.raster.coverageInfo}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){const e=[Ye("Pixel Value")],t=this.raster?.rasterInfo??this.serviceRasterInfo,i=t?.multidimensionalInfo;if(i){const r=Xe(i);e.push(...r)}return e}createPopupTemplate(e){return Qe({fields:this.rasterFields,title:this.title},e)}async save(e){return this._debouncedSaveOperations(0,e)}async saveAs(e,t){return this._debouncedSaveOperations(1,t,e)}async _openRaster(e){const t=new z({url:this.url,version:this.version,coverageId:this.coverageId,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters}});if(await t.open({signal:e}),!t.rasterInfo)throw t.destroy(),new k("wcs-layer:load","cannot load resources on "+this.url);const{rasterInfo:i}=t;i.noDataValue==null&&(i.noDataValue=this.noData),this._set("serviceRasterInfo",i),this._set("spatialReference",i.spatialReference),this.title==null&&this.setAtOrigin("title",t.datasetName,"service"),this.coverageId==null&&this.setAtOrigin("coverageId",t.coverageInfo.id,"service"),this.version==null&&t.version&&this.setAtOrigin("version",t.version,"service"),this.setAtOrigin("tileInfo",t.rasterInfo.storageInfo.tileInfo,"service");const{multidimensionalInfo:r}=i;if(r!=null){const n=r.variables[0].dimensions.find(({name:o})=>o==="StdTime");if(n){let o=n.extent?.[0]??n.values[0];Array.isArray(o)&&(o=o[0]);let s=n.extent?.[1]??n.values[n.values.length-1];Array.isArray(s)&&(s=s[1]);const a=Vt.has(n.intervalUnit?.toLowerCase())?n.intervalUnit?.toLowerCase():null;this.set("timeInfo",{startField:"StdTime",fullTimeExtent:{start:o,end:s},timeZone:null,interval:a?{value:n.interval,unit:a}:null})}}this.raster=t,this._configDefaultSettings(),this.addHandles(Pe(()=>this.customParameters,n=>this.raster.ioConfig.customFetchParameters=n))}};$([D({type:String,nonNullable:!0,json:{name:"wcsInfo.coverageId",write:{isRequired:!0,ignoreOrigin:!0}}})],T.prototype,"coverageId",void 0),$([D()],T.prototype,"coverageInfo",null),$([D({type:["1.0.0","1.1.0","1.1.1","1.1.2","2.0.1"],nonNullable:!0,json:{name:"wcsInfo.version",write:{isRequired:!0,ignoreOrigin:!0}}})],T.prototype,"version",void 0),$([D({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],T.prototype,"isReference",void 0),$([D({json:{read:!0,write:!0}})],T.prototype,"blendMode",void 0),$([D({readOnly:!0,clonable:!1})],T.prototype,"graphicOrigin",void 0),$([D(_e)],T.prototype,"legendEnabled",void 0),$([D({type:["show","hide"]})],T.prototype,"listMode",void 0),$([D()],T.prototype,"noData",void 0),$([D({type:["WCS"]})],T.prototype,"operationalLayerType",void 0),$([D()],T.prototype,"raster",void 0),$([D({readOnly:!0})],T.prototype,"type",void 0),$([D(Ge)],T.prototype,"popupEnabled",void 0),$([D({type:Te,json:{name:"popupInfo",write:!0}})],T.prototype,"popupTemplate",void 0),$([D({readOnly:!0})],T.prototype,"defaultPopupTemplate",null),$([D({readOnly:!0,type:[ce]})],T.prototype,"fields",void 0),$([D({readOnly:!0,type:[ce]})],T.prototype,"rasterFields",null),T=$([ge("esri.layers.WCSLayer")],T);const Vn=T;export{Vn as default};
