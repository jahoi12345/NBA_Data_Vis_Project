import{q as D,w as _,i as T,be as q,a4 as z,m as L,I as m,a5 as S,S as x,a2 as C,bf as I,Y as d,H as y,G as P}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{H as O,A as M}from"./Point-BfTTZoMu-DeJwQYfh.js";import{M as U}from"./LRUCache-fy84PBMi-Y56WPIvD.js";import{j,o as H}from"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import{e as k}from"./TileKey-CXWFOqOI-Lra6v-mg.js";import{h as N}from"./memoryEstimations-Bd726a_p-0cVCY2Jz.js";function F(t,e=!1){return t<=I?e?new Array(t).fill(0):new Array(t):new Uint32Array(t)}class w{constructor(e){E(e);const{location:a,data:i}=e;this.location=Object.freeze(C(a));const l=this.location.width,s=this.location.height;let n=!0,o=!0;const c=Math.ceil(l*s/32),r=F(c);let h=0;for(let f=0;f<i.length;f++){const p=f%32;i[f]?(o=!1,r[h]|=1<<p):n=!1,p===31&&++h}o?(this._availability="unavailable",this.byteSize=40):n?(this._availability="available",this.byteSize=40):(this._availability=r,this.byteSize=40+N(r))}getAvailability(e,a){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const i=(e-this.location.top)*this.location.width+(a-this.location.left),l=i%32,s=i>>5,n=this._availability;return s<0||s>n.length?"unknown":n[s]&1<<l?"available":"unavailable"}static fromDefinition(e,a){const i=e.service.request||O,{row:l,col:s,width:n,height:o}=e,c={query:{f:"json"}};return a=a?{...c,...a}:c,i(R(e),a).then(r=>r.data).catch(r=>{if(r?.details?.httpStatus===422)return{location:{top:l,left:s,width:n,height:o},valid:!0,data:new Array(n*o).fill(0)};throw r}).then(r=>{if(r.location&&(r.location.top!==l||r.location.left!==s||r.location.width!==n||r.location.height!==o))throw new m("tilemap:location-mismatch","Tilemap response for different location than requested",{response:r,definition:{top:l,left:s,width:n,height:o}});return w.fromJSON(r)})}static fromJSON(e){return Object.freeze(new w(e))}}function $(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function R(t){let e;if(t.service.tileServers?.length){const i=t.service.tileServers;e=`${i&&i.length?i[t.row%i.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}else e=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;const a=t.service.query;return a&&(e=`${e}?${a}`),e}function E(t){if(!t?.location)throw new m("tilemap:missing-location","Location missing from tilemap response");if(t.valid===!1)throw new m("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new m("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new m("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new m("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var v;function A(t,e,a){return new m("tile-map:tile-unavailable","Tile is not available",{level:t,row:e,col:a})}let u=class extends D{static{v=this}constructor(t){super(t),this._pendingTilemapRequests={},this.request=O,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new U(2097152),this.addHandles(j(()=>{const{layer:t}=this;return[t?.parsedUrl,t?.tileServers,t?.apiKey,t?.customParameters]},()=>this._initializeTilemapDefinition(),H))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(t,e,a){if(!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD)return"unavailable";const i=this._tilemapFromCache(t,e,a,this._tmpTilemapDefinition);return i?i.getAvailability(e,a):"unknown"}fetchAvailability(t,e,a,i){return!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD?Promise.reject(A(t,e,a)):this._fetchTilemap(t,e,a,i).catch(l=>l).then(l=>{if(l instanceof w){const s=l.getAvailability(e,a);if(s==="unavailable")throw A(t,e,a);return s}if(_(l))throw l;return"unknown"})}fetchAvailabilityUpsample(t,e,a,i,l){i.level=t,i.row=e,i.col=a;const s=this.layer.tileInfo;s.updateTileInfo(i);const n=this.fetchAvailability(t,e,a,l).catch(o=>{if(_(o))throw o;if(s.upsampleTile(i))return this.fetchAvailabilityUpsample(i.level,i.row,i.col,i,l);throw o});return this._fetchAvailabilityUpsamplePrefetch(t,e,a,l,n),n}async _fetchAvailabilityUpsamplePrefetch(t,e,a,i,l){if(!this._prefetchingEnabled)return;const s=`prefetch-${t}-${e}-${a}`;if(this.hasHandles(s))return;const n=new AbortController;l.then(()=>n.abort(),()=>n.abort());let o=!1;const c=T(()=>{o||(o=!0,n.abort())});if(this.addHandles(c,s),await q(10,n.signal).catch(()=>{}),o||(o=!0,this.removeHandles(s)),z(n))return;const r=new k(t,e,a),h={...i,signal:n.signal},f=this.layer.tileInfo;for(let p=0;v._prefetches.length<v._maxPrefetch&&f.upsampleTile(r);++p){const b=this.fetchAvailability(r.level,r.row,r.col,h);v._prefetches.push(b);const g=()=>{v._prefetches.removeUnordered(b)};b.then(g,g)}}static{this._maxPrefetch=4}static{this._prefetches=new L({initialSize:v._maxPrefetch})}static cleanupTilemapCache(){this._prefetches.prune()}_fetchTilemap(t,e,a,i){if(!this.layer.tileInfo.lodAt(t)||t<this.effectiveMinLOD||t>this.effectiveMaxLOD)return Promise.reject(new m("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`));const l=this._tmpTilemapDefinition,s=this._tilemapFromCache(t,e,a,l);if(s)return Promise.resolve(s);const n=i?.signal;return i={...i,signal:null},new Promise((o,c)=>{S(n,()=>c(x()));const r=$(l);let h=this._pendingTilemapRequests[r];if(!h){h=w.fromDefinition(l,i).then(p=>(this._tilemapCache.put(r,p,p.byteSize),p));const f=()=>{delete this._pendingTilemapRequests[r]};this._pendingTilemapRequests[r]=h,h.then(f,f)}h.then(o,c)})}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:t,apiKey:e,customParameters:a}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:t.path,query:M({...t.query,...a,token:e??t.query?.token}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(t,e,a,i){i.level=t,i.row=e-e%this.size,i.col=a-a%this.size;const l=$(i);return this._tilemapCache.get(l)}get test(){}};d([y({constructOnly:!0})],u.prototype,"layer",void 0),d([y({constructOnly:!0})],u.prototype,"minLOD",void 0),d([y({constructOnly:!0})],u.prototype,"maxLOD",void 0),d([y({constructOnly:!0})],u.prototype,"request",void 0),d([y({constructOnly:!0})],u.prototype,"size",void 0),u=v=d([P("esri.layers.support.TilemapCache")],u);export{u};
