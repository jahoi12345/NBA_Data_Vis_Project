import{e as Z,a2 as D,ar as Q,Y as W,H as S,G as Y}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{b as w,F as K,ah as O,af as V,aJ as X,aG as tt,S as et,ar as rt,aE as at,aU as st,a5 as nt,f as ot}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{k as it,A as lt,$ as ct,l as ht,F as pt,r as G,J as ut}from"./vec32-CewSdTn3-DHOFKD0R.js";import{t as m}from"./collectionUtils-jDyktm0P-ArdXNs6F.js";import{Z as ft,P as z,C as mt,_ as J}from"./Polygon-D6wEPb3W-CpL9Efjx.js";import{h as dt}from"./euclideanLengthMeasurementUtils-CpHh36Dt-B3Q3Npaw.js";import{n as yt,o as xt}from"./Polyline-CoiTLswR-BLagWJLS.js";import{c as gt}from"./distanceOperator-DGmm_87g-DnhsW2Ef.js";import{c as Mt,u as wt}from"./simplifyOperator-bRe3zzdW-Ci0cJetU.js";import{g as Rt}from"./mat2d-DlTglBkI--S7WYOjk.js";import{n as q,l as Tt}from"./mat2df64-DFLy2zOC-BU6AmJok.js";import{p as vt,o as Wt}from"./quat-B7J5v7rV-i-DOMCm_.js";import{t as B}from"./quatf64-CCm9z-pX-CQ7_sSji.js";var k;let M=k=class extends z{constructor(e){super(e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const e=this.center,t=this.numberOfPoints;if(this.hasZ=e?.hasZ??!1,this.rings.length!==0||!e)return;const a=V(this.radius,this.radiusUnit,"meters"),s=e.spatialReference;let o,r="geographic";if(s.isWebMercator?r="webMercator":((s.wkid&&X[s.wkid])!=null||(s.wkt2||s.wkt)&&tt(s.wkt2||s.wkt))&&(r="projected"),this.geodesic){let n;switch(r){case"webMercator":n=et(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=e}o=this._createGeodesicCircle(n,a,t),r==="webMercator"&&(o=rt(o))}else{let n;r==="webMercator"||r==="projected"?n=a/at(e.spatialReference):r==="geographic"&&(n=st(a,"meters",nt(e.spatialReference).radius)),o=this._createPlanarCircle(e,n,t)}this.spatialReference=o.spatialReference,this.addRing(o.rings[0])}clone(){const{center:e,numberOfPoints:t,radius:a,radiusUnit:s,geodesic:o}=this;return new k({center:e?.clone(),numberOfPoints:t,radius:a,radiusUnit:s,geodesic:o})}_createGeodesicCircle(e,t,a){const s=[],o=[e.x,e.y];for(let r=0;r<360;r+=360/a){const n=this.hasZ?[0,0,e.z??0]:[0,0];dt(n,o,r,t,ot.WGS84),s.push(n)}return s.push(s[0]),new z({rings:[s]})}_createPlanarCircle(e,t,a){const s=[],o=2*Math.PI/a;for(let r=0;r<a;++r){const n=o*r,i=[e.x+Math.cos(-n)*t,e.y+Math.sin(-n)*t];this.hasZ&&i.push(e.z??0),s.push(i)}return s.push(s[0]),new z({spatialReference:e.spatialReference,rings:[s]})}};W([S({type:w})],M.prototype,"center",void 0),W([S()],M.prototype,"geodesic",void 0),W([S()],M.prototype,"numberOfPoints",void 0),W([S()],M.prototype,"radius",void 0),W([S()],M.prototype,"radiusUnit",void 0),M=k=W([Y("esri.geometry.Circle")],M);const bt=M;function I(e,t,a=null){return a!=null?[e,t,a]:[e,t]}function l(e,t,a=null){return a!=null?{x:e,y:t,z:a}:{x:e,y:t}}class j{constructor(t){this.spatialReference=t}mapToLocalMultiple(t){return t.map(a=>this.mapToLocal(a)).filter(Z)}get doUnnormalization(){return!1}}let Ft=class extends j{constructor(e,t,a=null){super(t),this._defaultZ=a,this.transform=q(),this.transformInv=q(),this.transform=Tt(e),Rt(this.transformInv,this.transform)}makeMapPoint(e,t){return I(e,t,this._defaultZ)}mapToLocal(e){return l(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return I(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}},St=class extends j{constructor(e,t){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=m(),this.tangentFrameUpWS=m(),this.tangentFrameRightWS=m(),this.tangentFrameForwardWS=m(),this.localFrameRightWS=m(),this.localFrameUpWS=m(),this.worldToLocalTransform=B(),this.localToWorldTransform=B(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=t,this.defaultZ=t.hasZ?t.z:null;const a=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const s=m();it(s,this.tangentFrameForwardWS,lt(a,this.tangentFrameForwardWS)),ct(this.localFrameRightWS,a,s),ht(this.localFrameRightWS,this.localFrameRightWS),pt(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),vt(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),Wt(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,t){return I(e,t,this.defaultZ)}mapToLocal(e){const t=m();this.view.renderCoordsHelper.toRenderCoords(new w({x:e[0],y:e[1],spatialReference:this.spatialReference}),t),G(t,t,this.worldToLocalTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new w({spatialReference:this.view.spatialReference}));return a!=null?l(a.x/this.scale,a.y/this.scale):null}localToMap(e){const t=m();this.view.renderCoordsHelper.toRenderCoords(new w({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),t),G(t,t,this.localToWorldTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new w({spatialReference:this.view.spatialReference}));return a!=null?I(a.x,a.y,this.defaultZ):null}};function Bt(e,t){if(e.type==="2d")return new Ft(e.state.transform,e.spatialReference,t.length>2?t[2]:null);if(e.type==="3d"){const a=t.length>2?new w({x:t[0],y:t[1],z:t[2],spatialReference:e.spatialReference}):new w({x:t[0],y:t[1],spatialReference:e.spatialReference});return new St(e,a)}return null}function R(e,t){const a=new w({x:e[0],y:e[1],spatialReference:t});return e.length>2&&(a.z=e[2]),a}function Ot(e,t){return new xt({points:e,spatialReference:t})}function Jt(e,t,a){const s=new yt({paths:e,spatialReference:t});return a&&J(s),s}function L(e,t,a,s=!0){const o=D(e);o.forEach(n=>{const i=n[0],p=n[n.length-1];Q(i,p)&&n.length!==1||n.push(n[0])});let r=new z({rings:o,spatialReference:t});return r.rings.forEach(n=>{mt(n)||n.reverse()}),a&&J(r),s&&!Mt(r)&&O(t)&&(r=wt(r)||r),r}function jt(e,t,a){const s=t.mapToLocalMultiple(e),o=[],r={x:s[0].x,y:s[0].y},n={x:s[1].x,y:s[1].y},i=Math.round(n.x-r.x),p=Math.round(n.y-r.y),u=Math.max(Math.abs(i),Math.abs(p));if(a){const c={x:r.x+u,y:r.y+u},d={x:r.x-u,y:r.y-u};o.push(l(c.x,d.y),l(d.x,d.y),l(d.x,c.y),l(c.x,c.y))}else{const c={x:i>0?r.x+u:r.x-u,y:p>0?r.y+u:r.y-u};o.push(l(r.x,r.y),l(c.x,r.y),l(c.x,c.y),l(r.x,c.y))}return A(L([o.map(c=>t.localToMap(c)).filter(Z)],t.spatialReference,t.doUnnormalization,!0),o,t)}function At(e,t,a){let s=t.mapToLocalMultiple(e);if(s.length===1){const i=s[0];s=[l(i.x-48,i.y+48),l(i.x+48,i.y-48),l(i.x+48,i.y-48),l(i.x-48,i.y+48)]}const o=[],r={x:s[0].x,y:s[0].y},n={x:s[1].x,y:s[1].y};if(a){const i=Math.round(n.x-r.x),p=Math.round(n.y-r.y);o.push(l(r.x-i,r.y-p),l(n.x,r.y-p),l(n.x,n.y),l(r.x-i,n.y))}else o.push(l(r.x,r.y),l(n.x,r.y),l(n.x,n.y),l(r.x,n.y));return A(L([o.map(i=>t.localToMap(i)).filter(Z)],t.spatialReference,t.doUnnormalization,!0),o,t)}function A(e,t,a){const s=C(t[3],t[2],a),o=C(t[1],t[2],a),r=C(t[0],t[1],a),n=C(t[0],t[3],a);return{geometry:e,midpoints:s!=null&&o!=null&&r!=null&&n!=null?{top:s,right:o,bottom:r,left:n}:null}}function C(e,t,a){b[0]=e.x,b[1]=e.y,b[2]=0,F[0]=t.x,F[1]=t.y,F[2]=0,ut(b,b,F,.5),U.x=b[0],U.y=F[1],U.z=F[2];const s=a.localToMap(U);return s!=null?R(s,a.spatialReference):null}const U=l(0,0,0),b=m(),F=m();function Et(e,t,a,s){const o=t.mapToLocalMultiple(e);let r=null,n=null;if(a)r=o[0],n=o[1];else{const h=o[0],f=o[1],T=Math.round(f.x-h.x),v=Math.round(f.y-h.y),y=Math.max(Math.abs(T),Math.abs(v));r=l(T>0?h.x+y/2:h.x-y/2,v>0?h.y+y/2:h.y-y/2),n=l(Math.abs(T)>Math.abs(v)?r.x-y/2:r.x,Math.abs(T)>Math.abs(v)?r.y:r.y-y/2)}const i=t.localToMap(r),p=t.localToMap(n);if(i==null||p==null)return null;t.doUnnormalization&&ft([[i,p]],t.spatialReference);const u=R(i,t.spatialReference),c=R(p,t.spatialReference),d=K(t.spatialReference);let x=0;if(O(t.spatialReference))x=d*gt(u,c);else{const h=r.x-n.x,f=r.y-n.y;x=d*Math.sqrt(h*h+f*f)*1}const P=new bt({center:u,radius:x,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:L(P.rings,P.spatialReference,!1),center:u,edge:c}}function Nt(e,t,a){const s=t.mapToLocalMultiple(e),o=s[0],r=s[1],n=Math.round(r.x-o.x),i=Math.round(r.y-o.y),p=l(a?o.x:o.x+n/2,a?o.y:o.y+i/2),u=a?n:n/2,c=a?i:i/2,d=60,x=[],P=2*Math.PI/d;function h(g){const E=Math.cos(g),N=Math.sin(g);return l(u*E+p.x,c*N+p.y)}for(let g=0;g<d;g++)x.push(h(g*P));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=t,v=L([x.map(g=>t.localToMap(g)).filter(Z)],f,T,!1),y=t.localToMap(h(Math.PI/2)),_=t.localToMap(h(0)),$=t.localToMap(h(-Math.PI/2)),H=t.localToMap(h(Math.PI));return{geometry:v,midpoints:y!=null&&_!=null&&$!=null&&H!=null?{top:R(y,f),right:R(_,f),bottom:R($,f),left:R(H,f)}:null}}export{Ot as B,Nt as D,Bt as G,At as J,L,jt as N,Et as Q,Jt as q};
