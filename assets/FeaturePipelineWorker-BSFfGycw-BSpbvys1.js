const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/apiConverter-BAgvri9D-CJVft-_U.js","assets/Point2D-CMz7woHH-BVbGGL7p.js","assets/Envelope2D-mFnl8dXR-MYac-bfa.js","assets/ProjectionTransformation-PJc9H7Gq-Rbz84pUM.js","assets/Transformation2D-CrydmBdC-D4jE8w-_.js","assets/SimpleGeometryCursor-B92kdZ15-B1Z6elF7.js","assets/jsonMap-Bs3hmeCU-Cusd0Fmz.js","assets/OperatorDefinitions-DP7_WWTp-DP7_WWTp.js","assets/Extent-CgDMOSRD-CU1qE5Kr.js","assets/Point-BfTTZoMu-BAT2Wq6O.js","assets/index-CTl7hdrJ.js","assets/index-Cv2ko1Ob.css","assets/reader-DcGs6kKN-DHJfK-tm.js","assets/Polyline-CoiTLswR-BLagWJLS.js","assets/Polygon-D6wEPb3W-CpL9Efjx.js","assets/aaBoundingRect-CjwcS2F3-D7aII9DY.js","assets/mathUtils-PIGhLnI9-B1tKUlUb.js","assets/jsonConverter-DmBmaSz7-DAl7KiR-.js"])))=>i.map(i=>d[i]);
import{H as rr,_ as ir}from"./index-CTl7hdrJ.js";import{l as v,$ as St,a as ti,I as P,c4 as Ea,bC as Oa,aX as ws,c as vt,ce as Q,o as N,a8 as Ra,ab as za,ad as Da,q as Is,w as si,y as La,bQ as ri,bn as ne,v as G,e as Le,a5 as dt,bi as Ba,a2 as qa,cf as Na,F as ct,aU as Ga,Y as Z,H as ve,G as Ss}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{j as ft,I as ii}from"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import{l as w}from"./screenUtils-BitdhK1O-L0FLPAMi.js";import{F as vs,M as Ua}from"./workers-BEkgoq8Q-BNWfkyQs.js";import{p as $a}from"./TileInfo-Bz7QlefV-tjhen9qQ.js";import{s as T,n as Wa,f as Ke,e as ue,J as Va,q as ja,p as Ya,t as Ha,$ as A,c as pt,o as Xa,a as Qa}from"./definitions-Dvg4hMIw-CdK2DzFN.js";import{C as ai}from"./diffUtils-wTC1YzlE-JuqUWoWa.js";import{i as Za,C as Ka}from"./floatRGBA-D-Q4FzNN-BzjdY1tU.js";import{s as kt}from"./TileKey-C44YQC4_-BW7BBbYp.js";import{i as ni,r as ke,t as Ja}from"./streamLayerUtils-DFlbJ4P1-DFlbJ4P1.js";import{f as en}from"./DictionaryScriptEvaluator-G73uSGpN-Cn2sp0hZ.js";import{K as B}from"./labelPoint-4nqVL63d-Dz1LbGNv.js";import{P as we}from"./rasterizingUtils-CnBgARH0-BdMfGptJ.js";import{h as tn,P as sn,I as rn,a as ar,v as nr,b as or}from"./CIMSymbolHelper-CD2S7jie-Bc00obB6.js";import{F as oi}from"./Color-CERqXxxY-BuYn26eI.js";import{a1 as W,f as an,P as nn,F as q,az as cr,Y as Bt,u as on,l as lr,N as cn}from"./Polygon-D6wEPb3W-CpL9Efjx.js";import{N as se,R as y}from"./enums-B4pqBiXb-BO-3hS_8.js";import{R as ci,S as li,D as ln}from"./TurboLine-sjhG-uM1-BRrO10qB.js";import{j as hn,k as hi}from"./GeometryUtils-C354xUs0-CG8X9WjO.js";import{Y,O as D}from"./OptimizedFeature-CwRGZPwv-Ddclhn0A.js";import{s as hr,y as un}from"./mathUtils-PIGhLnI9-B1tKUlUb.js";import{O as Ge,A as Me,d as es,j as ts,S as dn}from"./mat2d-DlTglBkI--S7WYOjk.js";import{f as j,y as fn}from"./mat2df32-Dpt2CT5P-CY1Hu5g0.js";import{r as Be,o as ss}from"./vec2f32-CaVKkSa6-BjkBmyoj.js";import{o as ye}from"./vec2f64-rIxtbMRN-Kai9mK1i.js";import{B as ui,X as pn,F as rs,a as mn,J as ur,K as _n,n as yn,E as Re,b as gn,c as di}from"./featureConversionUtils-BDA_FXJx-CUwkrHf5.js";import{a as xn}from"./Rect-BAnET0xx--LefF6x-.js";import{R as bn,X as dr,l as fi}from"./utils-DX2muIr3-DiPfFKSl.js";import{k as ks,G as wn}from"./ArcadeExpression-BlIRq-oN-DGzfhzBj.js";import{QueueProcessor as Ms}from"./QueueProcessor-D8z0mMzA-GcdBlDoB.js";import{f as Ts,H as In}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{W as Sn,v as vn,K as kn}from"./FixedIntervalBinParameters-8snYOK8a-BSPWw9c2.js";import{m as Xe}from"./FieldsIndex-CimK-TqD-CrSnohIk.js";import{m as Mn,l as Tn}from"./aaBoundingBox-Cn49X7ge-DORLZxoS.js";import{i as Fn}from"./optimizedFeatureQueryEngineAdapter-Bma9_B5X-BMDAgToU.js";import{h as pi,Y as Pn,M as Cn}from"./QueryEngine-J0SYKhS8-CFA9lsZ6.js";import{z as An,U as Fs,j as $e,$ as E,Z as is,M as En,C as Mt,s as mi,n as On,P as Tt,X as Rn,D as zn,A as fr,B as pr,d as Dn,N as mr,v as Ln,f as Bn,w as qn}from"./SourceChunkStore-CfCqYuFd-CCGk3ReM.js";import{g as Nn}from"./labelUtils-BtizwBfq-Zegx4520.js";import{H as Gn,G as _r}from"./lengthUtils-Dt1_RvOO-bleznLOi.js";import{y as _i,O as yi,Y as Un,L as yr,d as $n,a as gr,P as gi}from"./aaBoundingRect-CjwcS2F3-D7aII9DY.js";import{f as xi,o as Ps}from"./Query-BlS0WPDF-BdshFBMz.js";import{f as Wn,P as Vn,y as jn}from"./operatorGeodeticDensify-zIdepNh4-Crrv4uWX.js";import{e as Yn}from"./geodeticCurveType-CirnHLSB-CirnHLSB.js";import{x as Hn}from"./normalizeUtils-85zLqeMi-DCF9gKvo.js";import{i as Xn}from"./normalizeUtilsSync-DqNvil4L-CeJdnwwK.js";import{h as te,o as Qn}from"./memoryEstimations-Bd726a_p-0cVCY2Jz.js";import{r as Zn}from"./uuid-Oe6SV2kF-IYX19xBA.js";import{E as Kn}from"./displayFilterUtils-CIXGrQzt-Ck5cgHqb.js";import{d as Jn}from"./Layer-DZvC7bne-m1cEC_yw.js";import{q as bi}from"./quantizationUtils-Ceq-Uxsu-CDK8m1qL.js";import{p as xr}from"./ogcFeatureUtils-BtncCEPw-Dd5YqN1i.js";import{J as eo,v as br}from"./query-DeNEvEsQ-piAD5C2I.js";import{h as to}from"./pbf-2SIhMekG-LK438LAR.js";import{i as so}from"./FeatureIdInfo-iL5WjyEH-DzYZU4u5.js";import{B as ro,V as io}from"./pbfQueryUtils-DlZBMNQk-B4EJfzeq.js";import{Z as wi}from"./parquet-BvPtb2Qg-DEpjS4pk.js";import{I as ao}from"./StreamFeatureManager-DS8maxEM-BXarN2IM.js";import{createConnection as no}from"./createConnection-qpkJl2Gf-Bk84wmnb.js";import{l as oo}from"./ReactiveMap-B0by2bYu-DCsCfMj5.js";import{r as co}from"./UpdatingHandles-D2RI_3Hb-dwLPjVun.js";import"./intl-DRFqUect-ClAS7BRt.js";import"./date-IqUzANpt-bLKO9IDT.js";import"./collectionUtils-jDyktm0P-ArdXNs6F.js";import"./Extent-CgDMOSRD-CU1qE5Kr.js";import"./Polyline-CoiTLswR-BLagWJLS.js";import"./Font-BwmnW7d2-D-oIm_Md.js";import"./defaults-BDN9qxeN-CCVK4JpS.js";import"./SimpleFillSymbol-CDawtd9z-CWD2KI2D.js";import"./SimpleMarkerSymbol-BGAFRS9_-CVQ5NLIA.js";import"./lineMarkers-CDwLe3J6-CNUjJvs3.js";import"./TextSymbol-hRGhyDHs-C0NgASym.js";import"./UnknownTimeZone-B697BDFv-CBbtul7O.js";import"./projectionUtils-BGH_5_I3-BySNUA-B.js";import"./NormalizationBinParametersMixin-BK9wNkI3-BKYeOhDN.js";import"./mat4f64-q_b6UJoq-Dh6sWB_w.js";import"./LRUCache-fy84PBMi-Y56WPIvD.js";import"./WhereClause-BSVqskBz-DANRwfyr.js";import"./fieldType-DVUzXtk_-tUuvnZJM.js";import"./vec42-B8VM4vXb-BnA9MysM.js";import"./vec4f64-DPb6J-GU-C7c2DqbZ.js";import"./mat4f32-Djp3mnm5-DzYG3LYB.js";import"./mat4-C96X-Nn0-Do6fKsNS.js";import"./ClassBreaksDefinition-BGOzyovZ-K0U0wKo_.js";import"./Scheduler-CNrsbccs-Bcg8fWoS.js";import"./typeUtils-DqrRcjBx-ZWdHcSIJ.js";import"./Field-Cm_ZejYW-CwJZmSru.js";import"./normalizeUtilsCommon-CnhQye_A-zWtr51r8.js";import"./date-DCujAECq-DJRghk8M.js";import"./Queue-CYlrXMwB-CYJTUII-.js";import"./SimpleObservable-CvFyr0NA-DXpoMYph.js";import"./reader-DcGs6kKN-DHJfK-tm.js";import"./TileKey-CXWFOqOI-CcilLir8.js";import"./signal-BX9ezF8a-cf1Pn6io.js";import"./Version-BtYZEj58-LyRHDnSJ.js";import"./jsonUtils-CmpazY1u-ateEpj4Q.js";import"./BidiEngine-BvER9tXK-EFuB0NWZ.js";import"./OptimizedFeatureSet-BR8EEvDc-CgsRgxJh.js";import"./createFeatureId-CVwTD0fV-3fKpJDrk.js";import"./TimeOnly-BERR31kg-PKcKegNB.js";import"./enum-BzLwmiID-CcyIdWlQ.js";import"./timeZoneUtils-BSc7-7qA-BAv3h8mh.js";import"./DoubleArray-DExKNiTh-CvVpHySW.js";import"./WhereClauseCache-B0L2SmwV-BYc3WALz.js";import"./QueryEngineCapabilities-DJC_YILC-CshvWf3J.js";import"./utils-CUk96PkC-CThUWKre.js";import"./heatmapUtils-B-AXnq0l-G7fD8L97.js";import"./utils-BbtW4lHb-DKC09XMb.js";import"./utils-BEeBypEk-DQLTC4jR.js";import"./SnappingCandidate-DGkpYqI6-CfPvDre4.js";import"./quickselect-QQC62dOK-Br2Ahhru.js";import"./SimpleGeometryCursor-B92kdZ15-B1Z6elF7.js";import"./Cyclical-BLSxUpe7-Bj8R2Yk-.js";import"./utils-CylVuxNi-CqOfmBVG.js";import"./utils-Dpg4yj1D-BVnuoMV8.js";import"./geojson-DW2M5qxx-D1WgSKS9.js";import"./clientSideDefaults-3DdoYkYX-n_psRtPH.js";import"./defaultsJSON-GKolV7NZ-GKolV7NZ.js";import"./sourceUtils-Dk-KUMub-By9LvFgs.js";import"./queryZScale-CRP3Sh_E-0yf18ElE.js";const as=(t,e=as,s=e.f||(e.f=["assets/apiConverter-BAgvri9D.js","assets/Point2D-CMz7woHH.js","assets/Envelope2D-mFnl8dXR.js","assets/ProjectionTransformation-PJc9H7Gq.js","assets/Transformation2D-CrydmBdC.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/jsonMap-Bs3hmeCU.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/Extent-CgDMOSRD.js","assets/Point-BfTTZoMu.js","assets/reader-DcGs6kKN.js","assets/index-BzxsWNRw.js","assets/index-Cv2ko1Ob.css","assets/Polyline-CoiTLswR.js","assets/Polygon-D6wEPb3W.js","assets/aaBoundingRect-CjwcS2F3.js","assets/mathUtils-PIGhLnI9.js","assets/jsonConverter-DmBmaSz7.js"]))=>t.map(r=>s[r]),mt={Relative:0,Absolute:1};let lo=class{constructor(t){this._client=t,this.layerView=this._client.createInvokeProxy(""),this.container=this._client.createInvokeProxy("container"),this._eventLog=this._client.createInvokeProxy("eventLog")}onEvent(t){vs(this._eventLog.onEvent(t))}},Ue=class ns{static{this.byteSizeHint=7*Uint32Array.BYTES_PER_ELEMENT}static{this.estimatedMemory=40}constructor(e,s,r,i,a,n,o){this.instanceId=e,this.textureKey=s,this.indexStart=r,this.indexCount=i,this.vertexStart=a,this.vertexCount=n,this.overlaps=o}updateBaseOffsets(e){this.vertexStart+=e.vertexFrom,this.indexStart+=e.indexFrom}clone(){return new ns(this.instanceId,this.textureKey,this.indexStart,this.indexCount,this.vertexStart,this.vertexCount,this.overlaps)}static write(e,s,r,i,a,n,o,c){e.push(s),e.push(r),e.push(i),e.push(a),e.push(n),e.push(o),e.push(c)}serialize(e){return e.push(this.instanceId),e.push(this.textureKey),e.push(this.indexStart),e.push(this.indexCount),e.push(this.vertexStart),e.push(this.vertexCount),e.push(this.overlaps),e}static deserialize(e){const s=e.readInt32(),r=e.readInt32(),i=e.readInt32(),a=e.readInt32(),n=e.readInt32(),o=e.readInt32(),c=e.readInt32();return new ns(s,r,i,a,n,o,c)}};function Ii(t,e){if(e!==null){t.push(e.length);for(const s of e)s.serialize(t);return t}t.push(0)}function Si(t,e,s){const r=t.readInt32(),i=new Array(r);for(let a=0;a<i.length;a++)i[a]=e.deserialize(t,s);return i}let ho=class vi{static{this.byteSizeHint=2*Uint32Array.BYTES_PER_ELEMENT+Ue.byteSizeHint}static estimateMemory(e){return 24+Ue.estimatedMemory*e}constructor(e,s){this.id=e,this.sortKey=s,this.records=[]}serialize(e){return e.push(this.id),e.writeF32(this.sortKey),Ii(e,this.records),e}static deserialize(e){const s=e.readInt32(),r=e.readF32(),i=new vi(s,r);return i.records=Si(e,Ue)??[],i}};const uo=1.25;let lt=class{get length(){return this._pos}constructor(t,e){this._pos=0;const s=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(s),this._buffer=new t(this._array),this._ctor=t,this._i16View=new Int16Array(this._array)}_roundToNearest(t,e){const s=Math.round(t);return e===1?s:s+(e-s%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest((this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT)*uo,this._buffer.BYTES_PER_ELEMENT),s=new ArrayBuffer(e),r=new this._ctor(s);r.set(this._buffer,0),this._array=s,this._buffer=r,this._i16View=new Int16Array(this._array)}}ensureSize(t){this._ensureSize(t)}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}i1616Add(t,e,s){this._i16View[2*t]+=e,this._i16View[2*t+1]+=s}getValue(t){return this._buffer[t]}getValueF32(t){return new Float32Array(this._array,4*t,1)[0]}incr(t){if(this._buffer.length<t)throw new Error("Increment index overflows the target buffer");this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}writeManyFrom(t,e,s){this._ensureSize(s-e);for(let r=e;r!==s;r++)this.writeFixed(t._buffer[r])}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){return[...this._buffer]}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}};const fo=6,po=4;let mo=class{constructor(t,e,s=0){const r=fo*s*Uint32Array.BYTES_PER_ELEMENT,i=po*s*e.stride,a=e.stride/4,n=e.attributes.find(o=>o.name==="pos"||o.name==="position");if(!n)throw new Error("InternalError: Unable to find position attribute");this.layout={...e,position:n},this._indices=new lt(Uint32Array,r),this._vertices=new lt(Uint32Array,i),this._metrics=new lt(Uint32Array,0),this._metricCountOffset=this._metrics.push(0),this._strideInt=a,this._instanceId=t}serialize(t){const e=this._indices.buffer(),s=this._vertices.buffer(),r=this._metrics.length?this._metrics.buffer():null;return t.push(e,s),{instanceId:this._instanceId,layout:this.layout,indices:e,vertices:s,metrics:r}}get strideInt(){return this._strideInt}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize(t){this._vertices.ensureSize(t)}indexEnsureSize(t){this._indices.ensureSize(t)}writeIndex(t){this._indices.push(t)}writeVertex(t){this._vertices.push(t)}writeVertexRegion(t){this._vertices.writeRegion(t)}writeVertexF32(t){this._vertices.writeF32(t)}writeMetric(t){this._metrics.incr(this._metricCountOffset),t.serialize(this._metrics)}},wr=class{constructor(t,e=0){this._id=t,this._sizeHint=e,this._entityRecordCountOffset=0,this._entityCountOffset=0,this._entityIdIndex=0,this._entitySortKeyIndex=0,this._didEntityStart=!1,this._instanceIdToVertexData=new Map,this._recordIndexStart=0,this._recordIndexCount=0,this._recordVertexStart=0,this._recordVertexCount=0,this._current={metric:null,writer:null,start:0,sortKey:0,instanceId:0,layoutHash:0,indexStart:0,vertexStart:0,textureKey:0,metricBoxLenPointer:0},this._entities=new lt(Uint32Array,this._sizeHint*ho.byteSizeHint),this._entityCountOffset=this._entities.push(0)}get id(){return this._id}serialize(){const t=new Array,e=[],s=this._entities.buffer();for(const r of this._instanceIdToVertexData.values())e.push(r.serialize(t));return{message:{data:e,entities:s},transferList:t}}vertexStart(){return this._current.vertexStart??0}vertexCount(){return this._current.writer?.vertexCount??0}indexCount(){return this._current.writer?.indexCount??0}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteRegion(t){this._current.writer.writeVertexRegion(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}recordBounds(t,e,s,r){}indexWrite(t){this._current.writer.writeIndex(t)}metricStart(t){this._current.metric=t,this._current.metric.recordStart=this.recordCount()}metricEnd(){const t=this._current.writer;this._current.metric&&(this._current.metric.recordCount=this.recordCount()-this._current.metric.recordStart),this._current.metric?.bounds.length&&this._current.metric?.recordCount?(t.writeMetric(this._current.metric),this._current.metric=null):this._current.metric=null}metricBoxWrite(t){this._current.metric.bounds.push(t)}entityStart(t,e=t){this._entityIdIndex=this._entities.push(t),this._entitySortKeyIndex=this._entities.writeF32(e),this._entityRecordCountOffset=this._entities.push(0),this._didEntityStart=!0}entityRecordCount(){return this._entities.getValue(this._entityRecordCountOffset)}entityEnd(){this._didEntityStart&&(this.entityRecordCount()===0?this._entities.seek(this._entityIdIndex):this._entities.incr(this._entityCountOffset),this._didEntityStart=!1)}recordCount(){return this._entities.getValue(this._entityRecordCountOffset)}recordStart(t,e,s=0){this._current.writer=this._getVertexWriter(t,e),this._current.indexStart=this._current.writer.indexCount,this._current.vertexStart=this._current.writer.vertexCount,this._current.instanceId=t,this._current.layoutHash=e.hash,this._current.textureKey=s}recordEnd(t=0){const e=this._current.vertexStart,s=this._current.writer.vertexCount-e;if(!s)return!1;const r=this._current.indexStart,i=this._current.writer.indexCount-r;return this._recordIndexStart=r,this._recordIndexCount=i,this._recordVertexStart=e,this._recordVertexCount=s,this._entities.incr(this._entityRecordCountOffset),Ue.write(this._entities,this._current.instanceId,this._current.textureKey,r,i,e,s,t),!0}copyLast(t,e){const s=this._recordVertexStart+this._recordVertexCount;this._entities.incr(this._entityRecordCountOffset),Ue.write(this._entities,this._current.instanceId,this._current.textureKey,this._recordIndexStart+this._recordIndexCount,this._recordIndexCount,s,this._recordVertexCount,0);const r=this._current.writer.indexWriter,i=this._current.writer.vertexWriter,a=this._recordIndexStart+this._recordIndexCount,n=this._recordVertexCount;for(let m=this._recordIndexStart;m!==a;m++){const _=r.getValue(m);r.push(_+n)}const o=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,c=this._recordVertexStart*o,l=(this._recordVertexStart+this._recordVertexCount)*o;for(let m=c;m!==l;m++){const _=i.getValue(m);i.push(_)}const h=this._current.writer.layout.position,u=h.packPrecisionFactor??1,d=h.offset/Uint32Array.BYTES_PER_ELEMENT,f=t*u,p=e*u;for(let m=s*o;m<=i.length;m+=o)i.i1616Add(m+d,f,p)}copyLastFrom(t,e,s){const r=t._entities.getValue(t._entityIdIndex);if(r!==this._entities.getValue(this._entityIdIndex)){const _=t._entities.getValueF32(t._entitySortKeyIndex);this.entityStart(r,_)}this.recordStart(t._current.instanceId,t._current.writer.layout,t._current.textureKey);const i=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,a=this._current.vertexStart,n=t._current.vertexStart-a,o=this._current.writer.indexWriter,c=this._current.writer.vertexWriter,l=t._current.writer.indexWriter,h=t._current.writer.vertexWriter;for(let _=t._current.indexStart;_!==l.length;_++){const g=l.getValue(_);o.push(g-n)}for(let _=t._current.vertexStart*i;_!==h.length;_++){const g=h.getValue(_);c.push(g)}const u=this._current.writer.layout.position,d=u.packPrecisionFactor??1,f=u.offset/Uint32Array.BYTES_PER_ELEMENT,p=e*d,m=s*d;for(let _=a*i;_<=c.length;_+=i)c.i1616Add(_+f,p,m);this.recordEnd()}_getVertexWriter(t,e){const s=this._instanceIdToVertexData;return s.has(t)||s.set(t,new mo(t,e,this._sizeHint)),s.get(t)}};const Ft=1,Cs=2,Pt=4,As=8,Es=16,Ct=32,Os=64,At=128;function qt(t){switch(t){case Ft:case As:case Ct:return-1;case Cs:case Os:return 0;case Pt:case Es:case At:return 1}}function Nt(t){switch(t){case Ft:case Cs:case Pt:return-1;case As:case Es:return 0;case Ct:case Os:case At:return 1}}const Ir=Ft|As|Ct,Sr=Pt|Es|At,vr=Ft|Cs|Pt,kr=Ct|Os|At;let _o=class{constructor(t,e,s,r,i=0){this.tileKey=t,this._bufferingEnabled=e,this._sizeHint=i,this._meshes={self:new wr(this.id,this._sizeHint),neighbors:new Array},this._currentRecordOverlaps=0,this._currentEntityOverlaps=0;const a=r?1:0;this._copyBufferedDataIntoSelf=s&&this._bufferingEnabled&&t.level===a}get id(){return this.tileKey.id}vertexStart(){return this._meshes.self.vertexStart()??0}vertexCount(){return this._meshes.self.vertexCount()}indexCount(){return this._meshes.self.indexCount()}indexEnsureSize(t){this._meshes.self.indexEnsureSize(t)}entityStart(t,e=t){this._currentEntityOverlaps=0,this._meshes.self.entityStart(t,e)}entityRecordCount(){return this._meshes.self.entityRecordCount()}entityEnd(){if(this._meshes.self.entityEnd(),this._bufferingEnabled){if(this._copyBufferedDataIntoSelf)return;for(let t=0;t<8;t++){const e=1<<t;this._currentEntityOverlaps&e&&this._meshes.neighbors[t].entityEnd()}}}recordStart(t,e,s){this._currentRecordOverlaps=0,this._meshes.self.recordStart(t,e,s)}recordEnd(t=0){const e=this._meshes.self.recordEnd(this._currentRecordOverlaps);return e&&this._currentRecordOverlaps!==0?(this._copyIntoNeighbors(),this._currentEntityOverlaps|=this._currentRecordOverlaps,!0):e}recordBounds(t,e,s,r){this._bufferingEnabled&&this._addOverlap(t,e,s,r)}recordCount(){return this._meshes.self.recordCount()}metricStart(t){this._meshes.self.metricStart(t)}metricBoxWrite(t){this._meshes.self.metricBoxWrite(t)}metricEnd(){this._meshes.self.metricEnd()}vertexWrite(t){this._meshes.self.vertexWrite(t)}vertexWriteF32(t){this._meshes.self.vertexWriteF32(t)}vertexWriteRegion(t){this._meshes.self.vertexWriteRegion(t)}indexWrite(t){this._meshes.self.indexWrite(t)}serialize(t){const e={message:[],transferList:[]},s=this._meshes.self.serialize();return e.message.push({tileId:this.tileKey.id,...s.message}),e.transferList.push(...s.transferList),this._meshes.neighbors.forEach((r,i)=>{const a=r.serialize(),n=1<<i,o=qt(n),c=Nt(n),l=new kt(this.tileKey).getNormalizedNeighbor(o,c,t);e.message.push({tileId:l.id,...a.message}),e.transferList.push(...a.transferList)}),e}_addOverlap(t,e,s,r){const i=Math.min(T/2,s),a=Math.min(T/2,r),n=255^((t<0+i?Sr:t>=T-i?Ir:Sr|Ir)|(e<0+a?kr:e>=T-a?vr:kr|vr));this._currentRecordOverlaps|=n}_copyIntoNeighbors(){for(let t=0;t<8;t++){const e=1<<t;if(this._currentRecordOverlaps&e){if(this._copyBufferedDataIntoSelf){const a=-qt(e)*T,n=-Nt(e)*T;if(n!==0)continue;this._meshes.self.copyLast(a,n);continue}if(!this._meshes.neighbors[t]){const a=Math.floor(this._sizeHint/16);this._meshes.neighbors[t]=new wr(e,a)}const s=this._meshes.neighbors[t],r=-qt(e)*T,i=-Nt(e)*T;s.copyLastFrom(this._meshes.self,r,i)}}}},yo=class{},oe=class ki{constructor(){this._defaultResult=null,this._backgroundFillResult=null}static async from(e,s){const r=new ki;return r.setDefault(await e.createMeshWriters(s.meshes)),r}size(){return 1}getDefault(){return this._defaultResult}setDefault(e){this._defaultResult=e}getBackgroundFill(){return this._backgroundFillResult}setBackgroundFill(e){this._backgroundFillResult=e}hasArcadeDependency(e){return this._defaultResult?.some(s=>s.hasArcadeDependency(e))??!1}match(e,s,r){const i=this.doMatch(e,s)||this.getDefault();if(i&&i.length>0){const a=this.getBackgroundFill();if(a)return[...a,...i]}return i}getSortKey(e,s){return 0}doMatch(e,s){return null}async fetchResources(e,s){}},go=class Mi extends oe{static async fromDictionaryRenderer(e,s){const r=await en.from(s.dictionaryInfo,s.userConfig,s.fieldMap);return new Mi(e,r)}constructor(e,s){super(),this._context=e,this._evaluator=s,this._controlStringToPromise=new Map,this._controlStringToGroup=new Map}async fetchResources(e,s){const r=s.getCursor(),i=new Set;for(;r.next();){const n=this._evaluateControlString(r);n&&i.add(n)}const a=Array.from(i.values()).map(n=>this._ensureGroup(e,n));await Promise.all(a)}match(e,s){const r=this._evaluateControlString(e);return r?this._controlStringToGroup.get(r):null}_evaluateControlString(e){const s=e.readLegacyFeatureWorldSpace();return this._evaluator.evaluate(s,0,e.fields,null)}_ensureGroup(e,s){let r=this._controlStringToPromise.get(s);return r==null&&(r=this._fetchGroup(e,s),this._controlStringToPromise.set(s,r)),r}async _fetchGroup(e,s){const r=await e.fetchDictionaryResourceImmediate({type:"dictionary-request",controlString:s});if(!r)return;const i=await this._context.createMeshWriters(r.meshes);this._controlStringToGroup.set(s,i)}},xo=class Ti extends oe{constructor(e,s){super(),this._intervals=[],this._isMaxInclusive=s,this._field=e}static async fromIntervalSchema(e,s){const r=await e.storage.createComputedField(s),i=new Ti(r,s.isMaxInclusive);await Promise.all(s.intervals.map(async o=>{const c=await e.createMeshWriters(o.meshes);i.add(o,c)}));const a=await e.createMeshWriters(s.defaultSymbol);i.setDefault(a);const n=await e.createMeshWriters(s.backgroundFill);return i.setBackgroundFill(n),i}add(e,s){this._intervals.push({interval:e,result:s}),this._intervals.sort((r,i)=>r.interval.min-i.interval.min)}size(){return super.size()+this._intervals.length}hasArcadeDependency(e){return this._field?.hasArcadeDependency(e)||this._intervals.some(s=>s.result.some(r=>r.hasArcadeDependency(e)))}doMatch(e,s){const r=this._field?.read(e,s);if(r==null||isNaN(r)||r===1/0||r===-1/0)return null;for(let i=0;i<this._intervals.length;i++){const{interval:a,result:n}=this._intervals[i],o=r>=a.min,c=this._isMaxInclusive?r<=a.max:r<a.max;if(o&&c)return n}return null}},bo=class Fi extends oe{static async fromLabelSchema(e,s){const r=s.classes.map(async a=>{const n=await e.createMeshWriters(a.meshes);return{minScale:a.minScale,maxScale:a.maxScale,meshes:n,expression:null,where:await e.storage.createWhereClause(a.where)}}),i=await Promise.all(r);return new Fi(i)}constructor(e){super(),this._labels=e}match(e,s,r){if(!this._labels.length)return null;const i=this._getLabels(s.$view.scale),a=[];for(const n of i)n.where&&!n.where(e,r)||a.push(...n.meshes);return a}hasArcadeDependency(e){return this._labels.some(s=>s.meshes.some(r=>r.hasArcadeDependency(e)))}_getLabels(e){return this._labels.filter(s=>this._validForTileScale(s,e))}_validForTileScale(e,s){const r=s-s/4,i=s+s/2;return(!e.minScale||e.minScale>=r)&&(!e.maxScale||e.maxScale<=i)}},wo=class Pi extends oe{constructor(e,s){super(),this._defaultSymbolSortKey=0,this._nullResult=null,this._resultsMap=new Map,this._fields=[],this._fields=e,this._separator=s||""}static async fromMatcherSchema(e,s){const r=s.expression?[e.storage.createComputedField({expression:s.expression})]:[s.field?e.storage.createComputedField({field:s.field}):null,s.field2?e.storage.createComputedField({field:s.field2}):null,s.field3?e.storage.createComputedField({field:s.field3}):null],i=(await Promise.all(r)).filter(c=>!!c),a=new Pi(i,s.fieldDelimiter),n=await e.createMeshWriters(s.defaultSymbol);a.setDefault(n);const o=await e.createMeshWriters(s.backgroundFill);return a.setBackgroundFill(o),await Promise.all(s.map.map(async(c,l)=>{const h=await e.createMeshWriters(c.symbol);c.value==="<Null>"?a.setNullResult(h):a.add(c.value,h,l+1)})),a}setNullResult(e){this._nullResult=e}getSortKey(e,s){const r=this._getValueFromFields(e,s);if(r==null||r===""||r==="<Null>")return 0;const i=this._resultsMap.get(r.toString());return i?i.sortKey:this._defaultSymbolSortKey}add(e,s,r){this._resultsMap.set(e.toString(),{meshWriters:s,sortKey:r}),this._defaultSymbolSortKey=Math.max(this._defaultSymbolSortKey,r+1)}size(){return super.size()+this._resultsMap.size}hasArcadeDependency(e){return this._fields.some(s=>s.hasArcadeDependency(e))||[...this._resultsMap.values()].some(s=>s.meshWriters.some(r=>r.hasArcadeDependency(e)))||this._nullResult?.some(s=>s.hasArcadeDependency(e))||!1}doMatch(e,s){const r=this._getValueFromFields(e,s);if(this._nullResult!==null&&(r==null||r===""||r==="<Null>"))return this._nullResult;if(r==null)return null;const i=r.toString();return this._resultsMap.get(i)?.meshWriters}_getValueFromFields(e,s){const r=[];for(const i of this._fields){const a=i.read(e,s);a==null||a===""?r.push("<Null>"):r.push(a)}return r.join(this._separator)}};async function ie(t,e){switch(e.type){case"simple":case"heatmap":case"dot-density":case"pie-chart":return oe.from(t,e);case"interval":return xo.fromIntervalSchema(t,e);case"dictionary":return go.fromDictionaryRenderer(t,e);case"label":return bo.fromLabelSchema(t,e);case"map":return wo.fromMatcherSchema(t,e);case"subtype":return Io.fromSubtypes(t,e);case"cluster":return So.fromClusterSchema(t,e);case"track":return vo.fromTrackSchema(t,e);default:throw new Error("Impl")}}let Io=class Ci extends oe{constructor(e,s){super(),this._subMatchers=e,this._subtypeField=s}static async fromSubtypes(e,s){const r=new Map,i=[];for(const a in s.renderers){const n=parseInt(a,10),o=ie(e,s.renderers[a]).then(c=>r.set(n,c));i.push(o)}return await Promise.all(i),new Ci(r,s.subtypeField)}match(e,s,r){const i=e.readAttribute(this._subtypeField),a=this._subMatchers.get(i);return a?a.match(e,s,r):null}hasArcadeDependency(e){for(const s of this._subMatchers.values())if(s.hasArcadeDependency(e))return!0;return!1}},So=class Ai extends oe{static async fromClusterSchema(e,s){const[r,i]=await Promise.all([ie(e,s.feature),ie(e,s.cluster)]);return new Ai(r,i)}constructor(e,s){super(),this._featureMatcher=e,this._clusterMatcher=s}match(e,s,r){return e.readAttribute("cluster_count")===1?this._featureMatcher.match(e,s,r):this._clusterMatcher.match(e,s,r)}hasArcadeDependency(e){return this._featureMatcher.hasArcadeDependency(e)||this._clusterMatcher.hasArcadeDependency(e)}},vo=class Ei extends oe{static async fromTrackSchema(e,s){const[r,i,a]=await Promise.all([ie(e,s.previousObservation),ie(e,s.latestObservation),ie(e,s.trackLine)]);return new Ei(r,i,a)}constructor(e,s,r){super(),this._previousObservationMatcher=e,this._latestObservationMatcher=s,this._trackLineMatcher=r}match(e,s,r){switch(e.readAttribute(ke)){case 0:return this._trackLineMatcher.match(e,s,r);case 1:return this._latestObservationMatcher.match(e,s,r);case 2:return this._previousObservationMatcher.match(e,s,r)}return null}hasArcadeDependency(e){return this._trackLineMatcher.hasArcadeDependency(e)||this._latestObservationMatcher.hasArcadeDependency(e)||this._previousObservationMatcher.hasArcadeDependency(e)}},ko=class Oi extends yo{static async create(e,s){const r=await ie(e,s.symbology),i=s.labels?await ie(e,s.labels):null;return new Oi(r,i)}constructor(e,s){super(),this._symbology=e,this._labels=s}destroy(){}async enqueueMatcherRequests(e,s){await Promise.all([this._symbology.fetchResources(e,s),this._labels?.fetchResources(e,s)])}enqueueWriterRequests(e,s,r,i){const a=this._symbology.match(s,r,i);if(a){for(const n of a)n.enqueueRequest(e,s,r);if(this._labels){const n=this._labels.match(s,r,i);if(!n)return;for(const o of n)o.enqueueRequest(e,s,r)}}}write(e,s,r,i,a,n){const o=this._symbology.match(r,i,a);if(o){for(const c of o)c.write(e,s,r,i,n);if(e.entityRecordCount()>=1&&this._labels){const c=this._labels.match(r,i,a);if(!c)return;for(const l of c)l.setReferences(o),l.write(e,s,r,i,n)}}}getSortKey(e,s){return this._symbology.getSortKey(e,s)}hasArcadeDependency(e){return!(!this._symbology.hasArcadeDependency(e)&&!this._labels?.hasArcadeDependency(e))}};function Mo(t){return"url"in t&&"urlHash"in t?{...t,url:""}:t}let To=class{},Fo=class extends To{constructor(t){super(),this._fetcher=t,this._controller=new AbortController,this._pendingIds=new Set,this._pendingRequests=[],this._resourceIdToResource=new Map}destroy(){this._controller.abort()}get _abortOptions(){return{signal:this._controller.signal}}enqueueRequest(t){const e=Mo(t.resource),s=ne(JSON.stringify(e));return this._pendingIds.has(s)||(this._pendingIds.add(s),this._pendingRequests.push({...t,resourceId:s})),s}async fetchEnqueuedResources(){const t=this._pendingRequests;if(this._pendingIds.clear(),this._pendingRequests=[],t.length===0)return;const e=await this._fetcher.fetch(t,this._abortOptions);for(let s=0;s<e.length;s++){const r=t[s].resourceId;this._resourceIdToResource.set(r,e[s])}}async fetchResourceImmediate(t){const e=await this._fetcher.fetch([t]);if(e.length!==1)throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");return e[0]}async fetchDictionaryResourceImmediate(t){const e=await this._fetcher.fetchDictionary([t]);if(e.length!==1)throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");return e[0]}getResource(t){return this._resourceIdToResource.get(t)}},Rs=class{static getPlacement(t,e,s,r,i){const a=rn(s);return a?(e===-1&&t.invertY(),a.execute(t,s,r,i)):null}};const Po=()=>G.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),Co=0,Ao=100;function fe(t,e){return[!!t?.minScale&&e.scaleToZoom(t.minScale)||Co,!!t?.maxScale&&e.scaleToZoom(t.maxScale)||Ao]}function $(t){return 1<<t}function Ee(t){let e=0;for(const[s,r]of t)r&&(e|=1<<s);return e}function C(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const n=oi.fromString(t);if(!n)return Po().errorOnce(new P("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=n.toArray()}else e=t;const[s,r,i,a]=e;return[s*(a/255),r*(a/255),i*(a/255),a]}function Ri(t){switch(t){case"butt":case"Butt":return 0;case"round":case"Round":return 1;case"square":case"Square":return 2}}function zi(t){switch(t){case"bevel":case"Bevel":return 0;case"miter":case"Miter":return 2;case"round":case"Round":return 1}}function Gt(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function Je(t,e){return Math.round(t*e)/e}const X={bitset:{isSDF:0,isMapAligned:1,scaleSymbolsProportionally:2,overrideOutlineColor:3,colorLocked:4,isStroke:5}},Eo=()=>G.getLogger("esri.views.2d.engine.webgl.alignmentUtils");function Oo(t){if(!t)return 0;switch(t){case"Left":case"left":return-1;case"Right":case"right":return 1;case"Justify":return Eo().warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),0;case"Center":case"center":return 0}}function Ro(t){if(!t)return 0;switch(t){case"Top":case"top":return 1;case"Center":case"middle":return 0;case"Baseline":case"baseline":return 2;case"Bottom":case"bottom":return-1}}function zo(t){switch(t){case 1:case"right":return-1;case 0:case"center":return 0;case-1:case"left":return 1;default:return console.debug(`Found invalid horizontal alignment ${t}`),0}}function Do(t){switch(t){case 1:case"top":return 1;case 0:case"middle":return 0;case-1:case 2:case"baseline":case"bottom":return-1;default:return console.debug(`Found invalid vertical alignment ${t}`),0}}let re=class os{constructor(e,s,r,i){this.transformedX=0,this.transformedY=0,this.center=Be(e,s),this.centerT=ss(),this.halfWidth=r/2,this.halfHeight=i/2,this.width=r,this.height=i}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(e){this.center[0]=e}set y(e){this.center[1]=e}clone(){return new os(this.x,this.y,this.width,this.height)}serialize(e){return e.writeF32(this.center[0]),e.writeF32(this.center[1]),e.push(this.width),e.push(this.height),e}findCollisionDelta(e,s=4){const r=Math.abs(e.centerT[0]-this.centerT[0]),i=Math.abs(e.centerT[1]-this.centerT[1]),a=(e.halfWidth+this.halfWidth+s)/r,n=(e.halfHeight+this.halfHeight+s)/i,o=Math.min(a,n);return Math.log2(o)}extend(e){const s=Math.min(this.xmin,e.xmin),r=Math.min(this.ymin,e.ymin),i=Math.max(this.xmax,e.xmax)-s,a=Math.max(this.ymax,e.ymax)-r,n=s+i/2,o=r+a/2;this.width=i,this.height=a,this.halfWidth=i/2,this.halfHeight=a/2,this.x=n,this.y=o}static deserialize(e){const s=e.readF32(),r=e.readF32(),i=e.readInt32(),a=e.readInt32();return new os(s,r,i,a)}};const zs=22,Di=4,Lo=zs+Di,Bo=zs-6,Mr=3,qo=Math.PI/180,J=8,No=1.5;let Li=class{constructor(t,e,s,r){this._rotationT=j(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const i=s.rect,a=new Float32Array(8);t*=r,e*=r;const n=s.code?i.width*r:s.metrics.width,o=s.code?i.height*r:s.metrics.height;this.width=n,this.height=o,a[0]=t,a[1]=e,a[2]=t+n,a[3]=e,a[4]=t,a[5]=e+o,a[6]=t+n,a[7]=e+o,this._data=a,this._setTextureCoords(i),this._scale=r,this._mosaic=s,this.x=t,this.y=e,this.maxOffset=Math.max(t+n,e+o)}get mosaic(){return this._mosaic}set angle(t){this._angle=t,Ge(this._rotationT,-t),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:e}=this._mosaic.metrics,s=e*this._scale,r=Math.abs(t)*this._scale,i=new Float32Array(8);i[0]=this.x,i[1]=this.y,i[2]=this.x+s,i[3]=this.y,i[4]=this.x,i[5]=this.y+r,i[6]=this.x+s,i[7]=this.y+r;const a=es(j(),this._rotationT,this._transform);fn(i,i,a);let n=1/0,o=1/0,c=-1/0,l=-1/0;for(let p=0;p<4;p++){const m=i[2*p],_=i[2*p+1];n=Math.min(n,m),o=Math.min(o,_),c=Math.max(c,m),l=Math.max(l,_)}const h=c-n,u=l-o,d=n+h/2,f=o+u/2;this._bounds=new re(d,f,h,u)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const t=es(j(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],W(this._offsets.topLeft,this._offsets.topLeft,t),W(this._offsets.topRight,this._offsets.topRight,t),W(this._offsets.bottomLeft,this._offsets.bottomLeft,t),W(this._offsets.bottomRight,this._offsets.bottomRight,t)}_setTextureCoords({x:t,y:e,width:s,height:r}){this._texcoords={topLeft:[t,e],topRight:[t+s,e],bottomLeft:[t,e+r],bottomRight:[t+s,e+r]}}};const Go=(t,e)=>({code:0,page:0,sdf:!0,rect:new xn(0,0,11,8),textureBinding:e,metrics:{advance:0,height:4,width:t,left:0,top:0}});function ze(t,e){return t.forEach(s=>W(s,s,e)),{topLeft:t[0],topRight:t[1],bottomLeft:t[2],bottomRight:t[3]}}let Uo=class{constructor(t,e,s){this._rotation=0,this._decorate(t,e,s),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=e.length>1,this._hasRotation=s.angle!==0,this._transform=this._createGlyphTransform(this.bounds,s),this._borderLineSizePx=s.borderLineSizePx,(s.borderLineSizePx||s.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const r of t)r.setTransform(this._transform)}setRotation(t){if(t===0&&this._rotation===0)return;this._rotation=t;const e=this._transform,s=Ge(j(),t);es(e,s,e);for(const r of this.glyphs)r.setTransform(this._transform)}_decorate(t,e,s){if(!s.decoration||s.decoration==="none"||!t.length)return;const r=s.scale,i=s.decoration==="underline"?Lo:Bo,a=t[0].textureBinding;for(const n of e){const o=n.startX*r,c=n.startY*r,l=(n.width+n.glyphWidthEnd)*r;t.push(new Li(o,c+i*r,Go(l,a),1))}}shapeBackground(t){const e=this._borderLineSizePx||0,s=(No+e)/2,r=this._borderLineSizePx?s:0,{xmin:i,ymin:a,xmax:n,ymax:o,x:c,y:l,width:h,height:u}=this.bounds,d=[i-J,a-J],f=[n+J,a-J],p=[i-J,o+J],m=[n+J,o+J],_=ze([[d[0]-s,d[1]-s],[f[0]+s,f[1]-s],[d[0]+r,d[1]+r],[f[0]-r,f[1]+r]],t),g=ze([[p[0]+r,p[1]-r],[m[0]-r,m[1]-r],[p[0]-s,p[1]+s],[m[0]+s,m[1]+s]],t),b=ze([[d[0]-s,d[1]-s],[d[0]+r,d[1]+r],[p[0]-s,p[1]+s],[p[0]+r,p[1]-r]],t),S=ze([[f[0]-r,f[1]+r],[f[0]+s,f[1]-s],[m[0]-r,m[1]-r],[m[0]+s,m[1]+s]],t),x={main:ze([d,f,p,m],t),top:_,bot:g,left:b,right:S};return[new re(c,l,h+2*s,u+2*s),x]}get boundsT(){const t=this.bounds,e=q(ss(),t.x,t.y);if(W(e,e,this._transform),this._hasRotation){const s=Math.max(t.width,t.height);return new re(e[0],e[1],s,s)}return new re(e[0],e[1],t.width,t.height)}_createBounds(t){let e=1/0,s=1/0,r=0,i=0;for(const o of t)e=Math.min(e,o.xTopLeft),s=Math.min(s,o.yTopLeft),r=Math.max(r,o.xBottomRight),i=Math.max(i,o.yBottomRight);const a=r-e,n=i-s;return new re(e+a/2,s+n/2,a,n)}_createGlyphTransform(t,e){const s=qo*e.angle,r=j(),i=ss();return Me(r,r,q(i,e.xOffset,-e.yOffset)),e.useCIMAngleBehavior?ts(r,r,s):(Me(r,r,q(i,t.x,t.y)),ts(r,r,s),Me(r,r,q(i,-t.x,-t.y))),r}},et=class{constructor(t,e,s,r,i,a){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(e,s)),this.end=Math.max(0,Math.max(e,s)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=r,this.yMin=i,this.yMax=a}};const cs=t=>t===10,Tr=t=>t===32;function $o(t,e,s){const r=new Array,i=1/s.scale,a=s.maxLineWidth*i,n=e?t.length-1:0,o=e?-1:t.length,c=e?-1:1;let l=n,h=0,u=0,d=l,f=d,p=0,m=1/0,_=0;for(;l!==o;){const{code:b,metrics:S}=t[l],x=Math.abs(S.top);if(cs(b)||Tr(b)||(m=Math.min(m,x),_=Math.max(_,x+S.height)),cs(b))l!==n&&(r.push(new et(t,d,l-c,h,m===1/0?0:m,_)),m=1/0,_=0),h=0,d=l+c,f=l+c,u=0;else if(Tr(b))f=l+c,u=0,p=S.advance,h+=S.advance;else if(h>a){if(f!==d){const I=f-2*c;h-=p,r.push(new et(t,d,I,h-u,m,_)),m=1/0,_=0,d=f,h=u}else r.push(new et(t,d,l-c,h,m,_)),m=1/0,_=0,d=l,f=l,h=0;h+=S.advance,u+=S.advance}else h+=S.advance,u+=S.advance;l+=c}const g=new et(t,d,l-c,h,m,_);return g.start>=0&&g.end<t.length&&r.push(g),r}function Wo(t,e){let s=0;for(let a=0;a<t.length;a++){const{width:n}=t[a];s=Math.max(n,s)}const r=e.decoration==="underline"?Di:0,i=t[0].yMin;return{x:0,y:i,height:t[t.length-1].yMax+e.lineHeight*(t.length-1)+r-i,width:s}}function Vo(t,e){const s=e.scale,r=new Array,{glyphs:i,isRightToLeft:a}=t,n=$o(i,a,e),o=n.length?Wo(n,e):{y:0,height:0},c=Oo(e.horizontalAlignment),l=Ro(e.verticalAlignment),h=l===2?1:0,u=h?0:l-1,d=(1-h)*-o.y+u*(o.height/2)+(h?1:0)*-zs;for(let f=0;f<n.length;f++){const{start:p,end:m,width:_}=n[f];let g=-1*(c+1)*(_/2)-Mr;const b=(t.isRightToLeft?n.length-1-f:f)*e.lineHeight+d-Mr;n[f].startX=g,n[f].startY=b;for(let S=p;S<=m;S++){const x=i[S];if(cs(x.code))continue;const I=new Li(g+x.metrics.left,b-x.metrics.top,x,s);g+=x.metrics.advance,r.push(I)}}return new Uo(r,n,e)}const jo=96/72;let Yo=class{static executeEffects(t,e,s,r){const i=jo,a=ar(t);let n=new or(e);for(const o of t){const c=nr(o);c&&(n=c.execute(n,o,i,s,a,r))}return n}static applyEffects(t,e){if(!t)return e;const s=ar(t);let r,i=new or(B.fromJSONCIM(e));for(const o of t){const c=nr(o);c&&(i=c.execute(i,o,1,null,s,!1))}const a=[];let n=null;for(;r=i.next();)a.push(...cn(r)),n=r.geometryType;return a.length===0||n===null?null:n==="esriGeometryPolygon"?{rings:a}:{paths:a}}};const Bi=new Float32Array(1),Ho=new Uint32Array(Bi.buffer);function Xo(t){return Bi[0]=t,Ho[0]}function Qo(t,e){return 65535&t|e<<16}function Fr(t){const e=Xo(t),s=e>>>31;let r=e>>>23&255,i=8388607&e;return r-=127,r>15?s<<15|31744:r<-25?0:(r<-14&&(i+=8388608,i/=2**(-14-r),r=-15),r+=15,i/=8192,i=Zo(i,1023),s<<15|r<<10|i)}function Zo(t,e){const s=Math.floor(t),r=t-s;return s<e&&(r>.5||r===.5&&s%2==1)?s+1:s}function Ko(t){const e=t.map(({name:s,count:r,type:i})=>`${s}.${r}.${i}`).join(",");return ne(e)}function ee(t,e,s,r,i,a,n){if(t.primitiveName===e){let o=r?.readWithDefault(i,a,t[s]&&n);return t.type==="text"&&(o=o.toString()),void(t[s]=o)}if("type"in t&&t.type!=null){if(t.effects)for(const o of t.effects)ee(o,e,s,r,i,a,n);switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(t.symbolLayers)for(const o of t.symbolLayers)ee(o,e,s,r,i,a,n);break;case"CIMTextSymbol":t.symbol&&ee(t.symbol,e,s,r,i,a,n);break;case"CIMHatchFill":t.lineSymbol&&ee(t.lineSymbol,e,s,r,i,a,n);break;case"CIMPictureMarker":case"CIMCharacterMarker":case"CIMVectorMarker":if(t.markerPlacement&&ee(t.markerPlacement,e,s,r,i,a,n),t.type==="CIMVectorMarker"&&t.markerGraphics)for(const o of t.markerGraphics)ee(o,e,s,r,i,a,n),ee(o.symbol,e,s,r,i,a,n)}}}const Jo=400;function qi(t){const e=Math.max(1.25*t.width,20);return t.effects!=null&&t.effects.length>0?Jo:e}function Ni(t){switch(t){case y.BYTE:case y.UNSIGNED_BYTE:return 1;case y.SHORT:case y.UNSIGNED_SHORT:case y.HALF_FLOAT:return 2;case y.FLOAT:case y.INT:case y.UNSIGNED_INT:return 4}}function ec(t){const e=[],s=[],r=[];for(const i of t){const a=Ni(i.type)*i.count;switch(a%2||a%4||4){case 4:e.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...s),e.push(...r),e}let tc=class Gi{static fromVertexSpec(e,s){const{attributes:r,optionalAttributes:i}=e;let a,n,o;const c=[];for(const m in r){if(r[m].otherSource)continue;const _=r[m];_.pack==="position"?a={..._,name:m,offset:0}:_.pack==="id"?n={..._,name:m,offset:4}:m==="bitset"?o={..._,name:m,offset:7}:c.push({..._,name:m})}for(const m in i)if(s[m]===!0){const _=i[m];c.push({..._,name:m})}const l=ec(c),h=[];let u=8,d=1;for(const m of l)h.push({...m,offset:u}),u+=Ni(m.type)*m.count,m.packAlternating&&(d=Math.max(m.packAlternating.count,d));const f=Uint32Array.BYTES_PER_ELEMENT,p=u%f;return new Gi(a,n,o,h,u+(p?f-p:0),d)}constructor(e,s,r,i,a,n){this.position=e,this.id=s,this.bitset=r,this.standardAttributes=i,this.stride=a,this.packVertexCount=n,i.push(r),this._attributes=[e,s,r,...i]}get attributeLayout(){if(!this._attributeLayout){const e=Ko(this._attributes),s=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:s,hash:e,stride:this.stride}}return this._attributeLayout}};function sc(t,e,s,r){const i=s.packPrecisionFactor??1;switch(s.type){case y.BYTE:if(s.count===1)t.setInt8(r+s.offset,e*i);else for(let a=0;a<s.count;a++){const n=a*Int8Array.BYTES_PER_ELEMENT;t.setInt8(r+s.offset+n,e[a]*i)}break;case y.UNSIGNED_BYTE:if(s.count===1)t.setUint8(r+s.offset,e*i);else for(let a=0;a<s.count;a++){const n=a*Uint8Array.BYTES_PER_ELEMENT;t.setUint8(r+s.offset+n,e[a]*i)}break;case y.SHORT:if(s.count===1)t.setInt16(r+s.offset,e*i,!0);else for(let a=0;a<s.count;a++){const n=a*Int16Array.BYTES_PER_ELEMENT;t.setInt16(r+s.offset+n,e[a]*i,!0)}break;case y.UNSIGNED_SHORT:if(s.count===1)t.setUint16(r+s.offset,e*i,!0);else for(let a=0;a<s.count;a++){const n=a*Uint16Array.BYTES_PER_ELEMENT;t.setUint16(r+s.offset+n,e[a]*i,!0)}break;case y.INT:if(s.count===1)t.setInt32(r+s.offset,e*i,!0);else for(let a=0;a<s.count;a++){const n=a*Int32Array.BYTES_PER_ELEMENT;t.setInt32(r+s.offset+n,e[a]*i,!0)}break;case y.UNSIGNED_INT:if(s.count===1)t.setUint32(r+s.offset,e*i,!0);else for(let a=0;a<s.count;a++){const n=a*Uint32Array.BYTES_PER_ELEMENT;t.setUint32(r+s.offset+n,e[a]*i,!0)}break;case y.FLOAT:if(s.count===1)t.setFloat32(r+s.offset,e*i,!0);else for(let a=0;a<s.count;a++){const n=a*Float32Array.BYTES_PER_ELEMENT;t.setFloat32(r+s.offset+n,e[a]*i,!0)}break;case y.HALF_FLOAT:if(s.count===1)t.setUint16(r+s.offset,Fr(e*i),!0);else for(let a=0;a<s.count;a++){const n=a*Uint16Array.BYTES_PER_ELEMENT;t.setUint16(r+s.offset+n,Fr(e[a]*i),!0)}}}let rc=class Ui{static fromVertexSpec(e,s){const r=tc.fromVertexSpec(e,s);return new Ui(r)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,s,r,i,a,n){for(let o=0;o<this._spec.packVertexCount;o++){const c=o*this._spec.stride;this._packPosition(r,i,c),this._packId(s,c);const l=this._spec.bitset;if(n){if(l.packTessellation){const h=l.packTessellation(n,a,r,i);this._pack(h,l,c)}for(const h of this._spec.standardAttributes)if(h.packTessellation!=null){const u=h.packTessellation(n,a,r,i);this._pack(u,h,c)}else if(h.packAlternating?.packTessellation){const u=h.packAlternating.packTessellation(n,a,r,i);for(let d=0;d<this._spec.packVertexCount;d++){const f=u[d];this._pack(f,h,d*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,s){for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const i=r.pack(e,s);for(let a=0;a<this._spec.packVertexCount;a++)this._pack(i,r,a*this._spec.stride)}else if(r.packAlternating?.pack){const i=r.packAlternating.pack(e,s);for(let a=0;a<this._spec.packVertexCount;a++){const n=i[a];this._pack(n,r,a*this._spec.stride)}}}_packPosition(e,s,r){const{offset:i}=this._spec.position,a=this._spec.position.packPrecisionFactor??1,n=Qo(e*a,s*a);this._dataView.setUint32(r+i,n,!0)}_packId(e,s){const r=e*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,r|i,!0)}_pack(e,s,r){sc(this._dataView,e,s,r)}},pe=class{constructor(t,e,s,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=i=>this.vertexSpec.createComputedParams(i)}get _vertexPack(){if(!this._cachedVertexPack){const t=rc.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){return this._evaluator.inputMeshParams.effects?.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){for(const{effect:t}of this.effectInfos||[])await sn(t)}enqueueRequest(t,e,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,s)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const a=this.evaluatedMeshParams.effects;if(!a||a.length===0)return void this._write(t,s,void 0,i);const n=this.getEffectCursor(t,s,a);if(!n)return;let o;for(;o=n.next();)o.invertY(),this._write(t,s,o,i)}ensurePacked(t,e,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,s);this._vertexPack.pack(r,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,s,r,i){const a=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,s,r,a,i)}getEffectCursor(t,e,s){const r=e.readGeometryForDisplay()?.clone();if(!r)return;const i=B.fromOptimizedCIM(r,e.geometryType);i.invertY();const a=t.id||"";return Yo.executeEffects(s,i,a,this._preventEffectClipping)}},$i=class extends pe{};function ic(t){const{sprite:e,isMapAligned:s,colorLocked:r,scaleSymbolsProportionally:i,isStroke:a}=t;let n=0;return s&&(n|=$(X.bitset.isMapAligned)),r&&(n|=$(X.bitset.colorLocked)),e.sdf&&(n|=$(X.bitset.isSDF)),i&&(n|=$(X.bitset.scaleSymbolsProportionally)),a&&(n|=$(X.bitset.isStroke)),n}function Wi(t,e){let s;if(typeof t=="string")s=ne(t+`-seed(${e})`);else{let r=12;s=t^e;do s=107*(s>>8^s)+r|0;while(--r!==0)}return(1+s/(1<<31))/2}function Vi(t){return Math.floor(Wi(t,ac)*nc)}const ac=53290320,nc=10;let me=class{generateSource(t){const e=[];for(let r=1;r<this.length;r++)e.push(`vec4 atom${r} = texture(${t.animationTexture}, (pointer + 0.5) / size);`),e.push("pointer.x += 1.0;");for(let r=0;r<this.ins;r++)e.push("top--;"),e.push(`vec4 in${this.ins-r-1} = stack[top];`);for(let r=0;r<this.outs;r++)e.push(`vec4 out${r};`);const{microcode:s}=this;for(const r of s)e.push(r);for(let r=0;r<this.outs;r++)e.push(`stack[top] = out${r};`),e.push("top++;"),e.push(`if (top >= ${Pr}) { top = ${Pr-1}; }`);return e}},_e=128,oc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=1,this.ins=0,this.outs=0,this.microcode=["break;"]}encode(){return[[this.opcode,0,0,0]]}},cc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=1,this.ins=0,this.outs=1,this.microcode=["out0 = vec4(atom0.y, atom0.y, atom0.y, atom0.y);"]}encode(t){return[[this.opcode,t,0,0]]}},lc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=1,this.ins=0,this.outs=1,this.microcode=["out0 = vec4(atom0.yzw, 0.0);"]}encode(t){return[[this.opcode,t[0]||0,t[1]||0,t[2]||0]]}},hc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=2,this.ins=0,this.outs=1,this.microcode=["out0 = atom1;"]}encode(t){return[[this.opcode,0,0,0],t]}};function Te(t){return[`float duration = clamp(${t.duration}, 0.05, 3600.0);`,`float startTimeOffset = ${t.startTimeOffset};`,`float repeatDelay = ${t.repeatDelay};`,`float timeOriginSelector = ${t.timeOriginSelector};`,`float repeatType = ${t.repeatType};`,`float easing = ${t.easing};`,`float playAnimation = ${t.playAnimation} * (1.0 - step(0.0, -${t.duration}));`,`float reverseAnimation = ${t.reverseAnimation};`,"float time = globalTime - (timeOriginSelector == 1.0 ? localTimeOrigin : 0.0);","time *= playAnimation;","time *= 1.0 - reverseAnimation * 2.0;","float period = duration + repeatDelay;","time += reverseAnimation == 1.0 ? (period - startTimeOffset - 0.001) : startTimeOffset + 0.001;","float omega = time / period;","float oi = floor(omega);","omega = repeatType == 1.0 || repeatType == 3.0 ? omega - oi : omega;","float of = omega * period;","of = (clamp(of, reverseAnimation * repeatDelay, period - (1.0 - reverseAnimation) * repeatDelay) - reverseAnimation * repeatDelay) / duration;","of = easing == 2.0 ? pow(of, 3.0) : of;","of = easing == 3.0 ? 1.0 - pow(1.0 - of, 3.0) : of;","of = easing == 4.0 ? of < 0.5 ? 4.0 * pow(of, 3.0) : 1.0 - pow(-2.0 * of + 2.0, 3.0) / 2.0 : of;","bool oscillate = repeatType == 3.0 && mod(oi, 2.0) == 1.0;",`${t.out} = oscillate ? 1.0 - of : of;`]}const uc={Linear:1,EaseIn:2,EaseOut:3,EaseInOut:4},dc={Loop:1,None:2,Oscillate:3},fc={Local:1,Global:2};function Fe(t){const e=uc[t.easing],s=dc[t.repeatType],r=fc[t.timeOriginSelector];return[[t.duration,t.startTimeOffset,t.repeatDelay,r],[s,e,t.playAnimation,t.reverseAnimation]]}let pc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=10,this.ins=1,this.outs=1,this.microcode=["vec2 fromTranslation = atom1.xy;","vec2 toTranslation = atom1.zw;","float fromRotation = atom2.x;","float toRotation = atom2.y;","float fromScale = atom2.z;","float toScale = atom2.w;","bool relativeTranslation = atom9.x == 1.0;","bool absoluteScale = atom9.y == 1.0;","vec2 translationMultiplier = relativeTranslation ? pixelDimensions : vec2(1.0, 1.0);","float scaleDivisor = absoluteScale ? pixelDimensions.y : 1.0;","float fTranslation;","{",...Te({duration:"atom3.x",startTimeOffset:"atom3.y",repeatDelay:"atom3.z",timeOriginSelector:"atom3.w",repeatType:"atom4.x",easing:"atom4.y",playAnimation:"atom4.z",reverseAnimation:"atom4.w",out:"fTranslation"}),"}","float fRotation;","{",...Te({duration:"atom5.x",startTimeOffset:"atom5.y",repeatDelay:"atom5.z",timeOriginSelector:"atom5.w",repeatType:"atom6.x",easing:"atom6.y",playAnimation:"atom6.z",reverseAnimation:"atom6.w",out:"fRotation"}),"}","float fScale;","{",...Te({duration:"atom7.x",startTimeOffset:"atom7.y",repeatDelay:"atom7.z",timeOriginSelector:"atom7.w",repeatType:"atom8.x",easing:"atom8.y",playAnimation:"atom8.z",reverseAnimation:"atom8.w",out:"fScale"}),"}","vec2 aTranslation = mix(fromTranslation, toTranslation, fTranslation);","float aRotation = mix(fromRotation, toRotation, fRotation);","float aScale = mix(fromScale, toScale, fScale);","vec2 pTranslation = in0.xy;","float pRotation = in0.z;","float pScale = in0.w;","aTranslation *= translationMultiplier;","aScale /= scaleDivisor;","float rotation = pRotation + aRotation;","float scale = pScale * aScale;","float sin1 = sin(pRotation);","float cos1 = cos(pRotation);","float s1 = pScale;","float x1 = pTranslation.x;","float y1 = pTranslation.y;","float x2 = aTranslation.x;","float y2 = aTranslation.y;",`
    vec2 translation = vec2(
      cos1 * s1 * x2 - sin1 * s1 * y2 + x1,
      sin1 * s1 * x2 + cos1 * s1 * y2 + y1
    );
    `,"out0 = vec4(translation, rotation, scale);"]}encode(t){return[[this.opcode,0,0,0],[t.translation.from[0],t.translation.from[1],t.translation.to[0],t.translation.to[1]],[t.rotation.from,t.rotation.to,t.scale.from,t.scale.to],...Fe(t.translation.timing),...Fe(t.rotation.timing),...Fe(t.scale.timing),[t.relativeTranslation?1:0,t.absoluteScale?1:0,0,0]]}},mc=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=7,this.ins=1,this.outs=1,this.microcode=["float fromOpacity = atom0.y;","float toOpacity = atom0.z;","vec4 fromColor = atom1;","vec4 toColor = atom2;","float fColor;","{",...Te({duration:"atom3.x",startTimeOffset:"atom3.y",repeatDelay:"atom3.z",timeOriginSelector:"atom3.w",repeatType:"atom4.x",easing:"atom4.y",playAnimation:"atom4.z",reverseAnimation:"atom4.w",out:"fColor"}),"}","float fOpacity;","{",...Te({duration:"atom5.x",startTimeOffset:"atom5.y",repeatDelay:"atom5.z",timeOriginSelector:"atom5.w",repeatType:"atom6.x",easing:"atom6.y",playAnimation:"atom6.z",reverseAnimation:"atom6.w",out:"fOpacity"}),"}","vec4 aColor = mix(fromColor, toColor, fColor);","aColor.a *= mix(fromOpacity, toOpacity, fOpacity);","vec4 pColor = in0;","out0 = aColor * pColor;"]}encode(t){return[[this.opcode,t.opacity.from,t.opacity.to,0],[t.color.from[0],t.color.from[1],t.color.from[2],t.color.from[3]],[t.color.to[0],t.color.to[1],t.color.to[2],t.color.to[3]],...Fe(t.color.timing),...Fe(t.opacity.timing)]}},_c=class extends me{constructor(){super(...arguments),this.opcode=++_e,this.length=4,this.ins=1,this.outs=1,this.microcode=["float fromShift = atom0.y;","float toShift = atom0.z;","float duration = atom1.x;","bool multiplyByLineLength = atom3.x == 1.0;","float fShift;","{",...Te({duration:"duration",startTimeOffset:"atom1.y",repeatDelay:"atom1.z",timeOriginSelector:"atom1.w",repeatType:"atom2.x",easing:"atom2.y",playAnimation:"atom2.z",reverseAnimation:"atom2.w",out:"fShift"}),"}","toShift *= multiplyByLineLength ? lineLength : 1.0;","float aShift = mix(fromShift, toShift, fShift);","vec4 pShift = in0;","out0 = mod(aShift + pShift, lineLength);"]}encode(t){return[[this.opcode,t.shift.from,t.shift.to,0],...Fe(t.shift.timing),[t.multiplyByLineLength?1:0,0,0,0]]}};const he={scalar:new cc,vector3:new lc,vector4:new hc,animatedTransform:new pc,animatedColor:new mc,animatedShift:new _c,ret:new oc},Pr=4;function Qe(t){return t instanceof Ze?t:typeof t=="object"&&"type"in t?bc[t.type].hydrate(t):new Ae(t)}let Ze=class{constructor(t){this.inputs=t}encode(){const t=[];for(const e of this.inputs)t.push(...e.encode());return t.push(...this.instructions),t}},Ae=class extends Ze{constructor(t){super([]),this.value=t}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[t,e,s,r]=this.value;return r!=null?he.vector4.encode([t,e||0,s||0,r]):he.vector3.encode([t,e||0,s||0])}return he.scalar.encode(this.value)}},yc=class ls extends Ze{constructor(e,s){super([s]),this._config=e,this._parent=s}static hydrate(e){return new ls(e,Qe(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof Ae))return this;const[s,r,i,a]=e.value,n=this._config.translation.from[0],o=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(n===this._config.translation.to[0]&&o===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=i+c,u=a*l,d=Math.sin(i),f=Math.cos(i);return new Ae([f*a*n-d*a*o+s,d*a*n+f*a*o+r,h,u])}return new ls(this._config,e)}get instructions(){return he.animatedTransform.encode(this._config)}},gc=class hs extends Ze{constructor(e,s){super([s]),this._config=e,this._parent=s}static hydrate(e){return new hs(e,Qe(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof Ae))return this;const[s,r,i,a]=e.value,n=this._config.color.from[0],o=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return n===this._config.color.to[0]&&o===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new Ae([s*n,r*o,i*c,a*l])):new hs(this._config,e)}get instructions(){return he.animatedColor.encode(this._config)}},xc=class us extends Ze{constructor(e,s){super([s]),this._config=e,this._parent=s}static hydrate(e){return new us(e,Qe(e.parent))}simplify(){const e=this._parent.simplify();return e instanceof Ae?new us(this._config,e):this}get instructions(){return he.animatedShift.encode(this._config)}};const bc={AnimatedTransform:yc,AnimatedColor:gc,AnimatedShift:xc};function wc(t){return ji(t.map(e=>z(e)).map(e=>Qe(e).simplify()))}function Ic(t){const e=[];return e.push(t.transform),e.push(t.fromColor),e.push(t.toColor),e.push(t.colorMix),e.push(t.toOpacity),e.push(t.opacityMix),t?.shift?e.push(t?.shift):e.push([1,1,1,1]),e}function ji(t){const e=[],s=[];let r=0;for(const i of t){const a=[...i.encode(),...he.ret.encode()];e.push([r+t.length,0,0,0]),s.push(...a),r+=a.length}return[...e,...s]}async function ds(t,e){const s=t;let r;if(typeof s=="number"||typeof s=="string"||typeof s=="boolean")r=s;else if(Array.isArray(s))r=await Promise.all(s.map(i=>ds(i,e)));else if(typeof s=="object")if("valueExpressionInfo"in s){const{valueExpressionInfo:i}=s,{expression:a}=i;r={...s,computed:await e.createComputedField({expression:a})}}else{r={};for(const i in s)r[i]=await ds(s[i],e)}return r}function z(t,e,s){function r(n){if(!("computed"in n))return n;let o=n.computed.readWithDefault(e,s,[255*n.defaultValue[0],255*n.defaultValue[1],255*n.defaultValue[2],n.defaultValue[3]]);if(typeof o=="string"){const c=oi.fromString(o);c&&(o=[c.r,c.g,c.b,c.a])}return o}const i=t;let a;if(typeof i=="number"||typeof i=="string"||typeof i=="boolean")a=i;else if(Array.isArray(i))a=i.map(n=>z(n,e,s));else if(typeof i=="object")if("type"in i&&i.type!=null&&i.type==="Process")switch(i.op){case"ArcadeColor":{const n=z(i.value,e,s);qe(Array.isArray(n)&&n.length===4),a=[n[0]/255,n[1]/255,n[2]/255,n[3]]}break;case"Transparency":{const n=z(i.value,e,s);qe(typeof n=="number"),a=1-n/100}break;case"Divide":case"Multiply":case"Add":{const n=z(i.left,e,s);qe(typeof n=="number");const o=z(i.right,e,s);switch(qe(typeof o=="number"),i.op){case"Divide":a=n/o;break;case"Multiply":a=n*o;break;case"Add":a=n+o}}break;case"Random":{const n=z(i.seed,e,s),o=z(i.min,e,s),c=z(i.max,e,s),l=e.getObjectId(),h=Vi(l||0);a=o+Wi(h,n)*(c-o)}break;case"Cond":{const n=z(i.condition,e,s),o=z(i.ifTrue,e,s),c=z(i.ifFalse,e,s);a=n?o:c}break;case"MatchWinding":{const n=z(i.sign,e,s);let o=z(i.angle,e,s);if(n>0)for(;o<0;)o+=2*Math.PI;else for(;o>0;)o-=2*Math.PI;a=o}}else if("computed"in i)a=r(i);else{a={};for(const n in i)a[n]=z(i[n],e,s)}return a}function*L(t){const e=t;if(Array.isArray(e))for(const s of e)yield*L(s);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*L(e.value);break;case"Divide":case"Multiply":case"Add":yield*L(e.left),yield*L(e.right);break;case"Random":yield*L(e.seed),yield*L(e.min),yield*L(e.max);break;case"Cond":yield*L(e.condition),yield*L(e.ifTrue),yield*L(e.ifFalse);break;case"MatchWinding":yield*L(e.sign),yield*L(e.angle)}else if("computed"in e)yield e.computed;else for(const s in e)yield*L(e[s])}function qe(t){if(!t)throw new Error("Assertion failed.")}const Ds={type:y.SHORT,count:2,packPrecisionFactor:ue,pack:({scaleInfo:t},{tileInfo:e})=>fe(t,e)},Sc={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:t})=>(qe(t),t)},Yi={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},vc={type:y.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Hi={type:y.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:t})=>t},kc={type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},Mc={type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},Tc={type:y.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[t,e]},Ls={type:y.UNSIGNED_BYTE,count:3,pack:"id"},Bs={type:y.UNSIGNED_BYTE,count:1,pack:ic},qs={type:y.SHORT,count:2,pack:"position",packPrecisionFactor:1},Ns={marker:{type:y.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:t})=>[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}},line:{type:y.FLOAT,count:2,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e},{baseSize:s})=>[t*s/2,e*s/2]},fill:{type:y.FLOAT,count:2,packTessellation:()=>[0,0]}},Fc={marker:{type:y.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}}},Xi={type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+A,a=e.y+A;return[i+1,a+1,i+s-1,a+r-1]}},Gs={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:t,baseSize:e,referenceSize:s})=>[t.dataColumn,t.dataRow,e,s]},Us={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:t,pixelDimensions:e,baseSize:s,sprite:r,sizeRatio:i})=>{const a=Math.max(s*r.width/r.height,s),n=r.sdfDecodeCoeff*a*i;return[e[0],e[1],t,n]}},Pc={type:y.BYTE,count:1,packTessellation:({angle:t})=>t};function $s(t){let{pixelDimensions:e,texelDimensions:s,baseSize:r,referenceSize:i,strokeWidth:a,sizeRatio:n}=t;if(e||(e=t.sprite.sdf?[0,0]:[t.sprite.width,t.sprite.height]),s||(s=t.sprite.sdf?[0,0]:e),t.patternHeight!=null){const c=t.patternHeight/e[1];e[1]*=c,e[0]*=c}r===-1&&(r=e[1]),r=w(r),i=w(i),a=w(a);const o=(t.sprite.sdfDecodeCoeff??1)*n;return{...t,pixelDimensions:e,texelDimensions:s,baseSize:r,referenceSize:i,strokeWidth:a,sdfDecodeCoeff:o}}const Cc=3.14159265359/128,Ac=1e-30,Qi=4,Zi=0,Ec=2,Oc=2,Rc=3,zc=0,Dc=3,_t=16,Cr=128,Lc=1,Ut=64,Bc=64,qc=2;let Ki=class extends $i{get vertexSpec(){return{createComputedParams:$s,optionalAttributes:{zoomRange:Ds,value1Position2Value2:Sc,lineLength:Hi},attributes:{id:Ls,bitset:Bs,pos:qs,offset:Ns.marker,uv:Fc.marker,animationPointerAndBaseSizeAndReferenceSize:Gs,sizing:Us,angle:Pc}}}_write(t,e,s){const r=this.evaluatedMeshParams.sprite,{textureBinding:i}=r;t.recordStart(this.instanceId,this.attributeLayout,i);const a=e.getDisplayId();if(this.shift&&e.geometryType==="esriGeometryPolyline"){if(!s){const n=B.fromFeatureSetReaderCIM(e);n&&this._writeParticles(t,e,n)}}else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(t,e);else if(e.geometryType==="esriGeometryPolygon"){const n=e.readCentroidForDisplay();if(!n)return;const[o,c]=n.coords;this._writeQuad(t,a,o,c)}else if(e.geometryType==="esriGeometryPoint"){const n=e.readXForDisplay(),o=e.readYForDisplay();this._writeQuad(t,a,n,o)}else{const n=e.readGeometryForDisplay();n&&n.forEachVertex((o,c)=>{this._writeQuad(t,a,o,c)})}t.recordEnd()}_writePlacedMarkers(t,e){const s=B.fromFeatureSetReaderCIM(e)?.clone();if(!s)return;const r=-1,i=Rs.getPlacement(s,r,this.evaluatedMeshParams.placement,w(1),t.id);if(!i)return;const a=e.getDisplayId();let n=i.next(),o=null;for(;n!=null;){const c=n.tx,l=-n.ty;if(Math.abs(c)>we||Math.abs(l)>we){n=i.next();continue}const h=-n.getAngle();t.recordBounds(c,l,Ut,Bc),this.shift?o&&this._writeQuad(t,a,o[0],o[1],void 0,h):this._writeQuad(t,a,c,l,void 0,h),o=[c,l],n=i.next()}}_writeParticles(t,e,s){const r=e.getDisplayId();for(;s.nextPath();){const i=[];for(;s.nextPoint();)i.push([s.x,s.y]);const a=Nc(i);let n=0;for(let l=1;l<i.length;l++){const h=i[l][0]-i[l-1][0],u=i[l][1]-i[l-1][1],d=Math.sqrt(h*h+u*u);n+=d}const o=l=>{for(const h of a){const{a:u,b:d}=h;this._writeQuad(t,r,u.position[0],u.position[1],[u.distance-l,d.position[0],d.position[1],d.distance-l],this.evaluatedMeshParams.angleToLine?Math.atan2(u.direction[1],u.direction[0]):0,n,!0)}},{placement:c}=this.evaluatedMeshParams;if(!c||"placementTemplate"in c||c.type==="CIMMarkerPlacementOnVertices"){let l;if(c&&c.type!=="CIMMarkerPlacementOnVertices")l=c.placementTemplate;else{l=[0];for(const u of a){const{a:d,b:f}=u,p=d.position[0]-f.position[0],m=d.position[1]-f.position[1],_=Math.sqrt(p*p+m*m);l.push(_)}}let h=-1*n;for(;h<(1+qc/2)*n;)for(const u of l)h+=u,o(h)}else c.type==="CIMMarkerPlacementAtExtremities"?c.extremityPlacement==="JustBegin"?o(1):c.extremityPlacement==="JustEnd"?(o(n-1),o(-1)):c.extremityPlacement==="Both"&&(o(1),o(n-1)):c.type==="CIMMarkerPlacementOnLine"&&(c.relativeTo==="LineBeginning"?o(1):c.relativeTo==="LineEnd"?(o(n-1),o(-1)):c.relativeTo==="LineMiddle"&&o(n/2))}}_writeQuad(t,e,s,r,i,a=0,n=0,o=!1){const c=this.evaluatedMeshParams.sprite,{rect:l}=c,h=l.x+A,u=l.y+A,d=l.x+l.width-A,f=l.y+l.height-A,p=t.vertexCount();o||t.recordBounds(s,r,Ut,Ut);const m={texXmin:h,texYmin:u,texXmax:d,texYmax:f,value1Position2Value2:i,angle:a/Cc,lineLength:n};for(let _=0;_<4;_++)this._writeVertex(t,e,s,r,m);t.indexEnsureSize(6),t.indexWrite(p),t.indexWrite(p+1),t.indexWrite(p+2),t.indexWrite(p+1),t.indexWrite(p+3),t.indexWrite(p+2)}};function Nc(t){const e=[];let s=0;for(let r=1;r<t.length;r++){const i=t[r-1],a=t[r],n=a[0]-i[0],o=a[1]-i[1],c=Math.sqrt(n*n+o*o),l=n/c,h=o/c;e.push({a:{position:i,distance:s,direction:[l,h]},b:{position:a,distance:s+c,direction:[l,h]}}),s+=c}return e}let Gc=class extends Ki{constructor(){super(...arguments),this.shift=!1}},Uc=class extends Ki{constructor(){super(...arguments),this.shift=!0}};function $c(t,e,s,r,i,a,n){ms=0;const o=(r-s)*a,c=i&&i.length,l=c?(i[0]-s)*a:o;let h,u,d,f,p,m=Ji(e,s,r,0,l,a,!0);if(m&&m.next!==m.prev){if(c&&(m=Yc(e,s,r,i,m,a)),o>80*a){h=d=e[0+s*a],u=f=e[1+s*a];for(let _=a;_<l;_+=a){const g=e[_+s*a],b=e[_+1+s*a];h=Math.min(h,g),u=Math.min(u,b),d=Math.max(d,g),f=Math.max(f,b)}p=Math.max(d-h,f-u),p=p!==0?1/p:0}Ve(m,t,a,h,u,p,n,0)}}function Ji(t,e,s,r,i,a,n){let o;if(n===Kc(t,e,s,r,i,a)>0)for(let c=r;c<i;c+=a)o=Ar(c+e*a,t[c+e*a],t[c+1+e*a],o);else for(let c=i-a;c>=r;c-=a)o=Ar(c+e*a,t[c+e*a],t[c+1+e*a],o);return o&&le(o,o.next)&&(je(o),o=o.next),o}function We(t,e=t){if(!t)return t;let s,r=t;do if(s=!1,r.steiner||!le(r,r.next)&&R(r.prev,r,r.next)!==0)r=r.next;else{if(je(r),r=e=r.prev,r===r.next)break;s=!0}while(s||r!==e);return e}function Ve(t,e,s,r,i,a,n,o){if(!t)return;!o&&a&&(t=ea(t,r,i,a));let c=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(a?Vc(t,r,i,a):Wc(t))e.push(l.index/s+n),e.push(t.index/s+n),e.push(h.index/s+n),je(t),t=h.next,c=h.next;else if((t=h)===c){o?o===1?Ve(t=el(t,e,s,n),e,s,r,i,a,n,2):o===2&&tl(t,e,s,r,i,a,n):Ve(We(t),e,s,r,i,a,n,1);break}}}function Wc(t){const e=t.prev,s=t,r=t.next;if(R(e,s,r)>=0)return!1;let i=t.next.next;const a=i;let n=0;for(;i!==t.prev&&(n===0||i!==a);){if(n++,Ie(e.x,e.y,s.x,s.y,r.x,r.y,i.x,i.y)&&R(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Vc(t,e,s,r){const i=t.prev,a=t,n=t.next;if(R(i,a,n)>=0)return!1;const o=i.x<a.x?i.x<n.x?i.x:n.x:a.x<n.x?a.x:n.x,c=i.y<a.y?i.y<n.y?i.y:n.y:a.y<n.y?a.y:n.y,l=i.x>a.x?i.x>n.x?i.x:n.x:a.x>n.x?a.x:n.x,h=i.y>a.y?i.y>n.y?i.y:n.y:a.y>n.y?a.y:n.y,u=fs(o,c,e,s,r),d=fs(l,h,e,s,r);let f=t.prevZ,p=t.nextZ;for(;f&&f.z>=u&&p&&p.z<=d;){if(f!==t.prev&&f!==t.next&&Ie(i.x,i.y,a.x,a.y,n.x,n.y,f.x,f.y)&&R(f.prev,f,f.next)>=0||(f=f.prevZ,p!==t.prev&&p!==t.next&&Ie(i.x,i.y,a.x,a.y,n.x,n.y,p.x,p.y)&&R(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=u;){if(f!==t.prev&&f!==t.next&&Ie(i.x,i.y,a.x,a.y,n.x,n.y,f.x,f.y)&&R(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==t.prev&&p!==t.next&&Ie(i.x,i.y,a.x,a.y,n.x,n.y,p.x,p.y)&&R(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Ar(t,e,s,r){const i=yt.create(t,e,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function je(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function jc(t){let e=t,s=t;do(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next;while(e!==t);return s}function Yc(t,e,s,r,i,a){const n=new Array;for(let o=0,c=r.length;o<c;o++){const l=Ji(t,e,s,r[o]*a,o<c-1?r[o+1]*a:s*a,a,!1);l===l.next&&(l.steiner=!0),n.push(jc(l))}n.sort(Jc);for(const o of n)i=Hc(o,i);return i}function Hc(t,e){const s=Xc(t,e);if(!s)return e;const r=sa(s,t);return We(r,r.next),We(s,s.next)}function Xc(t,e){let s=e;const r=t.x,i=t.y;let a,n=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const d=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(d<=r&&d>n){if(n=d,d===r){if(i===s.y)return s;if(i===s.next.y)return s.next}a=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!a)return null;if(r===n)return a.prev;const o=a,c=a.x,l=a.y;let h,u=1/0;for(s=a.next;s!==o;)r>=s.x&&s.x>=c&&r!==s.x&&Ie(i<l?r:n,i,c,l,i<l?n:r,i,s.x,s.y)&&(h=Math.abs(i-s.y)/(r-s.x),(h<u||h===u&&s.x>a.x)&&Ye(s,t)&&(a=s,u=h)),s=s.next;return a}function ea(t,e,s,r){let i;for(;i!==t;i=i.next){if(i=i||t,i.z===null&&(i.z=fs(i.x,i.y,e,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,ea(t,e,s,r);i.prevZ=i.prev,i.nextZ=i.next}return t.prevZ.nextZ=null,t.prevZ=null,Qc(t)}function Qc(t){let e,s=1;for(;;){let r,i=t;t=null,e=null;let a=0;for(;i;){a++,r=i;let n=0;for(;n<s&&r;n++)r=r.nextZ;let o=s;for(;n>0||o>0&&r;){let c;n===0?(c=r,r=r.nextZ,o--):o!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,n--):(c=r,r=r.nextZ,o--):(c=i,i=i.nextZ,n--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}i=r}if(e.nextZ=null,s*=2,a<2)return t}}function R(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function ta(t,e,s,r){return!!(le(t,e)&&le(s,r)||le(t,r)&&le(s,e))||R(t,e,s)>0!=R(t,e,r)>0&&R(s,r,t)>0!=R(s,r,e)>0}function Zc(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&ta(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}function Kc(t,e,s,r,i,a){let n=0;for(let o=r,c=i-a;o<i;o+=a)n+=(t[c+e*a]-t[o+e*a])*(t[o+1+e*a]+t[c+1+e*a]),c=o;return n}function Ie(t,e,s,r,i,a,n,o){return(i-n)*(e-o)-(t-n)*(a-o)>=0&&(t-n)*(r-o)-(s-n)*(e-o)>=0&&(s-n)*(a-o)-(i-n)*(r-o)>=0}function Ye(t,e){return R(t.prev,t,t.next)<0?R(t,e,t.next)>=0&&R(t,t.prev,e)>=0:R(t,e,t.prev)<0||R(t,t.next,e)<0}function fs(t,e,s,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function le(t,e){return t.x===e.x&&t.y===e.y}function Jc(t,e){return t.x-e.x}function el(t,e,s,r){let i=t;do{const a=i.prev,n=i.next.next;!le(a,n)&&ta(a,i,i.next,n)&&Ye(a,n)&&Ye(n,a)&&(e.push(a.index/s+r),e.push(i.index/s+r),e.push(n.index/s+r),je(i),je(i.next),i=t=n),i=i.next}while(i!==t);return i}function tl(t,e,s,r,i,a,n){let o=t;do{let c=o.next.next;for(;c!==o.prev;){if(o.index!==c.index&&sl(o,c)){let l=sa(o,c);return o=We(o,o.next),l=We(l,l.next),Ve(o,e,s,r,i,a,n,0),void Ve(l,e,s,r,i,a,n,0)}c=c.next}o=o.next}while(o!==t)}function sl(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!Zc(t,e)&&Ye(t,e)&&Ye(e,t)&&rl(t,e)}function rl(t,e){let s=t,r=!1;const i=(t.x+e.x)/2,a=(t.y+e.y)/2;do s.y>a!=s.next.y>a&&s.next.y!==s.y&&i<(s.next.x-s.x)*(a-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==t);return r}function sa(t,e){const s=yt.create(t.index,t.x,t.y),r=yt.create(e.index,e.x,e.y),i=t.next,a=e.prev;return t.next=e,e.prev=t,s.next=i,i.prev=s,r.next=s,s.prev=r,a.next=r,r.prev=a,r}let yt=class ra{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,s,r){const i=ms<ps.length?ps[ms++]:new ra;return i.index=e,i.x=s,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}};const ps=[],il=8096;let ms=0;for(let t=0;t<il;t++)ps.push(new yt);const al=1e-5,ce=new hi(0,0,0,1,0),_s=new hi(0,0,0,1,0);function Er(t,e,s){let r=0;for(let i=1;i<s;i++){const a=t[2*(e+i-1)],n=t[2*(e+i-1)+1];r+=(t[2*(e+i)]-a)*(t[2*(e+i)+1]+n)}return r}function nl(t,e,s,r,i){let a=0;const n=2;for(let o=s;o<r;o+=3){const c=(t[o]-i)*n,l=(t[o+1]-i)*n,h=(t[o+2]-i)*n;a+=Math.abs((e[c]-e[h])*(e[l+1]-e[c+1])-(e[c]-e[l])*(e[h+1]-e[c+1]))}return a}function ia(t,e){const{coords:s,lengths:r}=e,i=0,a=t;let n=0;for(let o=0;o<r.length;){let c=o,l=r[o],h=Er(s,n,l);const u=[];for(;++c<r.length;){const m=r[c],_=Er(s,n+l,m);if(!(_>0))break;h+=_,u.push(n+l),l+=m}const d=a.length;$c(a,s,n,n+l,u,2,i);const f=nl(a,s,d,a.length,i),p=Math.abs(h);if(Math.abs((f-p)/Math.max(1e-7,p))>al)return a.length=0,!1;o=c,n+=l}return!0}function ol(t){const{coords:e,lengths:s}=t,{buffer:r}=li(e,s);return r}function cl(t,e,s){let r=0;for(let i=0;i<t.lengths.length;i++){const a=t.lengths[i];for(let n=0;n<a;n++){const o=t.coords[2*(n+r)],c=t.coords[2*(n+r)+1];if(o<e||o>s||c<e||c>s)return!0}r+=a}return!1}function Ws(t,e){if(t==null)return null;if(!cl(t,-128,T+128))return t;ce.setPixelMargin(e),ce.reset(3);let s=0;for(let n=0;n<t.lengths.length;n++){const o=t.lengths[n];let c=t.coords[2*(0+s)],l=t.coords[2*(0+s)+1];ce.moveTo(c,l);for(let h=1;h<o;h++)c=t.coords[2*(h+s)],l=t.coords[2*(h+s)+1],ce.lineTo(c,l);ce.close(),s+=o}const r=ce.result(!1);if(!r)return null;const i=[],a=[];for(const n of r){let o=0;for(const c of n)a.push(c.x),a.push(c.y),o++;i.push(o)}return new D(i,a)}function aa(t,e){_s.setPixelMargin(e);const s=_s,r=-e,i=T+e;let a=[],n=!1;if(!t.nextPath())return null;let o=t.pathLength(),c=!0;for(;c;){t.seekPathStart();const l=[];if(!t.pathSize)return null;s.reset(2),t.nextPoint();let h=t.x,u=t.y;if(n)s.moveTo(h,u);else{if(h<r||h>i||u<r||u>i){n=!0;continue}l.push({x:h,y:u})}let d=!1;for(;t.nextPoint();)if(h=t.x,u=t.y,n)s.lineTo(h,u);else{if(h<r||h>i||u<r||u>i){d=!0;break}l.push({x:h,y:u})}if(d)n=!0;else{if(n){const f=s.resultWithStarts();if(f)for(const p of f)a.push({...p,pathLength:o})}else a.push({line:l,start:0,pathLength:o});c=t.nextPath(),o=c?t.pathLength():0,n=!1}}return a=a.filter(l=>l.line.length>1),a.length===0?null:a}ce.setExtent(T),_s.setExtent(T);let na=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const K={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:ue,pack:({scaleInfo:t},{tileInfo:e})=>fe(t,e)}},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:y.UNSIGNED_BYTE,count:1},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>C(t)},offset:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[Je(t,16),Je(e,16)]},normal:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[Je(t,16),Je(e,16)]},halfWidth:{type:y.HALF_FLOAT,count:1,pack:({width:t})=>w(.5*t)},referenceHalfWidth:{type:y.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>w(.5*t)}}};let ll=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}};const tt=65535;let Et=class extends pe{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=K,this._currentWrite=new ll,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:tt,textured:!1},this._tessParams=new na,this._initializeTessellator()}writeLineVertices(t,e,s){const r=this._getLines(e);r!=null&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new ci(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,s){const r=s??B.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,e),t.recordEnd()}_getLines(t){return aa(t,qi(this.evaluatedMeshParams))}_writeVertices(t,e,s){const{_currentWrite:r,_tessellationOptions:i,evaluatedMeshParams:a}=this,{width:n,capType:o,joinType:c,miterLimit:l,hasSizeVV:h}=a,u=w(.5*n);i.halfWidth=u,i.capType=Ri(o),i.joinType=zi(c),i.miterLimit=l;const d=!h;r.out=t,r.id=e.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=d&&u<Va?0:1;for(const{line:f,start:p,pathLength:m}of s)i.initialDistance=p%tt,r.pathLength=m,r.distanceOffset=Math.floor(p/tt)*tt,this._lineTessellator.tessellate(f,i,d)}_writeTesselatedVertex(t,e,s,r,i,a,n,o,c,l,h){const{out:u,id:d,vertexBounds:f,pathLength:p,distanceOffset:m}=this._currentWrite;return this.hasEffects&&u.recordBounds(t,e,f,f),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=a,this._tessParams.distance=h,this._tessParams.pathLength=p,this._tessParams.distanceOffset=m,this._writeVertex(u,d,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}},oa=class extends $i{_write(t,e,s){const r=s??B.fromFeatureSetReaderCIM(e);if(!r)return;const i=this.evaluatedMeshParams.sprite,{textureBinding:a}=i;t.recordStart(this.instanceId,this.attributeLayout,a);const n=e.getDisplayId();this._writePoly(t,n,r.asOptimized()),t.recordEnd()}},hl=class extends oa{constructor(){super(...arguments),this.vertexSpec={createComputedParams:$s,attributes:{id:Ls,bitset:Bs,pos:qs,offset:Ns.fill,tlbr:Xi,animationPointerAndBaseSizeAndReferenceSize:Gs,sizing:Us},optionalAttributes:{zoomRange:Ds,value1Position2Value2:Yi,lineLength:vc}}}_writePoly(t,e,s){const r=this._clip(s);if(!r)return;s=r;const i=[],a=t.vertexCount();let n;if(ia(i,s)){if(i.length===0)return;n=0;for(const o of i){const c=s.coords[2*o],l=s.coords[2*o+1];this._writeVertex(t,e,c,l),n++}}else{const{coords:o,lengths:c}=s,l=li(o,c);n=l.vertexCount;for(let h=0;h<l.buffer.length/2;h++){const u=l.buffer[2*h],d=l.buffer[2*h+1];this._writeVertex(t,e,u,d)}}if(n>0){t.indexEnsureSize(n);for(let o=0;o<n;o++)t.indexWrite(o+a)}}_clip(t){const e=this.hasEffects;return Ws(t,e?256:8)}},ul=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Or=65535;let dl=class extends oa{constructor(){super(...arguments),this.vertexSpec={createComputedParams:$s,attributes:{id:Ls,bitset:Bs,pos:qs,offset:Ns.line,tlbr:Xi,animationPointerAndBaseSizeAndReferenceSize:Gs,sizing:Us,accumulatedDistance:kc,normal:Tc,segmentDirection:Mc},optionalAttributes:{zoomRange:Ds,value1Position2Value2:Yi,lineLength:Hi}},this._tessParams=new na,this._currentWrite=new ul,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Or,textured:!1},this._lineLength=0,this._lineTessellator=new ci((t,e,s,r,i,a,n,o,c,l,h)=>this._writeTesselatedVertex(t,e,s,r,i,a,n,o,c,l,h,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(t,e,s){const r=aa(B.fromOptimized(s,"esriGeometryPolyline"),64);if(r==null)return;const{_currentWrite:i,_tessellationOptions:a}=this,{baseSize:n,capType:o,joinType:c,miterLimit:l}=this.evaluatedMeshParams,h=w(.5*n);a.halfWidth=h,a.capType=Ri(o||"Round"),a.joinType=zi(c||"Round"),a.miterLimit=l||2,i.out=t,i.id=e,i.vertexCount=0,i.indexCount=0,i.vertexFrom=t.vertexCount(),i.vertexBounds=1;for(const{line:u,start:d,pathLength:f}of r){a.initialDistance=d%Or,i.pathLength=f,this._lineLength=0;for(let p=1;p<u.length;p++){const m=u[p].x-u[p-1].x,_=u[p].y-u[p-1].y;this._lineLength+=Math.sqrt(m*m+_*_)}this._lineTessellator.tessellate(u,a,!1)}}_writeTesselatedVertex(t,e,s,r,i,a,n,o,c,l,h,u){const{out:d,id:f,vertexBounds:p,pathLength:m}=this._currentWrite;return this.hasEffects&&d.recordBounds(t,e,p,p),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=a,this._tessParams.distance=h,this._tessParams.pathLength=m,this._tessParams.lineLength=u,this._writeVertex(d,f,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(s),this._currentWrite.indexCount+=3}};const fl=100,pl=v("featurelayer-fast-triangulation-enabled");let Vs=class extends pe{async loadDependencies(){await Promise.all([super.loadDependencies(),ln()])}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,i),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return Ws(t,e?256:8)}_writeGeometry(t,e,s){const r=s.maxLength>fl,i=[],a=this.createTesselationParams(e);if(!r&&pl&&ia(i,s))return void(i.length&&this._writeVertices(t,e,s.coords,a,i));const n=ol(s);this._writeVertices(t,e,n,a)}_writeVertices(t,e,s,r,i){const a=e.getDisplayId(),n=t.vertexCount(),o=this.hasEffects;let c=0;if(i)for(const l of i){const h=s[2*l],u=s[2*l+1];o&&t.recordBounds(h,u,0,0),this._writeVertex(t,a,h,u,r),c++}else for(let l=0;l<s.length;l+=2){const h=Math.round(s[l]),u=Math.round(s[l+1]);o&&t.recordBounds(h,u,0,0),this._writeVertex(t,a,h,u,r),c++}t.indexEnsureSize(c);for(let l=0;l<c;l++)t.indexWrite(l+n)}};const ml={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:y.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let _l=class extends Vs{constructor(){super(...arguments),this.vertexSpec=ml}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const He={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:ue,pack:({scaleInfo:t},{tileInfo:e})=>fe(t,e)}},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>C(t)}}};let js=class extends Vs{constructor(){super(...arguments),this.vertexSpec=He}createTesselationParams(t){return null}};const de={createComputedParams:t=>t,optionalAttributes:He.optionalAttributes,attributes:{...He.attributes,tlbr:{count:4,type:y.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+A,a=e.y+A;return[i,a,i+s,a+r]}},inverseRasterizationScale:{count:1,type:y.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let ca=class extends js{constructor(){super(...arguments),this.vertexSpec=de}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const a=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._writeGeometry(t,e,i),t.recordEnd()}};function gt(t){const{sprite:e,aspectRatio:s,scaleProportionally:r}=t,i=w(t.height),a=i>0?i:e.height;let n=i*s;return n<=0?n=e.width:r&&(n*=e.width/e.height),{width:n,height:a}}function la(t){const{applyRandomOffset:e,sampleAlphaOnly:s}=t;return Ee([[Ec,e],[Qi,s]])}const ha={createComputedParams:t=>t,optionalAttributes:de.optionalAttributes,attributes:{...de.attributes,bitset:{count:1,type:y.UNSIGNED_BYTE,pack:la},width:{count:1,type:y.HALF_FLOAT,pack:t=>gt(t).width},height:{count:1,type:y.HALF_FLOAT,pack:t=>gt(t).height},offset:{count:2,type:y.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[w(t),-w(e)]},scale:{count:2,type:y.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:y.UNSIGNED_BYTE,pack:({angle:t})=>hn(t)}}};let yl=class extends ca{constructor(){super(...arguments),this.vertexSpec=ha}};const ua={createComputedParams:t=>t,optionalAttributes:K.optionalAttributes,attributes:{...K.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>C(t)}}},Ys={createComputedParams:t=>t,optionalAttributes:K.optionalAttributes,attributes:{...K.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>Ee([[Zi,!0],[Lc,t.outlineUsesColorVV]])},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>C(t)}}};let Hs=class extends Et{constructor(){super(...arguments),this.vertexSpec=Ys}},Xs=class extends js{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ua,this._lineMeshWriter=this._createOutlineWriter(t,e,s,r)}_createOutlineWriter(t,e,s,r){return new Hs(t,e,s,r)}_write(t,e){const s=this.evaluatedMeshParams.effects,r=this.evaluatedMeshParams.outlineEffects;if(s?.length||r?.length){if(s?.length){const i=this.getEffectCursor(t,e,s);if(i){let a;for(;a=i?.next();)a.invertY(),this._writeFill(t,e,a)}}else this._writeFill(t,e);if(r?.length){const i=this.getEffectCursor(t,e,r);if(i){let a;for(;a=i?.next();)a.invertY(),this._writeOutline(t,e,a)}}else this._writeOutline(t,e)}else this._writeSimpleOutlineFill(t,e)}_writeSimpleOutlineFill(t,e){const s=e.readGeometryForDisplay(),r=this._clip(s);r&&(this._writeGeometry(t,e,r),this._lineMeshWriter.writeLineVertices(t,B.fromOptimizedCIM(r,"esriGeometryPolyline"),e))}_writeFill(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&this._writeGeometry(t,e,i)}_writeOutline(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay(),i=this._clip(r);i&&this._lineMeshWriter.writeLineVertices(t,B.fromOptimizedCIM(i,"esriGeometryPolyline"),e)}_clip(t){return t?Ws(t,qi(this.evaluatedMeshParams)):null}get effectInfos(){return[...this._evaluator.inputMeshParams.effects?.effectInfos??[],...this._evaluator.inputMeshParams.outlineEffects?.effectInfos??[]]}write(t,e,s,r,i){this.ensurePacked(e,s,r),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const xt=ha,gl=Ys,xl={createComputedParams:t=>t,optionalAttributes:xt.optionalAttributes,attributes:{...xt.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>la(t)},aux1:{count:1,type:y.HALF_FLOAT,pack:t=>gt(t).width},aux2:{count:1,type:y.HALF_FLOAT,pack:t=>gt(t).height},aux3:{count:2,type:y.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[w(t),w(e)]},aux4:{count:2,type:y.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*_t,e*_t]}}},bl={createComputedParams:t=>t,optionalAttributes:xt.optionalAttributes,attributes:{...xt.attributes,color:gl.attributes.color,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>Ee([[Zi,!0]])},aux1:{count:1,type:y.HALF_FLOAT,pack:t=>w(.5*t.width)},aux2:{count:1,type:y.HALF_FLOAT,pack:t=>w(.5*t.referenceWidth)},aux3:{count:2,type:y.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:y.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*_t+Cr,e*_t+Cr]}}};let wl=class extends Hs{constructor(){super(...arguments),this.vertexSpec=bl}},Il=class extends Xs{constructor(){super(...arguments),this.vertexSpec=xl}_createOutlineWriter(t,e,s,r){return new wl(t,e,s,r)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const a=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const $t={linear:0,rectangular:1,circular:2},Rr={isAbsolute:0,isDiscrete:1},Sl=()=>G.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let vl=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??=this.calculateRelativeSize(),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===mt.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},Qs=class extends vl{constructor(t,e,s,r){super(e,s),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:i,rotationMatrix00:a,rotationMatrix01:n,rotationMatrix10:o,rotationMatrix11:c}=this;t.forEachVertex((l,h)=>{const u=l*a+h*n,d=l*o+h*c;i.xmin=Math.min(i.xmin,u),i.ymin=Math.min(i.ymin,d),i.xmax=Math.max(i.xmax,u),i.ymax=Math.max(i.ymax,d)}),this.center=[(i.xmin+i.xmax)/2,(i.ymin+i.ymax)/2]}},kl=class extends Qs{constructor(t,e,s,r){super(t,e,s,r),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:s,rotationMatrix01:r,bounds:i}=this,{xmin:a,xmax:n}=i;return[(t*s+e*r-a)/(n-a),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,xmax:r}=e;return[w(t)/(r-s),0]}},Ml=class extends Qs{constructor(t,e,s,r){super(t,e,s,r),this.method="rectangular"}getRelativePosition(t,e){const{bounds:s,center:r,rotationMatrix00:i,rotationMatrix01:a,rotationMatrix10:n,rotationMatrix11:o}=this,c=t*n+e*o,l=t*i+e*a-r[0],h=c-r[1];return[l*(2/(s.xmax-s.xmin)),-h*(2/(s.ymax-s.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:s,ymin:r,xmax:i,ymax:a}=e;return[w(2*t)/(i-s),w(2*t)/(a-r)]}},Tl=class extends Qs{constructor(t,e,s){super(t,e,s,0),this.method="circular";const{xmin:r,xmax:i,ymin:a,ymax:n}=this.bounds,o=i-r,c=n-a;this.radius=Math.sqrt(o*o+c*c)/2}getRelativePosition(t,e){const{center:s,radius:r}=this;return[(t-s[0])/r,-((e-s[1])/r)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[w(t)/this.radius,0]}};function Fl(t,e){if(t==null)return null;const s=un(e.angle),r=e.gradientSize,i=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new kl(t,r,i,s);case"rectangular":return new Ml(t,r,i,s);case"circular":return new Tl(t,r,i);default:return Sl().errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const Pl={createComputedParams:t=>t,optionalAttributes:He.optionalAttributes,attributes:{...He.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let s=0;return t===mt.Absolute&&(s|=$(Rr.isAbsolute)),e.toLowerCase()==="discrete"&&(s|=$(Rr.isDiscrete)),s}},tlbr:{count:4,type:y.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+A+pt,a=e.y+A;return[i,a,i+s-2*pt,a+r]}},relativePosition:{count:2,type:y.HALF_FLOAT,packTessellation:({gradientStats:t},e,s,r)=>t?.getRelativePosition(s,r)??[0,0]},relativeGradientSize:{count:2,type:y.HALF_FLOAT,packTessellation:({gradientStats:t})=>t?.relativeSize??[1,1]},gradientMethod:{count:1,type:y.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return $t.rectangular;case"circular":return $t.circular;default:return $t.linear}}}}};let Cl=class extends Vs{constructor(){super(...arguments),this.vertexSpec=Pl}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:Fl(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(t,e,s){const r=s?.asOptimized()??e.readGeometryForDisplay();this._unclippedGeometry=r;const i=this._clip(r);if(!i)return void(this._unclippedGeometry=null);const a=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._writeGeometry(t,e,i),this._unclippedGeometry=null,t.recordEnd()}};const Al={optionalAttributes:de.optionalAttributes,createComputedParams:t=>t,attributes:{...de.attributes,...ua.attributes}},El={optionalAttributes:de.optionalAttributes,createComputedParams:t=>t,attributes:{...de.attributes,...Ys.attributes}};let Ol=class extends Hs{constructor(){super(...arguments),this.vertexSpec=El}},Rl=class extends Xs{constructor(){super(...arguments),this.vertexSpec=Al}_createOutlineWriter(t,e,s,r){return new Ol(t,e,s,r)}write(t,e,s,r,i){this.ensurePacked(e,s,r);const a=this.evaluatedMeshParams.sprite?.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._write(t,s),t.recordEnd()}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._lineMeshWriter.ensurePacked(t,e,s)}enqueueRequest(t,e,s){super.enqueueRequest(t,e,s),this._lineMeshWriter.enqueueRequest(t,e,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const zl={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},offset:{type:y.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Dl=class extends pe{constructor(){super(...arguments),this.vertexSpec=zl}_write(t,e){t.recordStart(this.instanceId,this.attributeLayout);const s=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const r=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(t,s,r,i)}else e.geometryType==="esriGeometryMultipoint"&&e.readGeometryForDisplay()?.forEachVertex((r,i)=>{r>=0&&r<=512&&i>=0&&i<=512&&this._writeQuad(t,s,r,i)});t.recordEnd()}_writeQuad(t,e,s,r){const i=t.vertexCount();this._writeVertex(t,e,s,r),t.indexWrite(i+0),t.indexWrite(i+1),t.indexWrite(i+2),t.indexWrite(i+1),t.indexWrite(i+3),t.indexWrite(i+2)}};const zr=2;let Dr=class da{constructor(e,s,r,i,a,n,o,c,l,h,u,d=[],f=0,p=0){this.displayId=e,this.labelClassId=s,this.labelIdHash=r,this.hash=i,this.anchorX=a,this.anchorY=n,this.directionX=o,this.directionY=c,this.maxScale=l,this.minScale=h,this.referenceBounds=u,this.bounds=d,this.recordStart=f,this.recordCount=p,this.priority=0,this._colliders=null,this.uniqueSymbol=null,this.selectedForRendering=!1}get xTile(){return this.anchorX}get yTile(){return this.anchorY}colliders(e){if(!this._colliders){const s=e.attributeView,r=Xa;let i=this.referenceBounds?.size??0;const a=e.layerView.labelingCollisionInfos[0].vvEvaluators[0];if(a!=null){const h=a(s.getVisualVariableData(this.displayId,0));i=isNaN(h)||h==null||h===1/0?i:h}const n=this.minScale?e.layerView.view.featuresTilingScheme.scaleToZoom(this.minScale):0,o=this.maxScale?e.layerView.view.featuresTilingScheme.scaleToZoom(this.maxScale):25,c=this.directionX*(r+i/2),l=this.directionY*(r+i/2);this._colliders=this.bounds.map(h=>({labelId:this.labelIdHash,xTile:this.anchorX,yTile:this.anchorY,dxPixels:h.x-h.halfWidth+c,dyPixels:h.y-h.halfHeight+l,hard:!0,partIndex:1,width:h.width+zr,height:h.height+zr,angle:0,xScreen:0,yScreen:0,dxScreen:0,dyScreen:0,enabled:!0,minLod:n,maxLod:o}))}return this._colliders}get id(){return this.displayId}serialize(e){e.push(this.displayId),e.push(this.labelClassId),e.push(this.labelIdHash),e.push(this.hash),e.push(this.recordStart),e.push(this.recordCount),e.writeF32(this.anchorX),e.writeF32(this.anchorY),e.writeF32(this.directionX),e.writeF32(this.directionY),e.writeF32(this.maxScale),e.writeF32(this.minScale),this.referenceBounds?(e.writeF32(this.referenceBounds.size),e.writeF32(this.referenceBounds.offsetX),e.writeF32(this.referenceBounds.offsetY)):(e.writeF32(0),e.writeF32(0),e.writeF32(0)),Ii(e,this.bounds)}static deserialize(e){const s=e.readInt32(),r=e.readInt32(),i=e.readInt32(),a=e.readInt32(),n=e.readInt32(),o=e.readInt32(),c=e.readF32(),l=e.readF32(),h=e.readF32(),u=e.readF32(),d=e.readF32(),f=e.readF32(),p=e.readF32(),m=e.readF32(),_=e.readF32(),g=Si(e,re)??[];return new da(s,r,i,a,c,l,h,u,d,f,{size:p,offsetX:m,offsetY:_},g,n,o)}};function Lr(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t}function fa(t,e){return Math.sqrt(t*t+e*e)}function Br(t){const e=fa(t[0],t[1]);t[0]/=e,t[1]/=e}function Ll(t,e){return fa(t[0]-e[0],t[1]-e[1])}function Bl(t,e){return t[e+1]}function pa(t){return t.length-1}function ql(t){let e=0;for(let s=0;s<pa(t);s++)e+=Nl(t,s);return e}function Nl(t,e,s=1){let[r,i]=Bl(t,e);return[r,i]=[Math.round(r),Math.round(i)],Math.sqrt(r*r+i*i)*s}let Gl=class ys{constructor(e,s,r,i,a){this._segments=e,this._index=s,this._distance=r,this._xStart=i,this._yStart=a,this._done=!1}static create(e){return new ys(e,0,0,e[0][0],e[0][1])}clone(){return new ys(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,s=(0*e+-1*-this.dx)/(1*this.length);let r=Math.acos(s);return e>0&&(r=2*Math.PI-r),r}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:s}=this;return Math.sqrt(e*e+s*s)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<pa(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,s){const r=this.backwardLength;if(e<=r)return this._distance=(r-e)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>e)return this._seekBackwards(e-i);i+=this.length}return this._distance=0,s?this:null}seek(e,s=!1){if(e<0)return this._seekBackwards(Math.abs(e),s);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let r=this.remainingLength;for(;this.next();){if(r+this.length>e)return this.seek(e-r,s);r+=this.length}return this._distance=1,s?this:null}};function Wt(t,e,s,r=!0){const i=ql(t),a=Gl.create(t),n=i/2;if(!r)return a.seek(n),void(a.x<T&&a.y<T&&a.x>=0&&a.y>=0&&s(a.clone(),0,n+0*e,i));const o=Math.max((i-e)/2,0),c=Math.floor(o/e),l=n-c*e;a.seek(l);for(let h=-c;h<=c;h++)a.x<T&&a.y<T&&a.x>=0&&a.y>=0&&s(a.clone(),h,n+h*e,i),a.seek(e)}function Vt(t,e){const s=e;for(let r=0;r<t.length;r++){let i=t[r];Ul(i,s);const a=[];a.push(i[0]);for(let n=1;n<i.length;n++){const[o,c]=i[n-1],[l,h]=i[n],u=l-o,d=h-c;a.push([u,d])}t[r]=a,i=a}return t}function Ul(t,e){if(e<=0)return;const s=t.length;if(s<3)return;const r=[];let i=0;r.push(0);for(let h=1;h<s;h++)i+=Ll(t[h],t[h-1]),r.push(i);e=Math.min(e,.2*i);const a=[];a.push(t[0][0]),a.push(t[0][1]);const n=t[s-1][0],o=t[s-1][1],c=Lr([0,0],t[0],t[1]);Br(c),t[0][0]+=e*c[0],t[0][1]+=e*c[1],Lr(c,t[s-1],t[s-2]),Br(c),t[s-1][0]+=e*c[0],t[s-1][1]+=e*c[1];for(let h=1;h<s;h++)r[h]+=e;r[s-1]+=e;const l=.5*e;for(let h=1;h<s-1;h++){let u=0,d=0,f=0;for(let p=h-1;p>=0&&!(r[p+1]<r[h]-l);p--){const m=l+r[p+1]-r[h],_=r[p+1]-r[p],g=r[h]-r[p]<l?1:m/_;if(Math.abs(g)<1e-6)break;const b=g*g,S=g*m-.5*b*_,x=g*_/e,I=t[p+1],k=t[p][0]-I[0],M=t[p][1]-I[1];u+=x/S*(I[0]*g*m+.5*b*(m*k-_*I[0])-b*g*_*k/3),d+=x/S*(I[1]*g*m+.5*b*(m*M-_*I[1])-b*g*_*M/3),f+=x}for(let p=h+1;p<s&&!(r[p-1]>r[h]+l);p++){const m=l-r[p-1]+r[h],_=r[p]-r[p-1],g=r[p]-r[h]<l?1:m/_;if(Math.abs(g)<1e-6)break;const b=g*g,S=g*m-.5*b*_,x=g*_/e,I=t[p-1],k=t[p][0]-I[0],M=t[p][1]-I[1];u+=x/S*(I[0]*g*m+.5*b*(m*k-_*I[0])-b*g*_*k/3),d+=x/S*(I[1]*g*m+.5*b*(m*M-_*I[1])-b*g*_*M/3),f+=x}a.push(u/f),a.push(d/f)}a.push(n),a.push(o);for(let h=0,u=0;h<s;h++)t[h][0]=a[u++],t[h][1]=a[u++]}const qr=96;let $l=class{constructor(t){const{offsetX:e,offsetY:s,postAngle:r,fontSize:i,haloSize:a,outlineSize:n,scaleFactor:o,transforms:c}=t;if(this.offsetX=e,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(i,qr),this.haloSize=a??0,this.outlineSize=n??0,this.transforms=c,c&&c.infos.length>1){const l=fi(i,r,!1,e,s,c,!1);this.fontSize=Math.min(l.size,qr);const h=l.size/i;this.haloSize*=h,this.outlineSize*=h,this.postAngle=l.rotation,this.offsetX=l.offsetX,this.offsetY=l.offsetY}o&&(this.fontSize*=o,this.offsetX*=o,this.offsetY*=o)}};const Pe=28,ae=[4,4],st=[16,4],Wl={topLeft:st,topRight:st,bottomLeft:st,bottomRight:st},bt=[4,2],V=[4,6],Nr={topLeft:bt,topRight:bt,bottomLeft:V,bottomRight:V},Gr={topLeft:bt,topRight:V,bottomLeft:bt,bottomRight:V},Vl={topLeft:V,topRight:V,bottomLeft:ae,bottomRight:ae},jl={topLeft:ae,topRight:ae,bottomLeft:V,bottomRight:V},Yl={topLeft:V,topRight:ae,bottomLeft:V,bottomRight:ae},Hl={topLeft:ae,topRight:V,bottomLeft:ae,bottomRight:V},Xl={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:ue,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||Pe]},clipAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>Ql(t||0)},referenceSymbol:{type:y.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const s=t.isLineLabel||!t.referenceBounds,r=zo(s?"center":e.horizontalAlignment),i=Do(s?"middle":e.verticalAlignment),{offsetX:a,offsetY:n,size:o}=s?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[w(a),-w(n),Math.round(w(o)),r+1<<2|i+1]}},visibility:{type:y.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>Ee([[zc,t],[Dc,!!e]])},offset:{type:y.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:s,topLeft:r,topRight:i}=t;return[r,i,e,s]}}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontAndReferenceSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>[Math.round(w(t)),Math.round(w(e??t))]},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>C(t)},haloColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>C(t)},outlineAndHaloSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(w(t)),Math.round(w(e))]}}};let ma=class extends pe{constructor(){super(...arguments),this.vertexSpec=Xl,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,e,s){super.ensurePacked(t,e,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new $l(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,e,s){const r=this._getShaping();if(!r)return;const i=e.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,e,r,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(t,i,s.x,s.y,r,0);if(e.geometryType==="esriGeometryPolygon"){const o=e.readCentroidForDisplay();if(!o)return;const[c,l]=o.coords;return this._writeGlyphs(t,i,c,l,r,0)}if(e.geometryType==="esriGeometryMultipoint")return void e.readGeometryForDisplay()?.forEachVertex((o,c)=>this._writeGlyphs(t,i,o,c,r,0));const a=e.readXForDisplay(),n=e.readYForDisplay();return this._writeGlyphs(t,i,a,n,r,0)}_writePlacedTextMarkers(t,e,s,r){const i=r??B.fromFeatureSetReaderCIM(e);if(!i)return;const a=-1,n=Rs.getPlacement(i,a,this.evaluatedMeshParams.placement,w(1),t.id);if(!n)return;const o=e.getDisplayId();let c=n.next();for(;c!=null;){const l=c.tx,h=-c.ty,u=-c.getAngle();this._writeGlyphs(t,o,l,h,s,u),c=n.next()}}_getShaping(t){const e=this._textMeshTransformProps,s=this.evaluatedMeshParams;if(!s.glyphs?.glyphs.length)return null;const r=w(e.fontSize),i=w(e.offsetX),a=w(e.offsetY),n=hr(w(s.lineWidth),Ya,ja),o=Ha*hr(s.lineHeightRatio,.25,4);return Vo(s.glyphs,{scale:r/Qa,angle:e.postAngle,xOffset:i,yOffset:a,horizontalAlignment:s.horizontalAlignment,verticalAlignment:t||s.verticalAlignment,maxLineWidth:n,lineHeight:o,decoration:s.decoration,borderLineSizePx:w(s.boxBorderLineSize),hasBackground:!!s.boxBackgroundColor,useCIMAngleBehavior:s.useCIMAngleBehavior})}_writeGlyphs(t,e,s,r,i,a,n,o,c=!0){const l=this.evaluatedMeshParams,h=this._textMeshTransformProps,u=w(h.fontSize),d=h.haloSize,f=h.outlineSize,p=w(h.offsetX),m=w(h.offsetY),[_,g]=fe(l.scaleInfo,this.getTileInfo());a!==0&&i.setRotation(a);const b=i.bounds,S=s+b.x+p,x=r+b.y-m,I=2*(l.minPixelBuffer?l.minPixelBuffer/u:1),k=Math.max(b.width,b.height)*I;i.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,i.glyphs[0].textureBinding),c&&t.recordBounds(S,x,k,k),this._writeTextBox(t,e,s,r,i.textBox,n,o),t.recordEnd());for(const M of i.glyphs){t.recordStart(this.instanceId,this.attributeLayout,M.textureBinding),c&&t.recordBounds(S,x,k,k);const{texcoords:F,offsets:H}=M;this._writeQuad(t,e,s,r,{texcoords:F,offsets:H,fontSize:u,haloSize:d,outlineSize:f,color:C(l.color),isBackground:!1,referenceBounds:n,minZoom:_,maxZoom:g,...o}),t.recordEnd()}a!==0&&i.setRotation(-a)}_writeTextBox(t,e,s,r,i,a,n){const o=this.evaluatedMeshParams,{fontSize:c,haloSize:l,outlineSize:h}=this._textMeshTransformProps,{boxBackgroundColor:u,boxBorderLineColor:d}=o,f={isBackground:!0,fontSize:c,haloSize:l,outlineSize:h,referenceBounds:a,...n};u&&(this._writeQuad(t,e,s,r,{texcoords:Wl,offsets:i.main,color:C(u),...f}),d||(this._writeQuad(t,e,s,r,{texcoords:Vl,offsets:i.top,color:C(u),...f}),this._writeQuad(t,e,s,r,{texcoords:jl,offsets:i.bot,color:C(u),...f}),this._writeQuad(t,e,s,r,{texcoords:Yl,offsets:i.left,color:C(u),...f}),this._writeQuad(t,e,s,r,{texcoords:Hl,offsets:i.right,color:C(u),...f}))),d&&(this._writeQuad(t,e,s,r,{texcoords:Nr,offsets:i.top,color:C(d),...f}),this._writeQuad(t,e,s,r,{texcoords:Nr,offsets:i.bot,color:C(d),...f}),this._writeQuad(t,e,s,r,{texcoords:Gr,offsets:i.left,color:C(d),...f}),this._writeQuad(t,e,s,r,{texcoords:Gr,offsets:i.right,color:C(d),...f}))}_writeQuad(t,e,s,r,i){const a=t.vertexCount();this._writeVertex(t,e,s,r,i),t.indexWrite(a+0),t.indexWrite(a+1),t.indexWrite(a+2),t.indexWrite(a+1),t.indexWrite(a+3),t.indexWrite(a+2)}};const Ql=t=>Math.round(t*(254/360)),rt=1,ge=0,Zl=128;function Kl(t,e,s){return ne(`${t}${e}${s}`)}function Jl(t,e,s,r,i){return ne(`${t}${e}${s}${r*2**(Pe-i)}`)}function eh(t,e,s){return ne(`${t}${e}${s}`)}function th(t,e,s,r,i){return ne(`${t}${i}${e}${s*2**(Pe-r)}`)}const sh=Na(t=>{let e=0;if(t===0)return 1/0;for(;!(t%2);)e++,t/=2;return e});class rh extends ma{constructor(){super(...arguments),this._zoomLevel=0}_write(e,s,r,i){if(this._zoomLevel=i||0,r!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(s.geometryType){case"esriGeometryPoint":{const a=s.readXForDisplay(),n=s.readYForDisplay();this._writePoint(e,a,n,0,s);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const a=s.readCentroidForDisplay();if(!a)return;const[n,o]=a.coords;this._writePoint(e,n,o,0,s);break}case"esriGeometryMultipoint":{let a=0;const n=B.fromFeatureSetReader(s);if(n?.nextPath())for(;n.nextPoint();)this._writePoint(e,n.x,n.y,a++,s);break}case"esriGeometryPolyline":this._writeLines(e,s)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:s}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,s==="middle"?0:s==="bottom"?-1:1]}_createLineLabelMetric(e,s,r,i,a,n){const[o,c]=this._getMetricDir(),l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0,u=this.evaluatedMeshParams.labelClassId;return new Dr(e,u,s,r,i,a,o,c,l,h,n)}_writePoint(e,s,r,i,a){if(s<0||s>T||r<0||r>T)return;const n=this._getShaping();if(!n)return;const o=a.getDisplayId(),c=this.evaluatedMeshParams.labelClassId,l=Kl(this.evaluatedMeshParams.layerId,a.getObjectId(),i),h=eh(a.getObjectId(),c,i),[u,d]=this._getMetricDir(),f=this.evaluatedMeshParams.scaleInfo?.maxScale??0,p=this.evaluatedMeshParams.scaleInfo?.minScale??0,m=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new Dr(o,c,l,h,s,r,u,d,f,p,m)),this._writeGlyphs(e,o,s,r,n,0,m,void 0,!1),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const s=e.getBoundsInfo();if(s)return s}return null}_writeLines(e,s){const{scaleInfo:r,verticalAlignment:i}=this.evaluatedMeshParams,a=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const o=(l,h,u,d)=>this._placeSubdivGlyphs(l,h,u,d),c=(n.bounds.width+a)/(1<<rt);this._current={out:e,id:s.getDisplayId(),objId:s.getObjectId(),shaping:n,zoomRange:fe(r,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=i==="bottom"?"above":i==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(s,o,c):this._writeCenterAlong(s,o,c)}_writeAboveAndBelowAlong(e,s,r){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:a}=this._current,n=a.bounds.halfHeight,o=e.readGeometryForDisplay();if(!o)return;const c=new D;pn(c,o,!1,!1,"esriGeometryPolyline",1);const l=Ur(new D,c,n),h=Ur(new D,c,-n),u=rs(h,"esriGeometryPolyline",!1,!1),d=rs(l,"esriGeometryPolyline",!1,!1),f=Vt(d.paths,a.bounds.width),p=Vt(u.paths,a.bounds.width);this._current.offsetDirection="above";for(let m=0;m<f.length;m++)this._current.pathIndex=m,Wt(f[m],r,s,!!i);this._current.offsetDirection="below";for(let m=0;m<p.length;m++)this._current.pathIndex=m,Wt(p[m],r,s,!!i)}_writeCenterAlong(e,s,r){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:a}=this._current,n=Vt(e.readLegacyGeometryForDisplay().paths,a.bounds.width);for(let o=0;o<n.length;o++)this._current.pathIndex=o,Wt(n[o],r,s,!!i)}_placeSubdivGlyphs(e,s,r,i){const{allowOverrun:a,labelPosition:n,repeatLabelDistance:o,layerId:c,labelClassId:l}=this.evaluatedMeshParams,{objId:h,shaping:u,pathIndex:d}=this._current,f=this._current.zoomRange[0],p=sh(s),m=this._current.shaping.bounds.width/(1<<rt),_=Math.sqrt(o||Zl)/(1<<rt),g=Math.min(r,i-r),b=u.isMultiline?Pe:Math.log2(g/(_+m/2)),S=s===0?b:Math.min(p,b),x=Math.max(f,this._zoomLevel+rt-S),I=this._zoomLevel-x,k=u.bounds.width/2*2**I,M=Jl(c,h,d,s,this._zoomLevel),F=th(h,d,s,this._zoomLevel,l);this._current.shaping.isMultiline?s===0&&this._placeStraight(e,x,M,F):a&&I<0?this._placeStraightAlong(e,f,M,F):n==="parallel"?this._placeStraightAlong(e,x,M,F):n==="curved"&&this._placeCurved(e,x,k,M,F)}_placeStraight(e,s,r,i){const{out:a,id:n,shaping:o,referenceBounds:c}=this._current,{x:l,y:h}=e;a.metricStart(this._createLineLabelMetric(n,r,i,l,h)),a.metricBoxWrite(o.boundsT);const u=e.angle*(180/Math.PI)%360,d=(e.angle*(180/Math.PI)+180)%360;if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const f={clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:s};this._writeGlyphs(a,n,l,h,o,0,c,f,!1)}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const f={clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:s};this._writeGlyphs(a,n,l,h,o,0,c,f,!1)}a.metricEnd()}_placeCurved(e,s,r,i,a){const{out:n,id:o}=this._current;n.metricStart(this._createLineLabelMetric(o,i,a,e.x,e.y));const c=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(c,s,1,l),this._placeBack(e,c,s,r,1,l),this._placeForward(e,c,s,r,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(c,s,0,h),this._placeBack(e,c,s,r,0,h),this._placeForward(e,c,s,r,0,h)),n.metricEnd()}_placeStraightAlong(e,s,r,i){const{out:a,id:n,shaping:o,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:u}=this.evaluatedMeshParams,d=e.clone(),f=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360,m=o.glyphs.length>0&&!(!h&&!u);if(a.metricStart(this._createLineLabelMetric(n,r,i,e.x,e.y)),m){const _=Math.max(s,c[0],0),g=Math.min(Pe,c[1]),b=Ge(j(),-e.angle),S={minZoom:_,maxZoom:g,clipAngle:f,mapAligned:!0,isLineLabel:!0},x=w(this.evaluatedMeshParams.offsetX),I=w(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const k=Be(x,-1*I),[M,F]=o.shapeBackground(Me(j(),b,k));a.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,F,l,S),a.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const k=Be(x,I),[M,F]=o.shapeBackground(Me(j(),b,k));S.clipAngle=p,a.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),this._writeTextBox(a,n,e.x,e.y,F,l,S),a.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(d,s,1,f,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(d,s,0,p,!0),a.metricEnd()}_placeBack(e,s,r,i,a,n){const o=e.clone();let c=e.backwardLength+ge;for(;o.prev()&&!(c>=i);)this._placeOnSegment(o,s,c,r,-1,a,n),c+=o.length+ge}_placeForward(e,s,r,i,a,n){const o=e.clone();let c=e.remainingLength+ge;for(;o.next()&&!(c>=i);)this._placeOnSegment(o,s,c,r,1,a,n),c+=o.length+ge}_placeFirst(e,s,r,i,a=!1){const{out:n,id:o,shaping:c,zoomRange:l,referenceBounds:h}=this._current,u=c.glyphs,d=w(this.evaluatedMeshParams.offsetX),f=w(this.evaluatedMeshParams.offsetY),p=Be(d,f),m=Ge(j(),-e.angle);W(p,p,m);for(const _ of u){const g=_.x>c.bounds.x?r:1-r,b=g*e.remainingLength+(1-g)*e.backwardLength,S=Math.abs(_.x+_.width/2-c.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(S/(b+ge))),I=Math.max(s,a?0:x);if(_.maxZoom=Math.min(l[1],Pe),_.angle=e.angle+(1-r)*Math.PI,_.minZoom=Math.max(l[0],I),this._writeLineGlyph(n,o,e.x,e.y,_,i,h,!0),(r||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const k=new re(_.bounds.x+p[0],_.bounds.y+p[1],_.bounds.width,_.bounds.height);n.metricBoxWrite(k)}}}_placeOnSegment(e,s,r,i,a,n,o){const{out:c,id:l,shaping:h,referenceBounds:u}=this._current,d=h.glyphs,f=e.dx/e.length,p=e.dy/e.length,m={x:e.x+r*-a*f,y:e.y+r*-a*p},_=w(this.evaluatedMeshParams.offsetX),g=w(this.evaluatedMeshParams.offsetY),b=Be(_,g),S=Ge(j(),-e.angle);W(b,b,S);for(const x of d){const I=x.x>h.bounds.x?n:1-n;if(!(I&&a===1||!I&&a===-1))continue;const k=Math.abs(x.x+x.width/2-h.bounds.x),M=Math.max(0,this._zoomLevel+Math.log2(k/r)-.1),F=Math.max(i,this._zoomLevel+Math.log2(k/(r+e.length+ge)));if(M!==0&&(x.angle=e.angle+(1-n)*Math.PI,x.minZoom=F,x.maxZoom=M,this._writeLineGlyph(c,l,m.x,m.y,x,o,u,!0),(n||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const H=new re(x.bounds.x+b[0],x.bounds.y+b[1],x.bounds.width,x.bounds.height);c.metricBoxWrite(H)}}}_writeLineGlyph(e,s,r,i,a,n,o,c){if(r<0||r>T||i<0||i>T)return;e.recordStart(this.instanceId,this.attributeLayout,a.textureBinding);const{texcoords:l,offsets:h}=a,{fontSize:u,haloSize:d,outlineSize:f}=this._textMeshTransformProps;this._writeQuad(e,s,r,i,{texcoords:l,offsets:h,fontSize:u,haloSize:d,outlineSize:f,color:C(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:o,minZoom:Math.max(this._current.zoomRange[0],a.minZoom),maxZoom:Math.min(this._current.zoomRange[1],a.maxZoom),clipAngle:n,mapAligned:c,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*ue)/ue}_isVisible(e,s){let r=Math.max(this._current.zoomRange[0],e),i=Math.min(this._current.zoomRange[1],s);r=this._packedZoom(r),i=this._packedZoom(i);const a=this._packedZoom(this._zoomLevel);return r<=a&&a<=i}}function Ur(t,e,s){const{coords:r,lengths:i}=e,a=ye(),n=ye(),o=ye(),c=ye(),l=ye(),h=ye(),u=2;let d=0;for(let f=0;f<i.length;f++){const p=i[f];for(let m=0;m<p;m++){const _=u*(m+d-1),g=u*(m+d),b=u*(m+d+1);m>0?q(a,r[_],r[_+1]):q(a,0,0),q(n,r[g],r[g+1]),m<p-1?q(o,r[b],r[b+1]):q(o,0,0),m===0?q(c,0,0):(cr(c,n,a),Bt(c,c),q(c,c[1],-c[0])),m===p-1?q(l,0,0):(cr(l,o,n),Bt(l,l),q(l,l[1],-l[0])),on(h,c,l),Bt(h,h);const S=h[0]*l[0]+h[1]*l[1];S!==0&&lr(h,h,S),lr(h,h,s),t.coords.push(n[0]+h[0],n[1]+h[1])}t.lengths.push(p),d+=p}return t}const jt={isAlongLine:0,isAbsoluteSize:1,isDiscrete:2},ih={createComputedParams:t=>t,optionalAttributes:K.optionalAttributes,attributes:{...K.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:s})=>Ee([[jt.isAlongLine,t.toLowerCase()==="alongline"],[jt.isAbsoluteSize,e===mt.Absolute],[jt.isDiscrete,s.toLowerCase()==="discrete"]])},tlbr:{type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+A+pt,a=e.y+A;return[i,a,i+s-2*pt,a+r]}},accumulatedDistance:{type:y.HALF_FLOAT,count:1,packTessellation:({distance:t,pathLength:e,distanceOffset:s})=>(s+t)/e},gradientSize:{type:y.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===mt.Relative?t/100:w(t)},totalLength:{type:y.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};let ah=class extends Et{get _preventEffectClipping(){return!0}constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=ih,this._tessellationOptions.textured=!0}_write(t,e,s){const r=s??B.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,i?.textureBinding)}};const nh={createComputedParams:t=>t,optionalAttributes:K.optionalAttributes,attributes:{...K.attributes,bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:s})=>Ee([[Qi,t],[Oc,e],[Rc,s]])},tlbr:{type:y.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:s,height:r}=t,i=e.x+A,a=e.y+A;return[i,a,i+s,a+r]}},accumulatedDistance:{type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:y.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>w(t)},capType:{type:y.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case"Butt":case"butt":default:return 0;case"Square":case"square":return 1;case"Round":case"round":return 2}}}}};let oh=class extends Et{constructor(t,e,s,r){super(t,e,s,r),this.vertexSpec=nh,this._tessellationOptions.textured=!0}_write(t,e,s){const r=s??B.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,i?.textureBinding)}},ch=class gs{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const s=new gs(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:r,width:i,height:a,angle:n,alignment:o,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:u}=e;return s.rawWidth=w(i),s.rawHeight=w(a),s.angle=n,s.alignment=o,s.outlineSize=w(c),s.referenceSize=w(l),s.overrideOutlineColor=u,s.offsetX=w(e.offsetX),s.offsetY=w(e.offsetY),r!=="simple"||h.sdf||(s.rawWidth=h.width,s.rawHeight=h.height),s._computeSize(e,!1),s}static fromComplexMeshParams(e){const s=new gs(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:r,transforms:i,size:a,scaleX:n,anchorX:o,anchorY:c,angle:l,colorLocked:h,frameHeight:u,widthRatio:d,offsetX:f,offsetY:p,outlineSize:m,referenceSize:_,scaleFactor:g,sizeRatio:b,isAbsoluteAnchorPoint:S,rotateClockwise:x,scaleSymbolsProportionally:I,sprite:k}=e;if(i&&i.infos.length>0){const H=fi(a,l,x,f,p,i);a=H.size,l=H.rotation,f=H.offsetX,p=H.offsetY,x=!1}g&&(a*=g,f*=g,p*=g);const M=n*(k.width/k.height);s.alignment=r,s.rawHeight=w(a),s.rawWidth=s.rawHeight*M,s.referenceSize=w(_),s.sizeRatio=b,s.sdfDecodeCoeff=(k.sdfDecodeCoeff??1)*b,s.angle=l,s.rotateClockwise=x,s.anchorX=o,s.anchorY=c,s.offsetX=w(f),s.offsetY=w(p),S&&a&&(k.sdf?s.anchorX=o/(a*d):s.anchorX=o/(a*M),s.anchorY=c/a);const F=I&&u?a/u:1;return s.outlineSize=m===0||isNaN(m)?0:w(m)*F,s.scaleSymbolsProportionally=I,s.colorLocked=h,s._computeSize(e,!0),s}constructor(e,s,r,i,a,n,o){this.sprite=e,this.color=s,this.outlineColor=r,this.minPixelBuffer=i,this.placement=a,this.scaleInfo=n,this.effects=o,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,s){const{sprite:r,hasSizeVV:i}=e,a=!!r.sdf,n=r.sdfPaddingRatio??.5,{rawWidth:o,rawHeight:c,sizeRatio:l,outlineSize:h}=this,u=r.rect;let d=o*l,f=c*l,p=0,m=0;if(a){const x=1/(1-n);if(d*=x,f*=x,i)this.computedWidth=d,this.computedHeight=f;else{const I=s&&o>c?d:o,k=c,M=h+2;this.computedWidth=Math.min(I+M,d),this.computedHeight=Math.min(k+M,f);const F=Math.max(r.width,r.height)/Math.max(d,f);p=(this.computedWidth-d)*F,m=(this.computedHeight-f)*F}}else this.computedWidth=d*(u.width/r.width),this.computedHeight=f*(u.height/r.height),p=2*A,m=2*A;const _=u.x+A-p/2,g=u.y+A-m/2,b=_+r.width+p,S=g+r.height+m;this.texXmin=$r(_),this.texYmin=$r(g),this.texXmax=Wr(b),this.texYmax=Wr(S),this.computedWidth*=(this.texXmax-this.texXmin)/(b-_),this.computedHeight*=(this.texYmax-this.texYmin)/(S-g),this.anchorX*=d/this.computedWidth,this.anchorY*=f/this.computedHeight}};function $r(t,e=1e-7){const s=Math.ceil(t);return s-t<e?s:Math.floor(t)}function Wr(t,e=1e-7){const s=Math.floor(t);return t-s<e?s:Math.ceil(t)}const lh=3.14159265359/180,hh=128/Math.PI;function uh(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function dh(t){return uh(t*hh,256)}function fh(t,e,s,r,i=!1){const a=j(),n=i?1:-1;return dn(a),(e||s)&&Me(a,a,[e,-s]),r&&ts(a,a,n*lh*-r),a}const ph={createComputedParams:t=>ch.from(t),optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:ue,pack:({scaleInfo:t},{tileInfo:e})=>fe(t,e)}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let a=0;return t.sdf&&(a|=$(X.bitset.isSDF)),e===1&&(a|=$(X.bitset.isMapAligned)),s&&(a|=$(X.bitset.scaleSymbolsProportionally)),r&&(a|=$(X.bitset.overrideOutlineColor)),i&&(a|=$(X.bitset.colorLocked)),a}},offset:{type:y.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:s,anchorX:r,anchorY:i,offsetX:a,offsetY:n,rotateClockwise:o})=>{const c=fh(0,a,n,-t,o),l=-(.5+r)*e,h=-(.5-i)*s,u=[l,h],d=[l+e,h],f=[l,h+s],p=[l+e,h+s];return W(u,u,c),W(d,d,c),W(f,f,c),W(p,p,c),[u,d,f,p]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:s,texYmin:r})=>[[e,r],[t,r],[e,s],[t,s]]}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>C(t)},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>C(t)},sizing:{type:y.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:s,referenceSize:r})=>{const i=Math.max(t,e);return[Gt(i,128),Gt(s,128),Gt(r,128),0]}},placementAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>dh(t)},sdfDecodeCoeff:{type:y.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};let mh=class extends pe{constructor(){super(...arguments),this.vertexSpec=ph}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,e,s){const r=this.evaluatedMeshParams.sprite?.textureBinding,i=e.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,r);const a=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(this.evaluatedMeshParams.computedWidth,a),o=Math.max(this.evaluatedMeshParams.computedHeight,a),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,h=this.evaluatedMeshParams.offsetX+c,u=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null){let d=null;if(s!=null){const f=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(d=tn(s,2*f,!1),d===null)return}this._writePlacedMarkers(t,e,d,n,o)}else if(s?.nextPath()){s.nextPoint();const d=s.x,f=s.y;t.recordBounds(d+h,f+u,n,o),this._writeQuad(t,i,d,f)}else if(e.geometryType==="esriGeometryPolygon"){const d=e.readCentroidForDisplay();if(!d)return;const[f,p]=d.coords;t.recordBounds(f+h,p+u,n,o),this._writeQuad(t,i,f,p)}else if(e.geometryType==="esriGeometryPoint"){const d=e.readXForDisplay(),f=e.readYForDisplay();t.recordBounds(d+h,f+u,n,o),this._writeQuad(t,i,d,f)}else e.readGeometryForDisplay()?.forEachVertex((d,f)=>{t.recordBounds(d+h,f+u,n,o),Math.abs(d)>we||Math.abs(f)>we||this._writeQuad(t,i,d,f)});t.recordEnd()}_writePlacedMarkers(t,e,s,r,i){const a=s??B.fromFeatureSetReaderCIM(e);if(!a)return;const n=-1,o=Rs.getPlacement(a,n,this.evaluatedMeshParams.placement,w(1),t.id);if(!o)return;const c=e.getDisplayId();let l=o.next();const h=this.evaluatedMeshParams.offsetX,u=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const d=l.tx,f=-l.ty;if(Math.abs(d)>we||Math.abs(f)>we){l=o.next();continue}const p=-l.getAngle();t.recordBounds(d+h,f+u,r,i),this._writeQuad(t,c,d,f,p),l=o.next()}}_writeQuad(t,e,s,r,i){const a=t.vertexCount(),n=i==null?null:{placementAngle:i};this._writeVertex(t,e,s,r,n),t.indexWrite(a+0),t.indexWrite(a+1),t.indexWrite(a+2),t.indexWrite(a+1),t.indexWrite(a+3),t.indexWrite(a+2)}},Oe=class{destroy(){}},_a=class extends Oe{constructor(t){super(),this._value=t}resize(t){}read(t,e){return this._value}readWithDefault(t,e,s){return this._value}hasArcadeDependency(t){return!1}};const _h=()=>G.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function it(t,e,s,r){const{defaultValue:i,valueExpressionInfo:a,value:n}=e;if(a){if(a.type==="dictionary-template")return{...e,computed:t.createDictionaryTemplateField(a,s),defaultValue:i};const{expression:o}=a,c=await t.createComputedField({expression:o},r);return c?{...e,computed:c,defaultValue:i}:null}return{...e,computed:new _a(n),defaultValue:i}}async function Vr(t,e,s){const{valueExpressionInfo:r}=e,i=r.type==="dictionary-template"?t.createDictionaryTemplateField(r,s):await t.createComputedField({expression:r.expression});return i?{...e,computed:i}:null}function ya(t){return typeof t=="object"&&t!=null&&(!(!("valueExpressionInfo"in t)||!t.valueExpressionInfo)||"type"in t&&t.type==="Process"&&"op"in t&&t.op==="Random")}function wt(t){if(Array.isArray(t)){for(const e of t)if(wt(e))return!0}if(typeof t=="object"){if(ya(t))return!0;for(const e in t)if(wt(t[e]))return!0}return!1}let yh=class ga{static async create(e,s,r,i){const a={},n=new Map,o=new Map,c=new Map,l=new Map,h=new Map,u=new Map;for(const d in r){const f=r[d];if(f!=null&&typeof f=="object")if(Array.isArray(f)){if(typeof f[0]=="object")throw new Error(`InternalError: Cannot handle ${d}. Nested array params are not supported`);a[d]=f}else{if("valueExpressionInfo"in f){if(f.value){a[d]=f.value;continue}const p=await Vr(e,f,i);if(!p){a[d]=f.defaultValue;continue}n.set(d,p),a[d]=null;continue}switch(f.type){case"cim-effect-infos":if(f.effectInfos.some(p=>p.overrides.length)){o.set(d,{effects:await Promise.all(f.effectInfos.map(async p=>{const m=p.overrides.map(_=>it(e,_,i,!1));return{effect:p.effect,compiledOverrides:(await Promise.all(m)).filter(Le)}}))});break}a[d]=f.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":f.overrides.length&&c.set(d,{placementInfo:f,compiledOverrides:(await Promise.all(f.overrides.map(p=>it(e,p,i,!1)))).filter(Le)}),a[d]=f.placement;break;case"text-rasterization-param":{if(f.overrides.length){const m=f.overrides.map(_=>it(e,_,i,f.useLegacyLabelEvaluationRules??!1));l.set(d,{compiledOverrides:(await Promise.all(m)).filter(Le),rasterizationParam:f,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:f.resource};a[d]=await s.fetchResourceImmediate(p)??null;break}case"sprite-rasterization-param":{if(f.overrides.length){const m=f.overrides.map(_=>it(e,_,i,!1));l.set(d,{compiledOverrides:(await Promise.all(m)).filter(Le),rasterizationParam:f,objectIdToResourceId:new Map});continue}if(f.resource.type==="animated"){l.set(d,{compiledOverrides:[],rasterizationParam:f,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:f.resource};a[d]=await s.fetchResourceImmediate(p)??null;break}case"cim-marker-transform-param":{const{params:p}=f;if(wt(p)){const m={compiledMarkerInfos:[]};await Promise.all(p.map(async _=>{const g={props:{}};for(const b in _)if(ya(_[b])){const S=await Vr(e,_[b],i);g.compiledExpressionMap||(g.compiledExpressionMap=new Map);const x=g.compiledExpressionMap;S&&x.set(b,S)}else g.props[b]=_[b];m.compiledMarkerInfos.push(g)})),h.set(d,m)}else a[d]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{const{params:p}=f,m=Ic(p);if(wt(m)){const _=await Promise.all(m.map(g=>ds(g,e)));u.set(d,{params:_,propertyIdToResourceId:new Map,key:d})}else{const _=wc(m),g=await s.fetchResourceImmediate({type:"animation-info",resource:_});g!=null&&g.type==="sprite"&&(a[d]={dataRow:g.rect.y,dataColumn:g.rect.x})}break}default:a[d]=f}}else a[d]=f}return new ga(r,a,n,o,c,l,h,u)}constructor(e,s,r,i,a,n,o,c){this.inputMeshParams=e,this._resolvedMeshParams=s,this._dynamicProperties=r,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=a,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=o,this._dynamicAsyncAnimations=c,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())ks(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,s,r){for(const i of this._dynamicAsyncProperties.values()){const a=qa(i.rasterizationParam.resource);i.rasterizationParam.resource.type==="animated"&&i.rasterizationParam.resource.randomizeStartTime&&(a.primitiveName="__RESERVED__PRIMITIVE__NAME__",a.startGroup=Vi(s.getObjectId()||0));for(const{primitiveName:o,propertyName:c,computed:l,defaultValue:h,valueExpressionInfo:u}of i.compiledOverrides)try{const d=i.rasterizationParam.resource.type==="animated"?a.primitiveName:o;ee(a,d,c,l,s,r,h)}catch(d){_h().errorOnce(new P("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:d,valueExpressionInfo:u}))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:a});i.objectIdToResourceId.set(s.getObjectId(),n)}for(const i of this._dynamicAsyncAnimations.values()){const a=i.params.map(c=>z(c,s,r)).map(Qe).map(c=>c.simplify()),n=ji(a),o=e.enqueueRequest({type:"animation-info",resource:n});i.propertyIdToResourceId.set(s.getObjectId()+"."+i.key,o)}}evaluateMeshParams(e,s,r){for(const[i,a]of this._dynamicProperties.entries())this._resolvedMeshParams[i]=a.computed.readWithDefault(s,r,a.defaultValue);for(const[i,a]of this._dynamicPlacementProperties.entries())for(const{computed:n,defaultValue:o,propertyName:c}of a.compiledOverrides){const l=n.readWithDefault(s,r,o);a.placementInfo.placement[c]=l,this._resolvedMeshParams[i]=a.placementInfo.placement}for(const[i,a]of this._dynamicEffectProperties.entries())for(const n of a.effects){for(const{computed:o,defaultValue:c,propertyName:l}of n.compiledOverrides){const h=o.readWithDefault(s,r,c);n.effect[l]=h}this._resolvedMeshParams[i]=a.effects.map(o=>o.effect)}for(const[i,a]of this._dynamicTransformProperties.entries()){const n={type:"cim-marker-transform-info",infos:[]};for(const o of a.compiledMarkerInfos){const c={...o.props};if(o.compiledExpressionMap)for(const[l,h]of o.compiledExpressionMap){const u=h.computed.readWithDefault(s,r,h.defaultValue);c[l]=typeof u=="number"||typeof u=="boolean"?u:h.defaultValue}n.infos.push(c)}this._resolvedMeshParams[i]=n}for(const[i,a]of this._dynamicAsyncProperties.entries()){const n=a.objectIdToResourceId.get(s.getObjectId());if(n==null)continue;const o=e.getResource(n);this._resolvedMeshParams[i]=o}for(const[i,a]of this._dynamicAsyncAnimations.entries()){const n=a.propertyIdToResourceId.get(s.getObjectId()+"."+i);if(n==null)continue;const o=e.getResource(n);this._resolvedMeshParams[i]={dataRow:o.rect.y,dataColumn:o.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const s of e.effects)for(const r of s.compiledOverrides)yield r.computed;for(const e of this._dynamicPlacementProperties.values())for(const s of e.compiledOverrides)yield s.computed;for(const e of this._dynamicAsyncProperties.values())for(const s of e.compiledOverrides)yield s.computed;for(const e of this._dynamicTransformProperties.values())for(const s of e.compiledMarkerInfos)if(s.compiledExpressionMap!=null)for(const r of s.compiledExpressionMap.values())yield r.computed;for(const e of this._dynamicAsyncAnimations.values())for(const s of e.params)yield*L(s)}};const gh={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:y.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=w(t),s=-e/2,r=-e/2;return[[s,r],[s+e,r],[s,r+e],[s+e,r+e]]}}},texCoords:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:y.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:y.UNSIGNED_BYTE,count:1,pack:({size:t})=>w(t)},zoomRange:{type:y.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>fe(t,e)}}};let xh=class extends pe{constructor(){super(...arguments),this.vertexSpec=gh}_write(t,e){const s=e.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,i=Math.max(w(this.evaluatedMeshParams.size),r);let a,n;if(e.geometryType==="esriGeometryPoint")a=e.readXForDisplay(),n=e.readYForDisplay();else{const c=e.readCentroidForDisplay();if(!c)return;a=c?.coords[0],n=c?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(a,n,i,i);const o=t.vertexCount();this._writeVertex(t,s,a,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2),t.recordEnd()}},bh=class{async createMeshWriter(t,e,s,r,i){const a=this._getMeshWriter(r.techniqueType),n=await yh.create(t,e,r.inputParams,i),o=new a(r.id,n,r.optionalAttributes,s);return await o.loadDependencies(),o}_getMeshWriter(t){switch(t){case 13:return js;case 11:return _l;case 9:return yl;case 26:return ca;case 14:return Cl;case 24:return Xs;case 27:return Rl;case 10:return Il;case 21:return mh;case 28:return xh;case 30:return ma;case 19:return Et;case 31:return oh;case 15:return ah;case 17:return Dl;case 18:return rh;case 2:return Gc;case 3:return Uc;case 0:return hl;case 1:return dl;default:throw new Error("Internal Error: Mesh writer not in the registry")}}},wh=class{constructor(t,e,s,r,i){this.storage=t,this.proxy=e,this.viewParams=s,this.registry=r,this.fieldsMap=i}async createMeshWriters(t){const e=t.map(s=>this.registry.createMeshWriter(this.storage,this.proxy,this.viewParams,s,this.fieldsMap));return Promise.all(e)}},Ih=class{constructor(t){this._outstandingMessages=[],this._queue=new Ms({concurrency:t.concurrency,process:e=>t.process(e)})}async push(t){if(t.end)return await Promise.all(this._outstandingMessages),await this._queue.push(t),void(this._outstandingMessages=[]);const e=this._queue.push(t);return this._outstandingMessages.push(e),e}},Zs=class xs{static async create(e,s){if(s.statisticType==="count"){const i=new _a(1);return new xs(s.name,s.alias,s.type,s.statisticType,i)}const r=await e.createComputedField({expression:s.onStatisticExpression?.expression,field:s.onStatisticField});return new xs(s.name,s.alias,s.type,s.statisticType,r)}constructor(e,s,r,i,a){this.name=e,this.alias=s,this.type=r,this.statisticType=i,this.computed=a}},Ot=class{constructor(t){this.subscription=t,this.handledChunks=new Set}destroy(){}},xa=class{constructor(t,e,s){this._source=t,this._attributeStore=e,this._sqlOptions=s,this._sendStates=new Map}destroy(){}get enablePixelBuffering(){return!0}get isAggregate(){return!1}get usedMemory(){return 0}onSubscribe(t){const e=this.createState(t);this._sendStates.set(t.key.id,e),this.updateChunks()}onUnsubscribe(t){this._sendStates.get(t.key.id)?.destroy(),this._sendStates.delete(t.key.id)}get hasSubscribers(){return this._sendStates.size>0}requiresInvalidation(){return!1}invalidate(){const t=Array.from(this._sendStates.values());this._sendStates.clear();for(const e of t)e.destroy(),this.onSubscribe(e.subscription)}invalidateAttributeData(t){}hasArcadeDependency(t){return!1}getFeatureObjectIdsForAggregate(t){throw new Error("InternalError: AggregateId lookup not supported")}getDisplayIds(t){return this.displayMap(t,e=>e,e=>e)}getDisplayAndObjectIds(t){return this.displayMap(t,e=>e,(e,s,r)=>[e,r])}afterUpdateChunks(){}},Ks=class extends xa{constructor(t,e,s,r,i){super(t,e,i),this.spatialReference=s,this.aggregateFields=r,this._arcadeDependencies=new Set,this.events=new ii,this.featureAdapter=Fn;for(const a of r)ks(this._arcadeDependencies,a.computed)}get aggregateQueryEngine(){return this._aggregateQueryEngine||(this._aggregateQueryEngine=new pi({featureStore:this,fieldsIndex:this._metadata.fieldsIndex,geometryType:this._metadata.geometryType,featureIdInfo:this._metadata.featureIdInfo,spatialReference:this.spatialReference})),this._aggregateQueryEngine}get isAggregate(){return!0}removeChunks(t){}hasArcadeDependency(t){return this._arcadeDependencies.has(t)}forEach(t){return this.forEachAggregateWorldSpace(t)}forEachInBounds(t,e){}forEachBounds(t,e){const s=Tn();for(const r of t){const i=mn(s,r.geometry,!1,!1);i&&e(i)}}},Ce=class{constructor(t,e,s,r,i){this.subscription=t,this.reader=e,this.clear=s,this.end=r,this.debugInfo=i,this.type="append"}get id(){return this.subscription.tile.id}createMessage(t,e,s){return{type:"append",clear:this.clear,id:this.id,append:t,end:this.end,debugInfo:this.debugInfo,subscriptionVesrion:this.subscription.version,version:e,attributeEpoch:s}}},bs=class{constructor(t,e,s,r,i){this.subscription=t,this.reader=e,this.remove=s,this.end=r,this.debugInfo=i,this.type="update"}get id(){return this.subscription.tile.id}createMessage(t,e,s){return{type:"update",id:this.id,modify:t,debugInfo:this.debugInfo,remove:this.remove,version:e,subscriptionVesrion:this.subscription.version,end:this.end,attributeEpoch:s}}};const O=8388607,Sh=8388608,Se=t=>t&O;function vh(t,e){return((e?Sh:0)|t)>>>0}let kh=class extends Oe{constructor(t){super(),this._field=t}resize(t){throw new Error("Method not implemented.")}read(t,e){return t.readAttribute(this._field)}readWithDefault(t,e){return t.readAttribute(this._field)}hasArcadeDependency(t){return!1}};function Mh(t,e){const s=43758.5453*Math.sin(12.9898*t+78.233*e);return s-Math.floor(s)}let Th=class ba extends Oe{static async create(e,s){const r=await wn(e,s.spatialReference),i=ne(e);return new ba(r,i)}constructor(e,s){super(),this._compiled=e,this._cacheKey=s}resize(e){}read(e,s){return this.hasArcadeDependency("scale")||s.$view.timeZone!=="system"?fr(this._compiled,e,s):this._readCached(e,s)}readWithDefault(e,s,r){return this.hasArcadeDependency("scale")||s.$view.timeZone!=="system"?pr(this._compiled,e,s,r):this._readWithDefaultCached(e,s,r)}hasArcadeDependency(e){return this._compiled?.references(e)??!1}_getCacheKey(e){if(!this._compiled?.references("timeProperties"))return this._cacheKey;const{currentStart:s,currentEnd:r}=e.$view.timeProperties;return this._cacheKey+Mh(s??1,r??1)}_readCached(e,s){if(e.setCache(this._getCacheKey(s)),e.hasCachedValue())return e.getCachedValue();const r=fr(this._compiled,e,s);return e.setCachedValue(r),r}_readWithDefaultCached(e,s,r){if(e.setCache(this._getCacheKey(s)),e.hasCachedValue())return e.getCachedValue();const i=pr(this._compiled,e,s,r);return e.setCachedValue(i),i}},Fh=class wa extends Oe{static async create(e,s){const r=Nn(e);return new wa(i=>r.replaceAll(/{[^}]*}/g,a=>{const n=a.slice(1,-1),o=i.metadata.fieldsIndex.get(n);if(o==null)return a;const c=i.readAttribute(n);return c==null?"":Ka(c,o)}))}constructor(e){super(),this._evaluator=e}resize(e){}read(e,s){return this._evaluator(e)}readWithDefault(e,s,r){const i=this._evaluator(e);return zn(i)?r:i}hasArcadeDependency(e){return!1}},Ph=class extends Oe{constructor(t,e){super(),this._template=t,this._parts=bn(t.template,e)}resize(t){}read(t,e){return dr(t,this._parts,this._template.textCase)}readWithDefault(t,e,s){return dr(t,this._parts,this._template.textCase)}hasArcadeDependency(t){return!1}},Ch=class extends Oe{constructor(t,e){super(),this._field=t,this._normalizationInfo=e}resize(t){throw new Error("Method not implemented.")}read(t,e){return this._readNormalized(t)}readWithDefault(t,e){return this._readNormalized(t)}hasArcadeDependency(t){return!1}_readNormalized(t){const e=t.readAttribute(this._field);if(e==null)return null;const{normalizationField:s,normalizationTotal:r,normalizationType:i}=this._normalizationInfo,a=t.readAttribute(s);switch(i??"esriNormalizeByField"){case"esriNormalizeByField":return a?a?e/a:void 0:null;case"esriNormalizeByLog":return Math.log(e)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return r?e/r*100:null}}};const Yt=()=>G.getLogger("esri.views.2d.layers.FeatureLayerView2D"),Ah={getAttribute:(t,e)=>t.readAttribute(e)};async function Ia(t,e){try{const s=await Gn(t,e);return s.isStandardized||Yt().error(new P("sql-parse-error","expression is not standardized",{where:t})),(r,i)=>{const a=r.readArcadeFeature();try{return s.testFeatureCompiled(a,Ah,i.currentUser)}catch(n){return Yt().warn(new P("sql-runtime-error","Encountered an error when evaluating where clause",{where:t,error:n})),!0}}}catch(s){return Yt().warn(new P("sql-runtime-error","Encountered an error when evaluating where clause",{where:t,error:s})),r=>!0}}const jr=()=>G.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage"),xe=4294967295;function at(t,e,s){if(!(t.length>e))for(;t.length<=e;)t.push(s)}let Rt=class{constructor(t){this._numerics=[],this._strings=[],this._allocatedSize=256,this._bitsets=[],this._instanceIds=[],this._bounds=[],this._dirtyBitset=this.getBitset(this.createBitset()),this.compilationOptions=t}createBitset(){const t=this._bitsets.length;return this._bitsets.push(En.create(this._allocatedSize,O)),t+1}createDictionaryTemplateField(t,e){return new Ph(t,e)}async createComputedField(t,e=!1){if(t.expression)try{if(!this.compilationOptions)throw new Error("InternalError: Compilation options not defined");return e?await Fh.create(t.expression,this.compilationOptions):await Th.create(t.expression,this.compilationOptions)}catch(r){const i=new P("featurelayer","Failed to compile arcade expression",{error:r,expression:t.expression});return jr().error(i),null}if(t.normalizationType||t.normalizationField)return new Ch(t.field,t);if(t.field)return new kh(t.field);const s=new P("featurelayer","Unable to create computed field. No expression or field found",{info:t});return jr().error(s),null}async createWhereClause(t){return t?Ia(t,this.compilationOptions.fields):null}getBitset(t){return this._bitsets[t-1]}getComputedNumeric(t,e){return this.getComputedNumericAtIndex(t&O,0)}setComputedNumeric(t,e,s){return this.setComputedNumericAtIndex(t&O,s,0)}getComputedString(t,e){return this.getComputedStringAtIndex(t&O,0)}setComputedString(t,e,s){return this.setComputedStringAtIndex(t&O,0,s)}getComputedNumericAtIndex(t,e){const s=t&O;return this._ensureNumeric(e,s),this._numerics[e][s]}setComputedNumericAtIndex(t,e,s){const r=t&O;this._ensureNumeric(e,r),this._numerics[e][r]=s}getPackedChunkId(t){const e=t&O;return this._ensureInstanceId(e),this._instanceIds[e]}setPackedChunkId(t,e){const s=t&O;this._ensureInstanceId(s),this._instanceIds[s]=e}getComputedStringAtIndex(t,e){const s=t&O;return this._ensureString(e,s),this._strings[e][s]}setComputedStringAtIndex(t,e,s){const r=t&O;this._ensureString(e,r),this._strings[e][r]=s}getXMin(t){return this._bounds[4*(t&O)]}getYMin(t){return this._bounds[4*(t&O)+1]}getXMax(t){return this._bounds[4*(t&O)+2]}getYMax(t){return this._bounds[4*(t&O)+3]}setBounds(t,e,s=!1){const r=t&O;if(!s&&!this._dirtyBitset.has(t))return this._bounds[4*r]!==xe;this._dirtyBitset.unset(t);const i=e.readGeometryWorldSpace();if(at(this._bounds,4*r+4,0),!i||!i.coords.length)return this._bounds[4*r]=xe,this._bounds[4*r+1]=xe,this._bounds[4*r+2]=xe,this._bounds[4*r+3]=xe,!1;let a=1/0,n=1/0,o=-1/0,c=-1/0;return i.forEachVertex((l,h)=>{a=Math.min(a,l),n=Math.min(n,h),o=Math.max(o,l),c=Math.max(c,h)}),this._bounds[4*r]=a,this._bounds[4*r+1]=n,this._bounds[4*r+2]=o,this._bounds[4*r+3]=c,!0}getBounds(t,e){const s=this.getXMin(e),r=this.getYMin(e),i=this.getXMax(e),a=this.getYMax(e);return Mn(t,s,r,i,a),s!==xe}_ensureNumeric(t,e){this._numerics[t]||(this._numerics[t]=[]),at(this._numerics[t],e,0)}_ensureInstanceId(t){at(this._instanceIds,t,0)}_ensureString(t,e){this._strings[t]||(this._strings[t]=[]),at(this._strings[t],e,null)}};const Ht=1,Eh=2;let zt=class Sa{constructor(e){this._geometryBounds=_i(),this._idToVisibility=new Map,this._serviceInfo=e}static async create(e){const s=new Sa(e);return await s.update(e.filterJSON,e.spatialReference),s}get hash(){return this._hash}check(e,s){return this._applyFilter(e,s)}invalidate(){this._idToVisibility.forEach((e,s)=>{this._idToVisibility.set(s,0)})}setKnownIds(e){for(const s of e)this._idToVisibility.set(s,Ht)}setTrue(e){const s=[],r=[],i=new Set(e);return this._idToVisibility.forEach((a,n)=>{const o=!!(this._idToVisibility.get(n)&Ht),c=i.has(n);!o&&c?s.push(n):o&&!c&&r.push(n),this._idToVisibility.set(n,c?Ht|Eh:0)}),{show:s,hide:r}}createQuery(){const{geometry:e,spatialRel:s,where:r,timeExtent:i,objectIds:a}=this;return Ps.fromJSON({geometry:e,spatialRel:s,where:r,timeExtent:i,objectIds:a})}async update(e,s){this._hash=JSON.stringify(e);const r=await vn(e,null,s);await Promise.all([this._setGeometryFilter(r),this._setIdFilter(r),this._setAttributeFilter(r),this._setTimeFilter(r)])}async _setAttributeFilter(e){if(!e?.where)return this._clause=null,void(this.where=null);this._clause=await Ia(e.where,this._serviceInfo.fieldsIndex),this.where=e.where}_setIdFilter(e){this._idsToShow=e?.objectIds&&new Set(e.objectIds),this._idsToHide=e?.hiddenIds&&new Set(e.hiddenIds),this.objectIds=e?.objectIds}async _setGeometryFilter(e){if(!e?.geometry)return this._spatialQueryOperator=null,this.geometry=null,void(this.spatialRel=null);const s=e.geometry,r=e.spatialRel??"esriSpatialRelIntersects",i=await Pn(r,s,this._serviceInfo.geometryType,this._serviceInfo.hasZ,this._serviceInfo.hasM);an(this._geometryBounds,s),this._spatialQueryOperator=i,this.geometry=s,this.spatialRel=r}_setTimeFilter(e){if(this.timeExtent=this._timeOperator=null,e?.timeExtent){if(!this._serviceInfo.timeInfo){const s=new P("feature-layer-view:time-filter-not-available","Unable to apply time filter, as layer doesn't have time metadata.",e.timeExtent);return void G.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(s)}this.timeExtent=e.timeExtent,this._timeOperator=Cn(this._serviceInfo.timeInfo,e.timeExtent,Rn.Shared)}}_applyFilter(e,s){return this._filterByGeometry(e)&&this._filterById(e)&&this._filterByTime(e)&&this._filterByExpression(e,s)}_filterByExpression(e,s){return!this.where||this._clause(e,s)}_filterById(e){return(!this._idsToHide?.size||!this._idsToHide.has(e.getObjectId()))&&(!this._idsToShow?.size||this._idsToShow.has(e.getObjectId()))}_filterByGeometry(e){if(!this.geometry)return!0;const s=e.readGeometryWorldSpace();return!!s&&this._spatialQueryOperator(s)}_filterByTime(e){return this._timeOperator==null||this._timeOperator(e)}},Oh=class extends Ot{constructor(t,e){super(t),this.bins=new Map,this.featureCache=new Map,this.done=!1,this._store=e}reset(){this.destroy(),this.done=!1}destroy(){const t=this.subscription.tile.key.level;for(const e of this.featureCache.keys())this._store.releaseDisplayIdForObjectId(`${e}.${t}`);this.bins.clear(),this.featureCache.clear(),this.handledChunks.clear()}get tile(){return this.subscription.tile}*featuresWorldSpace(){for(const t of this.featureCache.values()){const e=t.clone();e.geometry&&_n(e.geometry,e.geometry,!1,!1,this.subscription.tile.transform),yield e}}},Rh=class va extends Ks{static async create(e,s,r,i,a){const n=s.metadata.outSpatialReference,o=new Rt({spatialReference:n}),c=await Promise.all(e.fields.map(async h=>Zs.create(o,h))),l=e.featureFilter?await zt.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:n,filterJSON:e.featureFilter}):null;return e.index.type==="geohash"&&await Sn(n,Ts.WGS84),new va(e,l,i,c,n,s,r,a)}constructor(e,s,r,i,a,n,o,c){super(n,o,a,i,c),this._schema=e,this._featureFilter=s,this._arcadeContextInfo=r,this._metadata=Mt.createFeature({geometryType:"esriGeometryPolygon",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:new Xe(e.fields).toJSON(),globalIdField:null,spatialReference:n.metadata.spatialReference,outSpatialReference:n.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}createState(e){return new Oh(e,this._attributeStore)}async*applyOverrideUpdate(e){for(const s of this._sendStates.values())s.reset(),yield new Ce(s.subscription,E.empty(this._source.metadata),!0,!1,{})}displayMap(e,s,r){const i=new Map(e.map(n=>[s(n),n])),a=[];for(const n of this._sendStates.values())for(const o of n.featuresWorldSpace()){const{objectId:c,displayId:l}=o,h=i.get(c);if(h!=null){const u=r(l,h,c);a.push(u),i.delete(c)}}return a}getDisplayFeatures(e){const s=new Set(e),r=new Set,i=[];for(const a of this._sendStates.values())for(const n of a.featuresWorldSpace())s.has(n.displayId)&&!r.has(n.objectId)&&(n.geometry&&i.push({...ui(n,this._metadata.geometryType,!1,!1),displayId:n.displayId}),r.add(n.objectId));return{features:[],aggregates:i,tracks:[]}}getFeatureObjectIdsForAggregate(e){for(const s of this._sendStates.values())for(const r of s.bins.values())if(r.id===e)return Array.from(r.containedObjectIds);return[]}async*updateChunks(){for(const e of this._sendStates.values())yield*this._update(e,this._source)}forEachAggregateWorldSpace(e){const s=new Set;for(const r of this._sendStates.values())for(const i of r.featuresWorldSpace())s.has(i.objectId)||(e(i),s.add(i.objectId))}_createIndexOptions(e){switch(this._schema.index.type){case"geohash":return{type:"geohash",fields:this.aggregateFields,featureFilter:this._featureFilter,geohashLevel:this._schema.index.fixBinLevel,spatialReference:this.spatialReference,arcadeContextInfo:this._arcadeContextInfo,scale:e.scale,sqlOptions:this._sqlOptions};case"grid":{const s=this._schema.index.fixedBinLevel,r=s!=null?e.tileInfoView.getLODInfoAt(s).scale:e.scale;return{type:"grid",fields:this.aggregateFields,cellSize:this._schema.index.size,featureFilter:this._featureFilter,spatialReference:this.spatialReference,arcadeContextInfo:this._arcadeContextInfo,scale:r,sqlOptions:this._sqlOptions}}}}async*_update(e,s){const{handledChunks:r,subscription:i,bins:a,featureCache:n}=e,o=i.tile;if(e.done)return;for(const p of s.chunks()){if(r.has(p.chunkId))continue;r.add(p.chunkId);const m=p.queryInfo;if("tileId"in m){const _=new kt(m.tileId);if(_.level!==o.level||_.world!==o.key.world)continue}p.getAggregateIndex(this._createIndexOptions(e.tile)).putBounded(a,e.tile.extent,e.tile.resolution)}const c=[],l=i.tile.transform,h=i.tile.key.level;for(const p of a.values()){let m=n.get(p.id);if(m)m.attributes=p.getAttributes();else{const _=p.getGeometry(this.spatialReference,l);m=new Y(_,p.getAttributes(),null,p.id),_||(m.centroid=p.getGeometricCentroid(this.spatialReference,l)),m.displayId=this._attributeStore.createDisplayIdForObjectId(`${m.objectId}.${h}`),n.set(p.id,m)}c.push(m)}this.events.emit("changed"),e.done=!s.updateTracking.updating;const u=E.fromOptimizedFeatures(c,this._metadata,l),d=u.getCursor(),f=e.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);for(;d.next();)this._attributeStore.setAttributeData(d.getDisplayId(),d,f,this._sqlOptions);yield new bs(e.subscription,u,[],e.done,{})}},zh=class{constructor(t,e){this.inner=t,this.displayId=e}};const nt=128;let Dh=class extends Ot{constructor(t){super(t),this.didSend=!1,this.done=!1}},Lh=class{constructor(t,e,s,r,i){this._level=t,this._scale=e,this._indexOptions=s,this._clusterRadius=r,this._store=i,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const t of this._clusters.values())this._store.releaseDisplayIdForObjectId(t.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const t of this._clusters.values()){const e=t.inner.getCentroid(null);yield new Y(e,t.inner.getAttributes(),null,t.inner.id,t.displayId)}}clusters(){return this._clusters.values()}updateChunks(t,e){let s=!1;for(const n of t){const o=n.queryInfo;"tileId"in o&&new kt(o.tileId).level!==this._level||this._handledChunks.has(n.normalizedChunkId)||(this._handledChunks.add(n.normalizedChunkId),s=!0,n.getAggregateIndex({...this._indexOptions,scale:this._scale}).put(this._cells))}const r={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},i=mr(this._indexOptions.spatialReference,this._scale),a=this._indexOptions.cellSize;for(const{subscription:n}of e){const o=n.tile.bounds,c=Math.floor(o[0]*i/a),l=Math.floor(o[1]*i/a),h=Math.ceil(o[2]*i/a),u=Math.ceil(o[3]*i/a);r.xMin=Math.min(r.xMin,c),r.yMin=Math.min(r.yMin,l),r.xMax=Math.max(r.xMax,h),r.yMax=Math.max(r.yMax,u)}return this._lastCellBounds!=null&&r.xMin===this._lastCellBounds.xMin&&r.yMin===this._lastCellBounds.yMin&&r.yMin===this._lastCellBounds.yMin&&r.yMax===this._lastCellBounds.yMax||(s=!0,this._lastCellBounds=r),s&&this._clusterCells(r),s}async updateStatistics(t){let e=!1;for(const s of this._clusters.values())s.inner.count>1&&(e=this._updateAggregateStatistics(this._statistics,s.inner)||e);if(e){const s=Array.from(this._statistics.entries()).map(([r,i])=>({fieldName:r,minValue:i.minValue,maxValue:i.maxValue}));await t.container.updateStatistics(this._level,s)}}createAggregateFeatures(t,e){const s=t.subscription,r=[],i=s.tile.transform;for(const a of this._clusters.values()){let n=a.inner.getCentroidX(i);const o=a.inner.getCentroidY(i),c=s.tile.lod,l=c.wrap?c.worldSize[0]:null,h=a.inner.count===1?a.inner.firstObjectId:a.inner.id,u=a.displayId;if(l!=null)if(l===1){const d=new D([],[n,o]),f=new Y(d,a.inner.getAttributes(),null,h,u);f.geometry.coords[0]-=T,r.push(f);const p=new D([],[n,o]),m=new Y(p,a.inner.getAttributes(),null,h,u);m.geometry.coords[0]+=T,r.push(m)}else n>T+T/2?n-=l*T:n<-256&&(n+=l*T);if(n<T+nt&&n>=-nt&&o<T+nt&&o>=-nt){const d=new D([],[n,o]),f=new Y(d,a.inner.getAttributes(),null,h,u);r.push(f)}}return E.fromOptimizedFeatures(r,e,s.tile.transform)}_clusterCells(t){let e=Array.from(this._cells.values());e=e.sort((n,o)=>o.count-n.count);const s=[];for(const n of this._clusters.values())s.push(n.inner.id);this._clusters.clear();const r=this._clusterRadius*(1/mr(this._indexOptions.spatialReference,this._scale)),i=1+this._clusterRadius/this._indexOptions.cellSize,a=new Set;for(const n of e){if(a.has(n.id)||n.gridX<t.xMin||n.gridX>t.xMax||n.gridY<t.yMin||n.gridY>t.yMax)continue;const o=this._store.createDisplayIdForObjectId(n.id),c=new zh(n.clone(),o);a.add(n.id),this._clusters.set(n.id,c);const l=n.centroidXWorld,h=n.centroidYWorld;for(let u=n.gridY-i;u<=n.gridY+i;u++)for(let d=n.gridX-i;d<=n.gridX+i;d++){if(u===n.gridY&&d===n.gridX)continue;const f=this._cells.get(Ln.createId(d,u));if(!f||a.has(f.id))continue;const p=Math.abs(f.centroidXWorld-l),m=Math.abs(f.centroidYWorld-h);p<r&&m<r&&(c.inner.merge(f),a.add(f.id))}}for(const n of s)this._store.releaseDisplayIdForObjectId(n)}_updateAggregateStatistics(t,e){let s=!1;for(const r of e.statistics.values()){if(r.field.type==="esriFieldTypeString")continue;const i=r.value,a=r.field,n=t.get(a.name);if(n){const{minValue:o,maxValue:c}=n,l=Math.min(n.minValue,i),h=Math.max(n.maxValue,i);o===l&&c===h||(n.minValue=l,n.maxValue=h,s=!0);continue}t.set(a.name,{minValue:i,maxValue:i}),s=!0}return s}},Bh=class ka extends Ks{static async create(e,s,r,i,a,n){const o=r.metadata.outSpatialReference,c=new Rt({spatialReference:o}),l={type:"grid",fields:await Promise.all(s.fields.map(async h=>Zs.create(c,h))),spatialReference:o,featureFilter:s.featureFilter?await zt.create({geometryType:r.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:r.metadata.timeInfo,fieldsIndex:r.metadata.fieldsIndex,spatialReference:o,filterJSON:s.featureFilter}):null,cellSize:s.clusterRadius/4,arcadeContextInfo:a,sqlOptions:n};return new ka(e,s.clusterRadius,l,s.fields,r,i,n)}constructor(e,s,r,i,a,n,o){super(a,n,r.spatialReference,r.fields,o),this._connection=e,this._clusterRadius=s,this._indexOptions=r,this._cellsPerScale=new Map,this._metadata=Mt.createFeature({geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:new Xe([...i,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}]).toJSON(),globalIdField:null,spatialReference:a.metadata.spatialReference,outSpatialReference:a.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const e of this._cellsPerScale.values())e.destroy();this._cellsPerScale.clear()}onSubscribe(e){super.onSubscribe(e),this._requiredLevel=e.tile.level,this._requiredScale=e.tile.scale}createState(e){return new Dh(e)}async*applyOverrideUpdate(e){for(const s of this._cellsPerScale.values())s.destroy();this._cellsPerScale.clear();for(const s of this._sendStates.values())s.done=!1}displayMap(e,s,r){const i=new Map(e.map(o=>[s(o),o])),a=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const o of n.clusters()){const c=i.get(o.inner.id);if(c!=null){const l=r(o.displayId,c,o.inner.id);a.push(l),i.delete(o.inner.id);continue}if(o.inner.count===1){const{firstObjectId:l}=o.inner,h=l?i.get(l):null;if(h!=null){const u=r(o.displayId,h,l);a.push(u),i.delete(l)}}}return a}getDisplayFeatures(e){const s=new Set(e),r=new Set,i=[],a=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const o of n.aggregatesWorldSpace())if(s.has(o.displayId)&&!r.has(o.displayId)){const c=ui(o,this._metadata.geometryType,!1,!1);if(r.add(o.displayId),c.attributes.cluster_count===1){i.push({...c,displayId:o.displayId});continue}a.push({...c,displayId:o.displayId})}return{features:i,aggregates:a,tracks:[]}}getFeatureObjectIdsForAggregate(e){const s=this._getClusterState(this._requiredLevel,this._requiredScale);for(const r of s.clusters())if(r.inner.id===e)return Array.from(r.inner.containedObjectIds);return[]}async*updateChunks(){const e=this._source.chunks();if(!e.length)return;const s=this._getClusterState(this._requiredLevel,this._requiredScale),r=Array.from(this._sendStates.values()).filter(n=>n.subscription.tile.level===this._requiredLevel);if(s.updateChunks(e,r)||!this._source.updateTracking.updating)for(const n of r)n.subscription.tile.level===this._requiredLevel&&(n.didSend=!1,n.done=!1);const i=Array.from(this._sendStates.values()).filter(n=>n.done).map(n=>n.subscription.tile.key),a=new Set(i);for(const n of this._sendStates.values())this._source.updateTracking.updating&&(i.some(o=>o.containsChild(n.subscription.tile.key))||n.subscription.tile.key.getChildKeys().every(o=>a.has(o)))||n.didSend||n.subscription.tile.level!==this._requiredLevel||(n.didSend=!0,yield*this._update(n,s,this._source));await s.updateStatistics(this._connection)}forEachAggregateWorldSpace(e){if(this._requiredLevel==null||this._requiredScale==null)return;const s=this._getClusterState(this._requiredLevel,this._requiredScale);for(const r of s.aggregatesWorldSpace())e(r)}_getClusterState(e,s){if(e==null||s==null)throw new Error("InternalError: Level and scale must be defined");let r=this._cellsPerScale.get(s);return r||(r=new Lh(e,s,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(s,r)),r}async*_update(e,s,r){if(e.done)return;const i=s.createAggregateFeatures(e,this._metadata);this.events.emit("changed"),e.done=!r.updateTracking.updating;const a=i.getCursor(),n=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);for(;a.next();)this._attributeStore.setAttributeData(a.getDisplayId(),a,n,this._sqlOptions);yield new Ce(e.subscription,i,!0,e.done,{})}},qh=class extends Ot{},Nh=class extends xa{constructor(t,e,s,r){super(t,e,r),this._arcadeContextInfo=s,this.handledChunks=new Set,this.handledChunksForIdCreation=new Set,this.handledChunksForAttributeData=new Set,this._streamLayerDeferredObjectIdsToRemove=[]}destroy(){super.destroy();for(const t of this._source.chunks())this._cleanupChunkIds(t)}invalidateAttributeData(t){this.handledChunksForAttributeData.clear(),this._arcadeContextInfo=t,this._evalOptions!=null&&(this._evalOptions=Fs(this._evalOptions.$view.scale,t))}onSubscribe(t){super.onSubscribe(t),this._evalOptions=t.tile.createArcadeEvaluationOptions(this._arcadeContextInfo)}createState(t){return new qh(t)}get aggregateQueryEngine(){return null}displayMap(t,e,s){const r=new Map(t.map(a=>[e(a),a])),i=[];for(const a of this._source.chunks()){const n=a.reader.getCursor();for(;n.next();){const o=n.getObjectId(),c=n.getDisplayId(),l=r.get(o);if(l!=null){const h=s(c,l,o);i.push(h),r.delete(o)}}}return i}getDisplayFeatures(t){const e=new Set(t),s=new Set,r=[];for(const i of this._source.chunks()){const a=i.reader.getCursor();for(;a.next();){const n=a.getObjectId(),o=a.getDisplayId();e.has(o)&&!s.has(n)&&(r.push({...a.readLegacyFeatureWorldSpace(),displayId:o}),s.add(n))}}return{features:r,aggregates:[],tracks:[]}}async*applyOverrideUpdate(t){const e=[];for(const a of t.modified.values()){const n=this._attributeStore.createDisplayIdForObjectId(a.objectId);a.displayId=n,e.push(n)}const s=E.fromOptimizedFeatures(Array.from(t.modified.values()),this._source.metadata).getCursor();for(;s.next();)this._attributeStore.setAttributeData(s.getDisplayId(),s,this._evalOptions,this._sqlOptions);const r=[];for(const a of t.removed){const n=this._attributeStore.getDisplayIdForObjectId(a);n!=null&&r.push(n)}v("esri-2d-update-debug")&&console.debug("FeatureUpdateStrategy.applyLocalEdit",{message:t,modifiedDisplayIds:e,removedDisplayIds:r});const i=On.fromFeatures(Array.from(t.modified.values()),this._source.metadata);this.handledChunks.add(i.chunkId),this.handledChunksForAttributeData.add(i.chunkId),this.handledChunksForIdCreation.add(i.chunkId);for(const a of this._sendStates.values())a.handledChunks.add(i.chunkId),yield new bs(a.subscription,null,e,!1,i.queryInfo);for(const a of this._sendStates.values()){const n=i.getTileReader(a.subscription.tile);yield new bs(a.subscription,n,r,!1,i.queryInfo)}for(const a of t.removed)this._attributeStore.releaseDisplayIdForObjectId(a)}async*updateChunks(){if(this._source.chunks().length){this._updateAttributeData();for(const t of this._sendStates.values())yield*this._update(t)}}removeChunks(t){for(const e of t)this.handledChunks.delete(e.chunkId),this.handledChunksForAttributeData.delete(e.chunkId),this._cleanupChunkIds(e)}afterUpdateChunks(){for(const t of this._streamLayerDeferredObjectIdsToRemove)this._attributeStore.releaseDisplayIdForObjectId(t);this._streamLayerDeferredObjectIdsToRemove=[]}_cleanupChunkIds(t){if(this.handledChunksForIdCreation.has(t.chunkId)){const e=t.reader.getCursor();for(;e.next();){const s=e.getObjectId();this._source.isStream?this._streamLayerDeferredObjectIdsToRemove.push(s):this._attributeStore.releaseDisplayIdForObjectId(s)}this.handledChunksForIdCreation.delete(t.chunkId)}}_updateAttributeData(){for(const t of this._source.chunks()){const{chunkId:e,reader:s}=t;if(!this.handledChunksForIdCreation.has(e)){this.handledChunksForIdCreation.add(e);const r=s.getCursor();for(;r.next();){const i=this._attributeStore.createDisplayIdForObjectId(r.getObjectId());r.setDisplayId(i)}}}for(const t of this._source.chunks())if(this._attributeStore.referencesScale()||!this.handledChunksForAttributeData.has(t.chunkId)){this.handledChunksForAttributeData.add(t.chunkId);const e=t.reader.getCursor();for(;e.next();){const s=e.getDisplayId();this._attributeStore.setAttributeData(s,e,this._evalOptions,this._sqlOptions)}}}*_update(t){const{subscription:e,handledChunks:s}=t;for(const r of this._source.chunks()){const{chunkId:i}=r;if(s.has(i)||!this.handledChunksForIdCreation.has(i)||!this.handledChunksForAttributeData.has(i))continue;s.add(i);const a=r.getTileReader(e.tile);a&&(yield new Ce(t.subscription,a,!1,r.end,r.queryInfo))}}},ht;const Gh=()=>G.getLogger("esri.views.2d.layers.features.processor.TrackStrategy"),Uh=32;class $h{constructor(e,s,r,i,a){this.chunkIndex=e,this.featureIndex=s,this.objectId=r,this.displayId=i,this.time=a}}class Yr{static getOid(e){return Ja+e}constructor(e,s,r,i,a,n,o,c){this._schema=e,this.trackId=s,this.objectId=r,this.displayId=i,this._fields=a,this._spatialReference=n,this._metadata=o,this._isStream=c,this._maxDisplayDuration=this._schema.maxDisplayDuration>0?this._schema.maxDisplayDuration:1/0,this._maxDisplayObservationsPerTrack=this._schema.maxDisplayObservationsPerTrack>=1?this._schema.maxDisplayObservationsPerTrack:1/0,this._observationRecords=[],this._nextObservationRecords=[],this._trackLinePath=[],this._bounds=[],this._trackLineGeometry=new D}get _trackLineAttributes(){const e={...this._latestObservationFeature?.attributes,aggregateId:this.objectId,[ke]:0};if(this._statistics!=null)for(const s of this._statistics.values())e[s.field.name]=s.value;return e}get _startTimeField(){return this._metadata.timeInfo?.startTimeField}get length(){return this._observationRecords.length}*observations(){yield*this._observationRecords}*previousObservations(){for(let e=0;e<this._observationRecords.length-1;e++)yield this._observationRecords[e]}get latestObservationFeature(){return this._latestObservationFeature}get latestObservationRecord(){return this._latestObservationRecord}stageObservation(e,s){this._nextObservationRecords.push(new $h(e,s.getIndex(),s.getObjectId(),s.getDisplayId(),this._startTimeField!=null?s.readAttributeAsTimestamp(this._startTimeField):null))}commitObservations(e,s,r){const i=new Set(this._nextObservationRecords.map(h=>h.objectId)),a=this._observationRecords.filter(h=>!i.has(h.objectId)).map(h=>h.objectId);let n,o;switch(this._observationRecords=[],this._trackLinePath=[],this._isStream||this._startTimeField==null||this._nextObservationRecords.sort((h,u)=>{const d=h.time,f=u.time;return d!=null&&f!=null?d-f:0}),this._schema.timeField){case"startTimeField":n=this._metadata.timeInfo?.startTimeField;break;case"endTimeField":n=this._metadata.timeInfo?.endTimeField;break;case"timeReceived":n=this._isStream?ni:null}o=this._isStream?r?.end??Date.now():r?.end??-1/0;const c=s.map(h=>h.reader.getCursor());let l;for(let h=this._nextObservationRecords.length-1;h>=0&&!(this._observationRecords.length>=this._maxDisplayObservationsPerTrack);h--){const u=this._nextObservationRecords[h],d=c[u.chunkIndex];ct(d),d.setIndex(u.featureIndex);const f=n!=null?d.readAttributeAsTimestamp(n):null;(f!=null?o-f:0)>=this._maxDisplayDuration||(this._commitObservation(u,d),l??=u)}if(l!=null){const{chunkIndex:h,featureIndex:u}=l,d=`${l.objectId}.latest`,f=e.createDisplayIdForObjectId(d),p=c[h];ct(p),p.setIndex(u);const m=new Y(p.readGeometryWorldSpace(),{...p.readAttributes(),[ke]:1},null,d,f);this._latestObservationFeature&&a.push(this._latestObservationFeature.objectId),this._latestObservationFeature=m,this._latestObservationRecord=l}else this._latestObservationFeature=null;return this._trackLineGeometry=Vh(this._trackLineGeometry,this._trackLinePath,this._spatialReference),this._bounds=Yh(this._trackLineGeometry),this._nextObservationRecords=[],a}updateStatistics(e,s){this._statistics=Dn.create(this._fields);const r=e.map(i=>i.reader.getCursor());for(const{chunkIndex:i,featureIndex:a}of this._observationRecords){const n=r[i];ct(n),n.setIndex(a),this._statistics.insert(n,s)}}overlapsTile(e){for(const s of this._bounds)if(Un(s,e.bounds,Uh))return!0;return!1}getLatestObservationFeatureForTile(e){if(this._latestObservationFeature==null)return null;const{objectId:s,displayId:r,geometry:i,attributes:a}=this._latestObservationFeature,n=new D;ur(n,i,!1,!1,this._metadata.geometryType,e.subscription.tile.transform);const o=yr(1/0,1/0,-1/0,-1/0);return jh(n,(c,l)=>gi(o,[c,l])),$n(o,yr(0,0,T,T))?new Y(n,a,null,s,r):null}getTrackLineFeatureForTile(e){const s=new D;return ur(s,this._trackLineGeometry,!1,!1,"esriGeometryPolyline",e.subscription.tile.transform),new Y(s,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineOptimizedFeature(){return new Y(this._trackLineGeometry,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineDisplayFeature(){const{_trackLineGeometry:e,_trackLineAttributes:s,displayId:r}=this;return{geometry:rs(e,"esriGeometryPolyline",!1,!1),attributes:s,displayId:r}}_commitObservation(e,s){const r=s.readCentroidWorldSpace();let i=r?.coords[0],a=r?.coords[1];r==null&&(i=s.readXWorldSpace(),a=s.readYWorldSpace()),i!=null&&a!=null&&(this._observationRecords.unshift(e),this._trackLinePath.unshift([i,a]))}}class Wh extends Ot{constructor(e){super(e),this.done=!1}}class Js extends Ks{static async create(e,s,r,i,a){const n=s.metadata.outSpatialReference,o=new Rt({spatialReference:n}),c=await Promise.all(e.fields.map(async h=>Zs.create(o,h))),l=e.featureFilter?await zt.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:n,filterJSON:e.featureFilter}):null;return n.isWrappable||Wn()||await Promise.all([rr(()=>ir(()=>import("./apiConverter-BAgvri9D-CJVft-_U.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17])),as([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17])),rr(()=>ir(()=>import("./jsonConverter-DmBmaSz7-DAl7KiR-.js"),__vite__mapDeps([17,1,3,2,4,5,6,7,9,10,11,12])),as([17,1,3,2,4,5,6,7,9,10,11,12])),Vn()]).then(([h,u,d])=>{ht={fromGeometryToGXGeometry:u.fromGeometryToGXGeometry,toGeometry:u.toGeometry,fromSpatialReference:h.fromSpatialReference}}),new Js(e,s,r,n,c,l,i,a)}constructor(e,s,r,i,a,n,o,c){super(s,r,i,a,c),this._schema=e,this._featureFilter=n,this._arcadeContextInfo=o,this._tracks=new Map,this._handledChunks=new Set,this._metadata=s.metadata.weakCloneWithAdditionalFields([{name:ke,alias:"trackPart",type:"esriFieldTypeSmallInteger"}]),this._trackLineMetadata=Mt.createFeature({geometryType:"esriGeometryPolyline",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:{fields:[...this._source.metadata.fieldsIndex.fields,...this.aggregateFields,{name:ke,alias:"trackPart",type:"esriFieldTypeSmallInteger"},{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],timeZoneByFieldName:null},globalIdField:null,spatialReference:s.metadata.spatialReference,outSpatialReference:s.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:s.metadata.timeInfo,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}destroy(){super.destroy(),this._clear()}get _isStream(){return this._source.isStream}get enablePixelBuffering(){return!0}get isAggregate(){return!1}requiresInvalidation(){return!0}invalidate(){super.invalidate(),this._clear()}createState(e){return new Wh(e)}async*applyOverrideUpdate(e){Gh().error("Applying override to tracks is not supported")}displayMap(e,s,r){const i=new Map(e.map(n=>[s(n),n])),a=[];for(const n of this._tracks.values()){const o=i.get(n.objectId);if(o!=null){const l=r(n.displayId,o,n.objectId);a.push(l),i.delete(n.objectId);continue}const c=n.latestObservationFeature;if(c?.objectId){const l=i.get(c.objectId);if(l!=null){const h=r(c.displayId,l,c.objectId);a.push(h),i.delete(c.objectId);continue}}for(const l of n.observations()){const h=i.get(l.objectId);if(h!=null){const u=r(l.displayId,h,l.objectId);a.push(u),i.delete(l.objectId)}}}return a}getDisplayFeatures(e){const s=new Set(e),r=[],i=[],a=this._source.chunks().map(n=>n.reader.getCursor());for(const n of this._tracks.values()){if(s.has(n.displayId)&&i.push(n.getTrackLineDisplayFeature()),n.latestObservationFeature!=null&&s.has(n.latestObservationFeature.displayId)){const{displayId:o,chunkIndex:c,featureIndex:l}=n.latestObservationRecord,h=a[c];h.setIndex(l),r.push({displayId:o,...h.readLegacyFeatureWorldSpace()})}for(const{displayId:o,chunkIndex:c,featureIndex:l}of n.observations())if(s.has(o)){const h=a[c];h.setIndex(l),r.push({displayId:o,...h.readLegacyFeatureWorldSpace()})}}return{features:r,aggregates:[],tracks:i}}getFeatureObjectIdsForAggregate(e){for(const s of this._tracks.values())if(s.objectId===e)return Array.from(s.observations(),r=>r.objectId);return[]}async*updateChunks(){this._handledChunks.size===0&&this._rebuildTracks();for(const e of this._sendStates.values())yield*this._update(e)}forEachAggregateWorldSpace(e){for(const s of this._tracks.values())e(s.getTrackLineOptimizedFeature())}_clear(){for(const e of this._source.chunks())if(this._handledChunks.has(e.chunkId)){const s=e.reader.getCursor();for(;s.next();){const r=s.getObjectId();this._attributeStore.releaseDisplayIdForObjectId(r)}}this._handledChunks.clear();for(const e of this._tracks.values())this._removeTrack(e);this._tracks.clear()}_rebuildTracks(){const e=this._source.chunks();if(!e.length)return;const s=this._metadata.timeInfo?.trackIdField;if(s==null)return;const r=new Set;for(let i=0;i<e.length;i++){const a=e[i];if(this._handledChunks.has(a.chunkId))continue;this._handledChunks.add(a.chunkId);const n=a.reader.getCursor();for(;n.next();){const o=n.getObjectId();n.setDisplayId(this._attributeStore.createDisplayIdForObjectId(o));const c=n.readAttribute(s);if(c!=null&&o!=null&&(this._featureFilter===null||this._featureFilter.check(n,this._sqlOptions))){if(!this._tracks.has(c)){const l=Yr.getOid(c),h=this._attributeStore.createDisplayIdForObjectId(l),u=new Yr(this._schema,c,l,h,this.aggregateFields,this.spatialReference,this._source.metadata,this._isStream);this._tracks.set(c,u)}this._tracks.get(c).stageObservation(i,n),r.add(c)}}}for(const i of this._tracks.values())if(r.has(i.trackId)){const a=i.commitObservations(this._attributeStore,e,this._featureFilter?.timeExtent);for(const n of a)this._attributeStore.releaseDisplayIdForObjectId(n);i.updateStatistics(e,Fs(1,this._arcadeContextInfo))}else this._removeTrack(i)}_removeTrack(e){this._tracks.delete(e.trackId),this._attributeStore.releaseDisplayIdForObjectId(e.objectId),e.latestObservationFeature!=null&&this._attributeStore.releaseDisplayIdForObjectId(e.latestObservationFeature.objectId)}*_update(e){if(e.done)return;e.done=!this._source.updateTracking.updating;const s=[],r=[];for(const h of this._tracks.values())if(h.length>0){if(this._schema.showLatestObservation){const u=h.getLatestObservationFeatureForTile(e);u!=null&&s.push(u)}this._schema.showTrackLine&&h.overlapsTile(e.subscription.tile)&&r.push(h.getTrackLineFeatureForTile(e))}const i=E.fromOptimizedFeatures(s,this._metadata,e.subscription.tile.transform),a=E.fromOptimizedFeatures(r,this._trackLineMetadata,e.subscription.tile.transform);let n=[];if(this._schema.showPreviousObservations){const h=this._source.chunks().map(()=>[]);for(const u of this._tracks.values())for(const{chunkIndex:d,featureIndex:f}of u.previousObservations())h[d].push(f);n=this._source.chunks().map((u,d)=>{const f=u.getTileReader(e.subscription.tile);if(f==null)return null;const p=mi.from(f,h[d]);return p.setProcessorAttributes({[ke]:2}),p.geometryType!=="esriGeometryPoint"&&p.getInTransform()!=null||p.setTransformForDisplay(e.subscription.tile.transform),p}).filter(Le)}this.events.emit("changed");const o=e.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo),c=a.getCursor();for(;c.next();)this._attributeStore.setAttributeData(c.getDisplayId(),c,o,this._sqlOptions);for(const h of n){const u=h.getCursor();for(;u.next();)this._attributeStore.setAttributeData(u.getDisplayId(),u,o,this._sqlOptions)}const l=i.getCursor();for(;l.next();)this._attributeStore.setAttributeData(l.getDisplayId(),l,o,this._sqlOptions);yield new Ce(e.subscription,a,!1,!1,{});for(const h of n)yield new Ce(e.subscription,h,!1,!1,{});yield new Ce(e.subscription,i,!1,e.done,{})}}function Vh(t,e,s){if(e.length<2)return Re(t,[e],!1,!1);if(s.isWrappable){let a=!1;for(let n=1;n<e.length;n++){const o=e[n][0],c=Hn(o,e[n-1][0],s);o!==c&&(e[n][0]=c,a=!0)}if(a){const n=Xn({paths:[e],spatialReference:s});if(n!=null)return Re(t,n.paths,!1,!1)}return Re(t,[e],!1,!1)}const r=ht.fromGeometryToGXGeometry({hasM:!1,hasZ:!1,paths:[e]}),i=ht.fromSpatialReference(s);if(i!=null){const a=jn(r,1e6,i,Yn.geodesic);if(a!=null){const n=ht.toGeometry(a,i);if(n!=null&&"paths"in n)return Re(t,n.paths,!1,!1)}}return Re(t,[e],!1,!1)}function jh(t,e){const{coords:s,lengths:r}=t;if(!r.length)return void e(s[0],s[1]);let i=0;for(let a=0;a<r.length;a++){const n=r[a];let o=0,c=0;for(let l=0;l<n;l++)o+=s[2*(l+i)],c+=s[2*(l+i)+1],e(o,c);i+=n}}function Yh(t){const{lengths:e,coords:s}=t,r=2;if(!e.length)return[gr()];const i=[];let a=0;for(let n=0;n<e.length;n++){const o=e[n],c=gr();i.push(c);for(let l=0;l<o;l++){const h=s[r*(l+a)],u=s[r*(l+a)+1];gi(c,[h,u])}a+=o}return i}const Hh=()=>G.getLogger("esri.views.2d.engine.webgl.Utils");function Xh(t){switch(t){case se.UNSIGNED_BYTE:return Uint8Array;case se.UNSIGNED_SHORT_4_4_4_4:return Uint16Array;case se.FLOAT:return Float32Array;default:return void Hh().error(new P("webgl-utils",`Unable to handle type ${t}`))}}const Qh=(t,e)=>t&&((...s)=>e.warn("DEBUG:",...s))||(()=>null),Zh=!1;let Hr=class{constructor(t){this.data=t,this._referenceCount=0}static{this.estimatedMemory=20}increment(){this._referenceCount+=1}decrement(){this._referenceCount-=1}empty(){return this._referenceCount===0}},Kh=class{constructor(){this._freeIdsGenerationA=[],this._freeIdsGenerationB=[],this._idCounter=1,this._freeIds=this._freeIdsGenerationA,this._objectIdToDisplayId=new Map}get usedMemory(){let t=0;return t+=te(this._freeIdsGenerationA),t+=te(this._freeIdsGenerationB),t+=this._objectIdToDisplayId.size*(Hr.estimatedMemory+8),t}createIdForObjectId(t){let e=this._objectIdToDisplayId.get(t);return e?e.increment():(e=new Hr(vh(this._getFreeId(),!1)),e.increment(),this._objectIdToDisplayId.set(t,e)),e.data}releaseIdForObjectId(t){const e=this._objectIdToDisplayId.get(t);e&&(e.decrement(),e.empty()&&(this._objectIdToDisplayId.delete(t),this._freeIds.push(e.data)))}getDisplayIdForObjectId(t){const e=this._objectIdToDisplayId.get(t);return e!=null?e.data:null}releaseAll(){for(const t of this._objectIdToDisplayId.values())this._freeIds.push(t.data);this._objectIdToDisplayId.clear()}incrementGeneration(){this._freeIds=this._freeIds===this._freeIdsGenerationA?this._freeIdsGenerationB:this._freeIdsGenerationA}_getFreeId(){return this._freeIds.length?this._freeIds.pop():this._idCounter++}};function Jh(t,e){if(!t||!e)return t;switch(e){case"radius":case"distance":return 2*t;case"diameter":case"width":return t;case"area":return Math.sqrt(t)}return t}const er=()=>G.getLogger("esri.views.layers.2d.features.support.AttributeStore"),Xt=Qh(Zh,er()),eu={sharedArrayBuffer:v("esri-shared-array-buffer"),atomics:v("esri-atomics")};let tu=class{constructor(t,e,s){this.size=0,this.texelSize=4,this.dirtyStart=0,this.dirtyEnd=0;const{pixelType:r,layout:i,textureOnly:a}=e;this.textureOnly=a||!1,this.pixelType=r,this.layout=i,this._resetRange(),this.size=t,this.isLocal=s,a||(this.data=this._initData(r,t))}get usedMemory(){return this.data?.byteLength??0}get buffer(){return this.data?.buffer}unsetComponentAllTexels(t,e){const s=this.data;for(let r=0;r<this.size*this.size;r++)s[r*this.texelSize+t]&=~e;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponentAllTexels(t,e){const s=this.data;for(let r=0;r<this.size*this.size;r++)s[r*this.texelSize+t]|=255&e;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponent(t,e,s){const r=this.data;for(const i of s)r[i*this.texelSize+t]|=e,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}setComponentTexel(t,e,s){this.data[s*this.texelSize+t]|=e,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s)}unsetComponentTexel(t,e,s){this.data[s*this.texelSize+t]&=~e,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s)}getData(t,e){const s=Se(t);return this.data[s*this.texelSize+e]}setData(t,e,s){const r=Se(t),i=1<<e;(this.layout&i)!==0?this.data!=null&&(this.data[r*this.texelSize+e]=s,this.dirtyStart=Math.min(this.dirtyStart,r),this.dirtyEnd=Math.max(this.dirtyEnd,r)):er().error("mapview-attributes-store","Tried to set a value for a texel's readonly component")}expand(t){if(this.size=t,!this.textureOnly){const e=this._initData(this.pixelType,t),s=this.data;e.set(s),this.data=e}}toMessage(){const t=this.dirtyStart,e=this.dirtyEnd,s=this.texelSize;if(t>e)return null;this._resetRange();const r=!this.isLocal,i=this.pixelType,a=this.layout,n=this.data;return{start:t,end:e,data:r&&n.slice(t*s,(e+1)*s)||null,pixelType:i,layout:a}}_initData(t,e){const s=ArrayBuffer,r=Xh(t),i=new r(new s(e*e*4*r.BYTES_PER_ELEMENT));for(let a=0;a<i.length;a+=4)i[a+1]=255;return i}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}},su=class{constructor(t){this._client=t,this._filters=[],this._blocks=new Array,this._attributeComputeInfo=null,this._abortController=new AbortController,this._size=Wa,this._idsToHighlight=new Map,this._arcadeDependencies=new Set,this._initialized=!1,this.version=0,this._idGenerator=new Kh,this._epoch=1}destroy(){this._abortController.abort()}_initialize(){if(this._blockDescriptors!=null)return;const t=se.FLOAT;Xt(`Creating AttributeStore ${eu.sharedArrayBuffer?"with":"without"} shared memory`),this._blockDescriptors=[{pixelType:se.UNSIGNED_BYTE,layout:1},{pixelType:se.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:se.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:se.FLOAT,layout:15}],this._blocks=this._blockDescriptors.map(()=>null)}get usedMemory(){let t=0;for(const e of this._blocks)e&&(t+=e.usedMemory);return t+=this._idGenerator.usedMemory,t}get hasHighlight(){return this._idsToHighlight.size>0}createDisplayIdForObjectId(t){return this._idGenerator.createIdForObjectId(t)}releaseDisplayIdForObjectId(t){return this._idGenerator.releaseIdForObjectId(t)}getDisplayIdForObjectId(t){return this._idGenerator.getDisplayIdForObjectId(t)}incrementDisplayIdGeneration(){this._idGenerator.incrementGeneration()}hasArcadeDependency(t){return this._arcadeDependencies.has(t)}releaseAllIds(){this._idGenerator.releaseAll()}async update(t,e,s,r=0){const i=ai(this._schema,t);if(this.version=r,i&&(v("esri-2d-update-debug")&&console.debug(`Version[${r}] AttributeStore.update`,{changed:i}),this._schema=t,this._attributeComputeInfo=null,this._initialize(),t!=null))if(s&&(this._filters=await Promise.all(t.filters.map(a=>a?zt.create({geometryType:s.geometryType,hasM:!1,hasZ:!1,timeInfo:s.timeInfo,fieldsIndex:s.fieldsIndex,spatialReference:s.outSpatialReference,filterJSON:a}):null))),t.type!=="multi")this._attributeComputeInfo={type:"feature",map:new Map},await Promise.all(t.bindings.map(async a=>{const n=await this._bind(e,a);this._updateReferences(n)}));else{this._attributeComputeInfo={type:"multi",keyField:t.keyField,map:new Map};for(const a in t.bindings){const n=t.bindings[a];await Promise.all(n.map(async o=>{const c=await this._bind(e,o,parseInt(a,10));this._updateReferences(c)}))}}}setHighlight(t,e){let s=null;t.length===0&&e.length===0&&(s=this._getBlock(0),s.unsetComponentAllTexels(0,(1<<Ke)-1));for(const{displayId:r,highlightFlags:i}of t){if(r==null||r===-1)continue;s||(s=this._getBlock(0),s.unsetComponentAllTexels(0,(1<<Ke)-1));const a=Se(r);s.setComponent(0,i,[a])}this._idsToHighlight.clear();for(const{objectId:r,highlightFlags:i}of t)this._idsToHighlight.set(r,i);for(const{objectId:r,highlightFlags:i}of e)this._idsToHighlight.set(r,i)}setData(t,e,s,r){const i=Se(t);this._ensureSizeForTexel(i),this._getBlock(e).setData(t,s,r)}getData(t,e,s){return this._getBlock(e).getData(t,s)}getHighlightFlags(t){return this._idsToHighlight.get(t)||0}unsetAttributeData(t){const e=Se(t);this._getBlock(0).setData(e,0,0)}referencesScale(){const t=this._attributeComputeInfo;if(!t)return!1;if(t.type==="multi"){for(const e of t.map.values())for(const{field:s}of e.values())if(s?.hasArcadeDependency("scale"))return!0}else for(const{field:e}of t.map.values())if(e?.hasArcadeDependency("scale"))return!0;return!1}setAttributeData(t,e,s,r){const i=Se(t);this._ensureSizeForTexel(i),this._getBlock(0).setData(i,0,this.getFilterFlags(e,r));const a=this._attributeComputeInfo,n=1,o=4;let c=null;a&&(c=a.type==="multi"?a.map.get(e.readAttribute(a.keyField)):a.map,c?.size&&c.forEach((l,h)=>{const u=h*n%o,d=Math.floor(h*n/o),f=this._getBlock(d+3);let p=l.field?.read(e,s);l.valueRepresentation&&(p=Jh(p,l.valueRepresentation)),(p===null||isNaN(p)||p===1/0||p===-1/0)&&(p=Ac),f.setData(i,u,p)}))}get epoch(){return this._epoch}sendUpdates(){const t=this._blocks.map(s=>s!=null?s.toMessage():null),e=this._getInitArgs();v("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.start"),this._client.update({initArgs:e,blockData:t,version:this.version,sendUpdateEpoch:this._epoch}),this._epoch+=1,v("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.end")}_ensureSizeForTexel(t){for(;t>=this._size*this._size;)if(this._expand())return}async _bind(t,e,s){const r=await t.createComputedField(e),{valueRepresentation:i}=e,a=this._attributeComputeInfo;if(a.type==="multi"){const n=a.map.get(s)??new Map;n.set(e.binding,{field:r,valueRepresentation:i}),a.map.set(s,n)}else a.map.set(e.binding,{field:r,valueRepresentation:i});return r}_getInitArgs(){return this._initialized?null:(this._initialized=!0,this._getBlock(1),this._getBlock(2),this._getBlock(7),{blockSize:this._size,blockDescriptors:this._blocks.map(t=>t!=null?{textureOnly:t.textureOnly,buffer:t.buffer,pixelType:t.pixelType}:null)})}_getBlock(t){const e=this._blocks[t];if(e!=null)return e;Xt(`Initializing AttributeBlock at index ${t}`);const s=new tu(this._size,this._blockDescriptors[t],this._client.isLocal);return this._blocks[t]=s,this._initialized=!1,s}_expand(){if(this._size<this._schema.capabilities.maxTextureSize){const t=this._size<<=1;Xt("Expanding block size to",t,this._blocks);for(const e of this._blocks)e?.expand(t);return this._initialized=!1,this._size=t,0}return er().error(new P("mapview-limitations","Maximum number of onscreen features exceeded.")),-1}_updateReferences(t){ks(this._arcadeDependencies,t)}isVisible(t){return!!(this._getBlock(0).getData(t,0)&1<<Ke)}getFilterFlags(t,e){let s=0;for(let i=0;i<this._filters.length;i++){const a=!!(1<<i),n=this._filters[i];s|=(!a||n==null||n.check(t,e)?1:0)<<i}let r=0;if(this._idsToHighlight.size){const i=t.getObjectId();r=this.getHighlightFlags(i)}return s<<Ke|r}};class ru{constructor(e,s){this._connection=e,this._source=s,this._version=1,this._registry=new bh,this._proxy=new Fo({fetch:(r,i)=>this._connection.layerView.fetch(r,i),fetchDictionary:(r,i)=>this._connection.layerView.fetchDictionary(r,i)}),this._attributeStore=new su({isLocal:!1,update:r=>vs(this._connection.container.updateAttributeView(r))})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}get usedMemory(){let e=0;return e+=this._attributeStore.usedMemory,this._strategy&&(e+=this._strategy.usedMemory),e}get version(){return this._version}getDisplayFeatures(e){return this._strategy?this._strategy.getDisplayFeatures(e):{features:[],aggregates:[],tracks:[]}}getDisplayIds(e){const s={};return this._strategy&&this._strategy.displayMap(e,r=>r,(r,i,a)=>{s[a]=r}),s}getFeatureObjectIdsForAggregate(e){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(e):[]}onSubscribe(e){this._strategy?.onSubscribe(e)}onUnsubscribe(e){this._strategy?.onUnsubscribe(e)}requiresInvalidation(){return this._strategy?.requiresInvalidation()??!1}async update(e,s,r,i,a){const n=e.processor,o=Q(this._schema?.storage,n.storage),c=Q(this._schema?.mesh.properties,n.mesh.properties),l=Q(this._schema?.mesh.factory,n.mesh.factory),h=Q(this._schema?.mesh.strategy,n.mesh.strategy),u=iu(this._schema?.expressionProperties,n.expressionProperties),d=u.some(I=>this._attributeStore.hasArcadeDependency(I)),f=u.some(I=>this._factory?.hasArcadeDependency(I)??!1),p=u.some(I=>this._strategy?.hasArcadeDependency(I))||this._strategy?.isAggregate&&d,m=f||p,_=c||l||h;if(!(o||_||f||d||p)&&!i)return!1;v("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:ai(this._schema,n),schema:n}),this._schema=n;const g=new Rt({fields:this._source.metadata.fieldsIndex,spatialReference:this._source.metadata.outSpatialReference}),b={currentUser:n.mesh.properties.currentUser};if((o||_||d)&&(await this._attributeStore.update(n.storage,g,this._source.metadata,s),this._strategy?.invalidateAttributeData(De(n))),!i&&!_&&!m)return!1;(h||c||m)&&await this._updateStrategy(n.mesh.strategy,a,De(n),b),this._updateSortKey(g,"sortKey"in n.mesh.properties?n.mesh.properties.sortKey:null);const S=n.mesh.factory.symbology.type==="dictionary"?n.mesh.factory.symbology.fieldMap:null,x=new wh(g,this._proxy,r,this._registry,S);return(l||n.mesh.factory.symbology.type==="dictionary")&&(this._factory=await ko.create(x,n.mesh.factory)),this._version=s,!0}async applyOverrideUpdate(e){if(!this._strategy)return;const s=this._strategy.applyOverrideUpdate(e);for await(const r of s)try{await this._process(r)}catch{}}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(e){this._strategy?.removeChunks(e),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:e}){if(!this._strategy||!this._strategy.hasSubscribers)return void this._attributeStore.setHighlight(e.map(({objectId:r,highlightFlags:i})=>({objectId:r,highlightFlags:i,displayId:-1})),e);const s=this._strategy.displayMap(e,({objectId:r})=>r,(r,{highlightFlags:i},a)=>({objectId:a,displayId:r,highlightFlags:i}));this._attributeStore.setHighlight(s,e)}invalidate(){this._strategy&&this._strategy.invalidate()}async _doUpdateChunks(){if(!this._strategy)return;const e=this._strategy.updateChunks(),s=[],r=new Map;for await(const i of e){let a=r.get(i.id);a==null&&(a=new Ih({concurrency:16,process:o=>this._process(o)}),r.set(i.id,a));const n=a.push(i).catch(o=>ws(o));s.push(n)}try{await Promise.all(s)}catch{}v("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),v("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(e,s,r,i){switch(this._strategy?.destroy(),e.type){case"feature":this._strategy=new Nh(this._source,this._attributeStore,r,i);break;case"binning":this._strategy=await Rh.create(e,this._source,this._attributeStore,r,i);break;case"cluster":this._strategy=await Bh.create(this._connection,e,this._source,this._attributeStore,r,i);break;case"track":this._strategy=await Js.create(e,this._source,this._attributeStore,r,i)}for(const a of s)this._strategy.onSubscribe(a)}async _updateSortKey(e,s){if(this._sortInfo=vt(this._sortInfo?.computed),s!=null){const r=s.byRenderer?null:await e.createComputedField(s);this._sortInfo={...s,computed:r}}}async _process(e){const s=e.subscription;if(v("esri-2d-update-debug")){const l=s.tile;console.debug(`Version[${this._version}] Tile[${l.key.id}, end=${e.end}] Processor._process`)}const r={currentUser:this._schema?.mesh.properties.currentUser};await this._fetchResources(e,r),N(s.signal);const i=await this._write(e,s.tile.createArcadeEvaluationOptions(De(this._schema)),r),a=s.tile.tileInfoView.getLODInfoAt(s.tile.key);N(s.signal);const{message:n,transferList:o}=i.serialize(a),c={objectIdMap:null,inner:e.createMessage(n,this._version,this._attributeStore.epoch)};if(this._schema?.mesh.properties.returnMeshObjectId){c.objectIdMap={};const l=e.reader?.getCursor();if(l)for(;l.next();)c.objectIdMap[l.getDisplayId()]=l.getObjectId()}if(N(s.signal),await this._connection.container.onMessage(c,{signal:s.signal,transferList:o}),this._attributeStore.sendUpdates(),v("esri-2d-update-debug")){const l=s.tile;console.debug(`Version[${this._version}] Tile[${l.key.id}, end=${e.end}] Processor._process.await`)}}async _fetchResources(e,s){await this._fetchMatcherResources(e),await this._fetchWriterResources(e,s)}async _fetchMatcherResources(e){if(e.reader)return this._factory.enqueueMatcherRequests(this._proxy,e.reader)}async _fetchWriterResources(e,s){if(!e.reader)return;const r=e.reader.getCursor(),i=e.subscription.tile.createArcadeEvaluationOptions(De(this._schema));for(;r.next();)this._factory.enqueueWriterRequests(this._proxy,r,i,s);await this._proxy.fetchEnqueuedResources()}async _write(e,s,r){const i=e.subscription.tile,a=e.reader?.getCursor(),n=a?.getSize()??0,o=i.tileInfoView.tileInfo.isWrappable,c=i.tileInfoView.tileInfo.spatialReference.isWGS84,l=new _o(i.key,this._strategy.enablePixelBuffering,o,c,n);if(!a)return l;const h=i.createArcadeEvaluationOptions(De(this._schema));let u=0;for(;a.next();){++u%1e3||(await Ra(0),N(e.subscription));const d=this._getSortKeyValue(a,s);l.entityStart(a.getDisplayId(),d),this._factory.write(l,this._proxy,a,h,r,i.level),l.entityEnd()}return l}_getSortKeyValue(e,s){if(!this._sortInfo)return 0;const{computed:r,order:i,byRenderer:a}=this._sortInfo,n=a?this._factory.getSortKey(e,s):r?.read(e,s);return n==null||isNaN(n)?0:n*(i==="asc"?-1:1)}}function iu(t,e){const s=[];return t?.timeExtent?.start===e.timeExtent?.start&&t?.timeExtent?.end===e.timeExtent?.end||s.push("timeProperties"),s}function De(t){const{timeZone:e}=t?.mesh.properties??{},{timeExtent:s}=t?.expressionProperties??{};return{timeZone:e,timeExtent:s}}let au=class Ma{static from(e){let s=0,r=0,i=0;return e.forEach(a=>{const n=a._readGeometry();n&&(r+=n.isPoint?1:n.lengths.reduce((o,c)=>o+c,0),i+=n.isPoint?1:n.lengths.length,s+=1)}),new Ma(s,r,i)}constructor(e,s,r){this.featureCount=e,this.vertexCount=s,this.ringCount=r}toJSON(){return{featureCount:this.featureCount,ringCount:this.featureCount,vertexCount:this.featureCount}}};const nu=2500;let ut=class extends Is{constructor(t){super(),this._connection=t,this._enabledEventTypes=new Set,this._updateInfo={websocket:0,client:0},this._lastTime=performance.now(),this._queuedCommands=[],this.addHandles([ft(()=>this._strategy?.connectionStatus??"disconnected",e=>{this._layerView.setProperty({propertyName:"pipelineConnectionStatus",value:e})},{initial:!0}),ft(()=>this._strategy?.errorString||null,e=>this._layerView.setProperty({propertyName:"pipelineErrorString",value:e}),{initial:!0})])}destroy(){this._strategy=null,this.removeAllHandles()}get _layerView(){return this._connection.layerView}set strategy(t){this._strategy==null&&this._resetUpdateInfo(performance.now());const e="event-handles";this.removeHandles(e),t!=null&&(this.addHandles([t.events.on("data-received",s=>this._onFeature(s)),t.events.on("message-received",s=>this._onWebSocketMessage(s)),t.events.on("features-updated",s=>this._onUpdate(s)),t.events.on("tick",()=>this._onTick())],e),this._queuedCommands.forEach(s=>s(t)),this._queuedCommands=[]),this._strategy=t}updateCustomParameters(t){t!=null&&this._callOrEnqueue(e=>e.updateCustomParameters(t))}sendMessageToSocket(t){this._callOrEnqueue(e=>e.sendMessageToSocket(t))}sendMessageToClient(t){this._callOrEnqueue(e=>e.sendMessageToClient(t))}enableEvent(t,e){e?this._enabledEventTypes.add(t):this._enabledEventTypes.delete(t)}disconnect(){this._strategy?.disconnect()}connect(){this._strategy?.connect()}clear(){this._strategy?.clear()}_onWebSocketMessage(t){this._enabledEventTypes.has("message-received")&&this._layerView.emitEvent({name:"message-received",event:t})}_onFeature(t){this._updateInfo.websocket++,this._enabledEventTypes.has("data-received")&&this._layerView.emitEvent({name:"data-received",event:{attributes:t.attributes,centroid:t.centroid,geometry:t.geometry}})}_onUpdate(t){this._updateInfo.client+=t}_onTick(){const t=performance.now(),e=t-this._lastTime;if(e>nu){const s=Math.round(this._updateInfo.client/(e/1e3)),r=Math.round(this._updateInfo.websocket/(e/1e3));this._resetUpdateInfo(t),this._layerView.emitEvent({name:"update-rate",event:{client:s,websocket:r}})}}_resetUpdateInfo(t){this._lastTime=t,this._updateInfo.client=0,this._updateInfo.websocket=0}_callOrEnqueue(t){this._strategy!=null?t(this._strategy):this._queuedCommands.push(t)}};Z([ve()],ut.prototype,"_strategy",void 0),ut=Z([Ss("esri.views.2d.layers.features.sources.StreamMessenger")],ut);let ou=class{constructor(){this._requiresInvalidation=!1}get requiresInvalidation(){return this._requiresInvalidation}requireInvalidation(){this._requiresInvalidation=!0}};class Dt{constructor(e,s,r){this._context=r,this._controller=new AbortController,this.metadata=Mt.createFeature(e),this._schema=s}destroy(){this._controller.abort(),this.store.destroy()}get store(){return this._context.store}get _connection(){return this._context.connection}get _options(){return{signal:this._controller.signal}}get _signal(){return this._controller.signal}async applyOverride(e){this._onOverride(),await this.store.applyOverride(e)}takeOverrideUpdate(){return this.store.takeOverrideUpdate()}unsafeSetQueryHistoricMoment(e){throw new Error("InternalError: LoadStrategy does not support query info")}async queryByObjectId(e,s){throw new Error("InternalError: LoadStrategy does not support fetching")}prepareCacheUpdate(e,s){}applyCacheUpdate(){return null}}async function cu(t,e,s,r={}){const i=(await Promise.allSettled(s.map(a=>lu(t,e,a,r)))).filter(a=>a.status==="rejected").map(a=>a.reason);if(i.length)throw new P("featurelayer-query","Encountered errors when downloading data",{errors:i})}async function lu(t,e,s,r={}){const i=`${t.chunkPrefix??""}${s.num}`,a=await t.fetch(s.query,r,{chunkId:i}),n=new $e(a,s.query.inner.toJSON(),s.num,!1);n.chunkId=n.normalizedChunkId=i,N(r),e.insert(n)}const Qt=8e3;let hu=class{constructor(t,e,s,r){this.store=t,this.queryInfo=e,this._options=s,this._fetch=r,this._nextBatch=new Set,this._fetchFeatures=Ga(async()=>{if(this._nextBatch.size===0||this._options.signal?.aborted)return;const i=Array.from(this._nextBatch);this._nextBatch.clear(),i.length>Qt&&G.getLogger("esri.views.2d.layers.FeatureLayerView2D").warn(new P("highlight-too-many-features",`highlight is limited to ${Qt} features on large layers configured with a display filter to avoid performance issues`));const a=this.queryInfo.objectIdsQueryPageSize,n=Math.ceil(Qt/a),o=Math.min(n,Math.ceil(i.length/a)),c=Array.from({length:o},(l,h)=>{const u=h*a,d=Math.min(u+a,i.length);return{num:h,query:this.queryInfo.createObjectIdsQuery(i.slice(u,d))}});try{await cu({chunkPrefix:"cache."+Zn(),fetch:this._fetch},this.store,c,this._options)}catch{}})}prepareCacheUpdate(t,e){if(e)for(const s of e)this._nextBatch.delete(s);for(const s of t)this._nextBatch.add(s)}applyCacheUpdate(){return this._nextBatch.size===0||this._options.signal?.aborted?null:this._fetchFeatures().catch(()=>{})}};const Zt=4;function uu(t){switch(t.type){case"object-id":case"unique-id-simple":return`${t.fieldName} ASC`;case"unique-id-composite":return`${t.fieldNames.join(",")} ASC`}}function du(t,e,s){const r=uu(s.featureIdInfo);return{returnCentroid:s.serviceGeometryType==="esriGeometryPolygon"&&!t.queryMetadata.supportsCentroidOnDegeneratedQuantizedGeometry&&!t.queryMetadata.supportsDegeneratedQuantizedGeometry,returnGeometry:!0,timeReferenceUnknownClient:s.timeReferenceUnknownClient??void 0,outSpatialReference:Ts.fromJSON(t.outSpatialReference),orderByFields:t.type==="memory"?[]:[r],where:e.definitionExpression??"1=1",outFields:e.availableFields,multipatchOption:s.serviceGeometryType==="esriGeometryMultiPatch"?"xyFootprint":null,gdbVersion:e.gdbVersion,historicMoment:e.historicMoment?new Date(e.historicMoment):null,timeExtent:e.timeExtent?Jn.fromJSON(e.timeExtent):null}}let fu=class Ta{static create(e,s,r){const i=s.queryScaleRanges,a=s.displayFilterInfo;return new Ta(du(e,s,r),a,i,r.subtypeField,s.customParameters,r.geometryType,e.queryMetadata)}constructor(e,s,r,i,a,n,o){this._queryParams=e,this._displayFilter=s,this._queryScaleRanges=r,this._subtypeField=i,this._customParameters=a,this._geometryType=n,this._queryMetadata=o}get pageSize(){if(this._queryMetadata==null)throw new Error("InternalError: Service does not support paged queries");const e=this._queryMetadata.supportsMaxRecordCountFactor?Zt:null,s=(this._queryMetadata.maxRecordCount??8e3)*(e??1);return Math.min(8e3,s)}get objectIdsQueryPageSize(){return this._queryMetadata?.maxRecordCount??2e3}updateHistoricMoment(e){this._queryParams.historicMoment=e}updateFields(e){this._queryParams.outFields=e}createPatchFieldsQuery(e,s,r){if(!s.getSize())return null;const i=e.clone();if(this._queryParams.outFields[0]==="*"){if((i.outFields??[])[0]==="*")return null;i.outFields=this._queryParams.outFields}else{const n=new Set(this._queryParams.outFields),o=[];for(const c of n)s.hasField(c)||o.push(c);if(o.length===0)return null;i.outFields=o}i.returnGeometry=!1,i.returnCentroid=!1,i.quantizationParameters=null,i.cacheHint=!0;const a={inner:i,customParameters:this._customParameters};if(v("esri-tiles-debug")&&r!=null){const n=r.chunkId.toString().replaceAll("/",".");a.customParameters=a.customParameters?{...a.customParameters,chunkId:n}:{chunkId:n}}return a}createQuery(e={}){if(!this._queryParams)throw new Error("InternalError: queryInfo should be defined");return{inner:new Ps({...this._queryParams,...e}),customParameters:this._customParameters}}createTileQuery(e,s){if(this._queryMetadata==null)throw new Error("InternalError: Service does not support tile queries");const r=this.createQuery(s),i=r.inner;if(this._queryScaleRanges?.length){const a=this._queryScaleRanges.filter(n=>(!n.minScale||n.minScale>=e.maxScale)&&(!n.maxScale||n.maxScale<=e.minScale)).map(n=>n.subtypeCode);if(a.length){const n=`${this._subtypeField} IN (${a})`;i.where=_r(i.where,n)}}if(this._displayFilter&&(i.where=_r(i.where,Kn(this._displayFilter,e.minScale,e.maxScale))),i.quantizationParameters=s.quantizationParameters??e.getQuantizationParameters(),i.resultType="tile",i.geometry=e.extent,this._queryMetadata.supportsQuantization?this._geometryType==="esriGeometryPolyline"&&(i.maxAllowableOffset=e.resolution*v("feature-polyline-generalization-factor")):this._geometryType!=="esriGeometryPolyline"&&this._geometryType!=="esriGeometryPolygon"||(i.maxAllowableOffset=e.resolution,this._geometryType==="esriGeometryPolyline"&&(i.maxAllowableOffset*=v("feature-polyline-generalization-factor"))),i.defaultSpatialReferenceEnabled=this._queryMetadata.supportsDefaultSpatialReference,i.compactGeometryEnabled=this._queryMetadata.supportsCompactGeometry,this._queryMetadata.supportsMaxRecordCountFactor&&(i.maxRecordCountFactor=Zt),v("esri-tiles-debug")){const a=e.id.replaceAll("/",".");r.customParameters=r.customParameters?{...r.customParameters,tileId:a}:{tileId:a}}return r}createPagedTileQuery(e,s){const r=this.pageSize;return this.createTileQuery(e,{start:r*s,num:r,returnExceededLimitFeatures:!0})}createPagedQuery(e,s){const r=this.pageSize;return this.createQuery({start:r*e,num:r,returnExceededLimitFeatures:!0,maxRecordCountFactor:Zt,quantizationParameters:s,cacheHint:!0})}createObjectIdsQuery(e){return this.createQuery({objectIds:e,outFields:["*"]})}};const Fa=32,Kt=268435455;let pu=class{constructor(){this.hasFeatures=!1,this.exceededTransferLimit=!1,this.fieldCount=0,this.featureCount=0,this.idFieldIndices=[],this.vertexCount=0,this.offsets={attributes:new Array,geometry:new Array},this.centroid=new Array}get usedMemory(){let t=0;return t+=te(this.idFieldIndices),t+=te(this.offsets.attributes),t+=te(this.offsets.geometry),t+=te(this.centroid),this.displayIds&&(t+=te(this.displayIds)),this.groupIds&&(t+=te(this.groupIds)),t}};function mu(t,e,s,r=!1){const i=t.asUnsafe(),a=i.pos(),n=new pu;let o=0,c=0;const l=1,h=2,u=4,d=3;let f=null,p=!1;const m=[];for(;i.next();)switch(i.tag()){case 12:f=i.processMessage(io);break;case 9:if(n.exceededTransferLimit=i.getBool(),n.exceededTransferLimit){n.offsets.geometry=r?new Float64Array(8e3):new Int32Array(8e3),n.centroid=r?new Float64Array(16e3):new Int32Array(16e3);for(let g=0;g<n.centroid.length;g++)n.centroid[g]=Kt}break;case 13:{const g=i.processMessage(ro);g.index=o++,m.push(g);break}case 15:{const g=i.getLength(),b=i.pos()+g;if(!n.exceededTransferLimit){const x=n.offsets.geometry,I=n.centroid;x.push(0),I.push(Kt),I.push(Kt)}!p&&n.exceededTransferLimit&&(p=!0,n.offsets.attributes=r?new Float64Array(8e3*o):new Uint32Array(8e3*o));let S=c*o;for(;i.pos()<b&&i.next();)switch(i.tag()){case l:{p?n.offsets.attributes[S++]=i.pos():n.offsets.attributes.push(i.pos());const x=i.getLength();i.skipLen(x);break}case h:if(e){const x=i.getLength(),I=i.pos()+x;for(;i.pos()<I&&i.next();)if(i.tag()===d){i.getUInt32();const k=i.getSInt64(),M=i.getSInt64();n.centroid[2*c]=k,n.centroid[2*c+1]=M}else i.skip()}else{n.offsets.geometry[c]=i.pos();const x=i.getLength();n.vertexCount+=x,i.skipLen(x)}break;case u:{const x=i.getLength(),I=i.pos()+x;for(;i.pos()<I&&i.next();)if(i.tag()===d){i.getUInt32();const k=i.getSInt64(),M=i.getSInt64();n.centroid[2*c]=k,n.centroid[2*c+1]=M}else i.skip();break}default:i.skip()}c++,n.hasFeatures=!0;break}default:i.skip()}n.fields=new Xe(m),n.featureCount=c,n.fieldCount=o;const _=so(s);return n.idFieldIndices=Array.from(_,g=>n.fields.get(g)?.index),n.transform=f,n.displayIds=new Uint32Array(n.featureCount),n.groupIds=new Uint16Array(n.featureCount),i.move(a),n}const Xr=268435455,Qr=128,Zr=128e3,U={small:{delta:new Int32Array(Qr),decoded:new Int32Array(Qr)},small64:{delta:new Float64Array(0),decoded:new Float64Array(0)},large:{delta:new Int32Array(Zr),decoded:new Int32Array(Zr)},large64:{delta:new Float64Array(0),decoded:new Float64Array(0)}};function Kr(t,e){return e?t<=U.small64.delta.length?U.small64:(t<=U.large64.delta.length||(U.large64.delta=new Float64Array(Math.round(1.25*t)),U.large64.decoded=new Float64Array(Math.round(1.25*t))),U.large64):t<=U.small.delta.length?U.small:(t<=U.large.delta.length||(U.large.delta=new Int32Array(Math.round(1.25*t)),U.large.decoded=new Int32Array(Math.round(1.25*t))),U.large)}function _u(t){try{const e=new to(new Uint8Array(t),new DataView(t));for(;e.next();){if(e.tag()===2)return yu(e.getMessage());e.skip()}}catch(e){const s=new P("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:e});G.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(s)}return null}function yu(t){for(;t.next();){if(t.tag()===1)return t.getMessage();t.skip()}return null}function gu(t){const e=t.getLength(),s=t.pos()+e;for(;t.pos()<s&&t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getSInt32();case 5:return t.getUInt32();case 6:return t.getInt64();case 7:return t.getUInt64();case 8:return t.getSInt64();case 9:return t.getBool();default:return t.skip(),null}return null}function xu(t,e,s,r,i){return t?e*i-r*s===0&&e*r+s*i>0:!1}class It extends Bn{static fromBuffer(e,s,r=!1){const i=s.geometryType,a=_u(e),n=mu(a,i==="esriGeometryPoint",s.featureIdInfo,r);return new It(a,n,s,r)}constructor(e,s,r,i){super(r),this._use64Bit=i,this._hasNext=!1,this._isPoints=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0},this._parseCaches=new Array,this._geometryType=r.geometryType,this._reader=e,this._header=s,this._hasNext=s.hasFeatures,this._isPoints=r.geometryType==="esriGeometryPoint"}get _size(){return this._header.featureCount}get fields(){return this._header.fields}get geometryType(){return this._geometryType}get hasZ(){return!1}get hasM(){return!1}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getSize(){return this._size}getInTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex(e){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._featureIndex=e}getAttributeHash(){let e="";for(const s of this._header.fields.fields)e+=this._readAttributeAtIndex(s.index)+".";return e}getObjectId(){if(this._header.idFieldIndices.length===1)return this._readAttributeAtIndex(this._header.idFieldIndices[0]);const e=this._header.idFieldIndices.map(s=>this._readAttributeAtIndex(s));return JSON.stringify(e)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId(e){this._header.displayIds[this._featureIndex]=e}readGeometryArea(){return this._cache.area||this._readGeometry(!0),this._cache.area}copy(){const e=this._reader.clone(),s=new It(e,this._header,this.metadata,this._use64Bit);return this.copyInto(s),s}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0;++this._featureIndex<this._size&&!this._getExists(););return this._featureIndex<this._size}get usedMemory(){return Qn+(this._cache.geometry?.usedMemory??0)}get underlyingMemory(){return super.underlyingMemory+this._reader.usedMemory+this._header.usedMemory}_readX(){return this._header.centroid[2*this._featureIndex]}_readY(){return this._header.centroid[2*this._featureIndex+1]}_readServerCentroid(){const e=this._header.centroid[2*this._featureIndex],s=this._header.centroid[2*this._featureIndex+1];return e===Xr?null:new D([],[e,s])}_readGeometry(e=!1){if(this._cache.geometry===void 0){let s=null;if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===Xr)return null;const r=this._header.centroid[2*this._featureIndex],i=this._header.centroid[2*this._featureIndex+1];s=new D([],[r,i])}else{const r=this._header.offsets.geometry[this._featureIndex],i=this._reader;if(r===0)return null;i.move(r);try{s=e?this._parseGeometryForDisplay(i):this._parseGeometry(i)}catch{return null}}return s?.coords.length===0&&(s=null),this._cache.geometry=s,s}return this._cache.geometry}_readAttribute(e,s){const r=this._header.fields.get(e);if(r==null)return;const i=this._readAttributeAtIndex(r.index),a=this._header.fields.isDateField(r.name);return s?i==null?i:a?new Date(i):i:i}_readAttributes(){const e={};for(const s of this._header.fields.fields)e[s.name]=this._readAttributeAtIndex(s.index);return e}copyInto(e){super.copyInto(e),e._featureIndex=this._featureIndex,e._featureOffset=this._featureOffset,e._hasNext=this._hasNext,e._parseCaches=this._parseCaches}_readAttributeAtIndex(e){let s=this._parseCaches[e];if(s||(s=new qn(this.getSize()),this._parseCaches[e]=s),s.has(this._featureIndex))return s.get(this._featureIndex);const r=this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+e],i=this._reader;i.move(r);const a=gu(i);return s.set(this._featureIndex,a),a}_readGeometryDeltaDecoded(e=!1){if(this._cache.unquantGeometry===void 0){const s=this._readGeometry(e);if(!s)return this._cache.unquantGeometry=void 0,null;if(!this.getInTransform())return this._cache.unquantGeometry=s,s;const r=Kr(s.coords.length,this._use64Bit).decoded,i=s.clone(r),a=i.coords;let n=0;for(const o of i.lengths){for(let c=1;c<o;c++){const l=2*(n+c),h=2*(n+c-1);a[l]+=a[h],a[l+1]+=a[h+1]}n+=o}return this._cache.unquantGeometry=i,i}return this._cache.unquantGeometry}_parseGeometry(e){const s=e.asUnsafe(),r=s.getLength(),i=s.pos()+r,a=[],n=[];for(;s.pos()<i&&s.next();)switch(s.tag()){case 2:{const o=s.getUInt32(),c=s.pos()+o;for(;s.pos()<c;)n.push(s.getUInt32());break}case 3:{const o=s.getUInt32(),c=s.pos()+o;for(a.push(s.getSInt64()),a.push(s.getSInt64()),this.hasZ&&s.getSInt64(),this.hasM&&s.getSInt64();s.pos()<c;)a.push(s.getSInt64()),a.push(s.getSInt64()),this.hasZ&&s.getSInt64(),this.hasM&&s.getSInt64();break}default:s.skip()}return new D(n,a)}_parseGeometryForDisplay(e){const s=e.asUnsafe(),r=s.getLength(),i=s.pos()+r,a=[],n=[];let o=0,c=0,l=null,h=0;const u=this.geometryType==="esriGeometryPolygon",d=this.geometryType==="esriGeometryPolyline",f=u?3:d?2:1,p=u||d;for(;s.pos()<i&&s.next();)switch(s.tag()){case 2:{const m=s.getUInt32(),_=s.pos()+m;for(;s.pos()<_;){const g=s.getUInt32();a.push(g),o+=g}l=Kr(2*o,this._use64Bit).delta;break}case 3:{s.getUInt32();const m=2+(this.hasZ?1:0)+(this.hasM?1:0);ct(l);for(const _ of a){if(c+m*_>l.length){for(let x=0;x<_;x++)s.getSInt64(),s.getSInt64(),this.hasZ&&s.getSInt64(),this.hasM&&s.getSInt64();continue}let g=0,b=s.getSInt64(),S=s.getSInt64();this.hasZ&&s.getSInt64(),this.hasM&&s.getSInt64(),l[c++]=b,l[c++]=S,g+=1;for(let x=1;x<_;x++){const I=s.getSInt64(),k=s.getSInt64(),M=b+I,F=S+k;h+=-.5*(M-b)*(F+S),this.hasZ&&s.getSInt64(),this.hasM&&s.getSInt64(),I===0&&k===0||xu(p,l[c-2],l[c-1],I,k)?(l[c-2]+=I,l[c-1]+=k):(l[c++]=I,l[c++]=k,g+=1),b=M,S=F}g>=f?n.push(g):c-=g*m}break}default:s.skip()}return this._cache.area=h,n.length?new D(n,l):l!=null?this._createDeltaQuantizedExtrudedGeometry(l[0],l[1]):null}}let Lt=class{constructor(t,e){this.service=t,this._metadata=e}destroy(){}};function bu(t,e,s){switch(t.type){case"memory":return new Iu(t,e,s);case"ogc":return new ku(t,e);case"feature-service":return t.queryMetadata.supportsFormatPBF&&v("featurelayer-pbf")?new Su(t,e):new vu(t,e)}}async function wu(t){const e=new Ua;return await e.open(t,{}),e}class Iu extends Lt{constructor(e,s,r){super(e,s),this._ports=[],this._loaded=this._load(r)}destroy(){this._loaded.finally(()=>{this._client.close(),this._client=null;for(const e of this._ports)e.close()}).catch(()=>{})}async _load(e){this._ports=await e.layerView.openMemoryPorts(),this._client=await wu(this._ports)}async executeQuery(e,s){await this._loaded;const r=await this._client.invoke("queryFeatures",e.toJSON(),s);return E.fromFeatureSet(r,this._metadata)}}class Su extends Lt{async executeQuery(e,s){const{data:r}=await eo(this.service.source,e,s),i=!e.quantizationParameters;return It.fromBuffer(r,this._metadata,i)}}class vu extends Lt{async executeQuery(e,s){const{source:r,queryMetadata:i}=this.service;if(e.quantizationParameters!=null&&!i.supportsQuantization){const n=e.clone(),o=bi(n.quantizationParameters);n.quantizationParameters=null;const{data:c}=await br(r,n,this._metadata.spatialReference,s),l=gn(c,this._metadata.featureIdInfo);return di(o,l),E.fromOptimizedFeatureSet(l,this._metadata)}const{data:a}=await br(r,e,this._metadata.spatialReference,s);return this._metadata.geometryType==="esriGeometryPoint"&&(a.features=a.features?.filter(n=>{if(n.geometry!=null){const o=n.geometry;return Number.isFinite(o.x)&&Number.isFinite(o.y)}return!0})),E.fromFeatureSet(a,this._metadata)}}class ku extends Lt{async executeQuery(e,s){if(e.quantizationParameters&&!this.service.queryMetadata.supportsQuantization){const i=e.clone(),a=bi(i.quantizationParameters);i.quantizationParameters=null;const n=await xr(this.service.source,e,s);return di(a,n),E.fromOptimizedFeatureSet(n,this._metadata)}const r=await xr(this.service.source,e,s);return E.fromOptimizedFeatureSet(r,this._metadata)}}let Pa=class extends Dt{constructor(t,e,s){super(t.metadata,e,s),this._service=t,this._didApplyOverride=!1,this._queue=new Ms({concurrency:Fa,process:async r=>{const i={signal:r.options?.signal,query:r.query.customParameters,useRequestQueue:!0};return this._adapter.executeQuery(r.query.inner,i)}}),this._queryInfo=fu.create(t,{...e.full,...e.partial},this.metadata),this._adapter=bu(t,this.metadata,s.connection),this._lastEditDate=t.queryMetadata.lastEditDate}destroy(){super.destroy(),this._adapter.destroy()}unsafeSetQueryHistoricMoment(t){this._queryInfo.updateHistoricMoment(t)}async tryUpdate(t,e){if(Q(this.availableFields,e.availableFields)){if(this._didApplyOverride||await this._queryLastEditDateChanged())return!1;await this._updateFields(e.availableFields)}return this._schema.partial=e,!0}async queryByObjectId(t,e){if(t.length===0)return E.empty(this.metadata);const s=this._queryInfo.createQuery({objectIds:t});return s.inner.outFields=e,this._fetch(s,null,null)}get availableFields(){return this._schema.partial.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}_onOverride(){this._didApplyOverride=!0}async _updateFields(t){this._queryInfo.updateFields(t);const e=Array.from(this.store.chunks()).map(async r=>{const i=Ps.fromJSON(r.queryInfo.queryJSON);if(i)try{return await this._tryUpdateFields(r.reader,i,{chunkId:r.chunkId}),null}catch(a){return a}}),s=(await Promise.all(e)).filter(r=>r);if(s.length)throw new P("featurelayer-query","Encountered errors when downloading fields",{errors:s})}async _fetch(t,e,s){const r=await this._enqueue(t,e);return await this._tryUpdateFields(r,t.inner,s),r}async _queryLastEditDateChanged(){if(this._lastEditDate==null||!("source"in this._service))return!1;const t=this._service.source,e={...t.query,f:"json"},s=(await In(t.path,{query:e,responseType:"json"})).data.editingInfo.lastEditDate;return s!==this._lastEditDate&&(this._lastEditDate=s,!0)}async _tryUpdateFields(t,e,s){const r=this._queryInfo.createPatchFieldsQuery(e,t,s);if(!r)return;const i=await this._enqueue(r,this._options);i.getSize()===t.getSize()?t.joinAttributes(i):G.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new P("featurelayer-query",`Failed to join features. Expected a count of ${t.getSize()} features, but got ${i.getSize()}`,{query:r.inner.toJSON(),debugInfo:s}))}async _enqueue(t,e){return this._connection.onEvent({type:"fetchStart"}),this._queue.push({query:t,options:e}).finally(()=>{this._connection.onEvent({type:"fetchEnd",done:this._queue.length===0})})}},Ca=class extends Pa{constructor(t,e,s){super(t,e,s),this._chunksById=new Map,this._featureCache=new hu(this.store,this._queryInfo,this._options,this._fetch.bind(this))}prepareCacheUpdate(t,e){return this._featureCache.prepareCacheUpdate(t,e)}applyCacheUpdate(){return this._featureCache.applyCacheUpdate()}unload(t){this._removeChunks(t.tile)}_addChunk(t){const e=t.tile.id;this._chunksById.has(e)||this._chunksById.set(e,[]);const s=t.size();(s||t.first||t.end)&&(v("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] ATileLoadStrategy.addChunk [count=${s}]`),this._chunksById.get(e).push(t),this.store.insert(t))}_removeChunks(t){const e=this._chunksById.get(t.key.id)??[];for(const s of e)v("esri-2d-update-debug")&&console.debug(`Tile[${t.key.id}] Chunk[${s.chunkId}] ATileLoadStrategy.removeChunk`),this.store.remove(s);this._chunksById.delete(t.key.id)}},Jr=class extends Tt{constructor(t,e,s,r,i,a){super(),this._reader=t,this._queryJSON=e,this._tile=s,this._sourceTile=r,this._sourceTileDepth=i,this._end=a,this.chunkId=`${this._tile.key.id}.${this._sourceTile?.key.id}${this._end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._sourceTile?.key.normalizedId}${this._end?"e":""}`}get queryInfo(){return{type:"drill-down-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,sourceTileDepth:this._sourceTileDepth,sourceTileId:this._sourceTile?.key.id,size:this.size(),end:this.end}}get first(){return this._sourceTileDepth===0}get reader(){return this._reader}get end(){return this._end}get tile(){return this._tile}get isTiled(){return!0}getTileReader(t){return this._tile.key.id===t.key.id?this.reader:null}};const Mu=v("featurelayer-query-max-depth");let Tu=class{constructor(t,e){this.subscription=t,this._tileIdToResult=new Map,this._controller=new AbortController,this._handles=St([dt(t.signal,()=>this._controller.abort()),dt(e,()=>this._controller.abort())])}destroy(){this._controller.abort(),this._handles.remove()}get(t){return this._tileIdToResult.get(t)}set(t,e){this._tileIdToResult.set(t,e)}get options(){return{signal:this._controller.signal}}},Fu=class extends Ca{constructor(){super(...arguments),this._loadStates=new Map}destroy(){super.destroy();for(const t of this._loadStates.values())t.destroy();this._loadStates.clear()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load(t){this._loadStates.has(t.key.id)||this._loadStates.set(t.key.id,new Tu(t,this._options));const e=this._loadStates.get(t.key.id);let s;try{for await(const i of this._fetchChunkInfos(e,t.tile,0)){const{queryJSON:a,reader:n,sourceTile:o,sourceTileDepth:c,tile:l}=i,h=new Jr(n,a,l,o,c,!1);N(e.options),this._addChunk(h)}}catch(i){s=i}N(e.options);const r=new Jr(E.empty(this.metadata),null,t.tile,null,-1,!0);if(this._addChunk(r),s)throw s}unload(t){super.unload(t),this._loadStates.get(t.key.id)?.destroy(),this._loadStates.delete(t.key.id)}async*_fetchChunkInfos(t,e,s){let r=t.get(e.id);const i=!!r;if(r||(r=await this._fetchChunkInfo(t,e,s),t.set(e.id,r)),r.reader.exceededTransferLimit&&s<v("featurelayer-query-max-depth"))for(const a of e.createChildTiles())yield*this._fetchChunkInfos(t,a,s+1);else i||(yield r)}async _fetchChunkInfo(t,e,s){const r=t.subscription.tile.getQuantizationParameters(),i=this._queryInfo.createTileQuery(e,{returnExceededLimitFeatures:s===Mu,quantizationParameters:r});return{reader:await this._fetch(i,t.options,{chunkId:e.id}),queryJSON:i.inner.toJSON(),tile:t.subscription.tile,sourceTile:e,sourceTileDepth:s}}},ei=class extends Tt{constructor(t,e,s,r,i){super(),this._reader=t,this._queryJSON=e,this._tile=s,this._page=r,this._end=i,this.chunkId=`${this._tile.key.id}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._page}${this.end?"e":""}`}get queryInfo(){return{type:"paged-tile",chunkId:this.chunkId,tileId:this._tile.key.id,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get reader(){return this._reader}get first(){return this._page===0}get end(){return this._end}get page(){return this._page}get tile(){return this._tile}get isTiled(){return!0}getTileReader(t){return this._tile.key.id===t.key.id?this.reader:null}};class Pu{constructor(e,s){this.subscription=e,this._pages=new Set,this._controller=new AbortController,this._done=!1,this._handles=St([dt(e.signal,()=>this._controller.abort()),dt(s,()=>this._controller.abort())])}destroy(){this._controller.abort(),this._handles.remove()}get pageStart(){let e=-1;for(const s of this._pages.values())e=Math.max(e,s);return e+1}get done(){return this._done}get options(){return{signal:this._controller.signal}}add(e,s){this._pages.add(e),this._done=this._done||s}}class Cu extends Ca{constructor(){super(...arguments),this._loadStates=new Map}destroy(){super.destroy();for(const e of this._loadStates.values())e.destroy();this._loadStates.clear()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}async load(e){const s=La(this._loadStates,e.key.id,()=>new Pu(e,this._options));for await(const r of this._fetchPages(s))this._addChunk(r)}unload(e){super.unload(e),this._loadStates.get(e.key.id)?.destroy(),this._loadStates.delete(e.key.id)}async*_fetchPages(e){let s;try{for await(const r of this._concurrentPageStream(e))N(e.options),r.size()!==0&&(yield r)}catch(r){s=r}if(s&&si(s)||(yield new ei(E.empty(this.metadata),null,e.subscription.tile,-1,!0)),s)throw s}async*_concurrentPageStream(e){const s=v("featurelayer-query-tile-concurrency"),r=this._pageStreamAll(e),i=[];let a=!1,n=1;for(;!a;){const o=[];for(;!a&&i.length<n;){const c=r.next();if(!c.value){a=!0;break}const l=c.value;l.then(h=>{h.reader.exceededTransferLimit||(a=!0)}).catch(h=>{a=!0}).finally(()=>{i.splice(i.indexOf(l),1)}),i.push(l),o.push(l)}for(const c of o)yield c;i.length&&await Promise.race(i),n<s&&(n+=1)}}*_pageStreamAll(e){const s=Math.ceil(v("featurelayer-query-tile-max-features")/this._queryInfo.pageSize);for(let r=0;r<s;r++)yield this._downloadPage(r,e)}async _downloadPage(e,s){N(s.options);const r=s.subscription.tile,i=this._queryInfo.createPagedTileQuery(r,e),a=await this._fetch(i,s.options,{chunkId:`${r.id}-${e}`});return N(s.options),new ei(a,i.inner.toJSON(),r,e,!1)}}let Au=class extends Pa{constructor(t,e,s){super(t,e,s)}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}load(t){return this._promise==null&&(this._promise=this._download()),this._promise}unload(t){}async _download(){const t=this._schema.snapshotInfo.initialTolerance,e=t?new xi({mode:"view",originPosition:"upper-left",tolerance:t}):null;await this._downloadStreaming(e),e!=null&&await this._downloadRefresh()}async _downloadStreaming(t){try{for await(const e of this._fetchPages(t))this.store.insert(e)}catch(e){throw new P("featurelayer-query","Encountered error when downloading data",{error:e})}}async _downloadRefresh(){try{const t=[];for await(const e of this._fetchPages(null))t.push(e);this.store.clear();for(const e of t)this.store.insert(e);this.store.refresh()}catch(t){throw new P("featurelayer-query","Encountered error when downloading data",{error:t})}}async*_fetchPages(t){let e;try{for await(const s of this._concurrentPageStream(t))s.size()!==0&&(yield s)}catch(s){e=s}if(e&&si(e)||(yield new $e(E.empty(this.metadata),null,-1,!0)),e)throw e}async*_concurrentPageStream(t){const e=v("featurelayer-snapshot-concurrency"),s=this._pageStreamAll(t),r=[];let i=!1,a=1;for(;!i;){const n=[];for(;!i&&r.length<a;){const o=s.next();if(!o.value){i=!0;break}const c=o.value;c.then(l=>{l.reader.exceededTransferLimit||(i=!0)}).catch(l=>{i=!0}).finally(()=>{r.splice(r.indexOf(c),1)}),r.push(c),n.push(c)}for(const o of n)yield o;r.length&&await Promise.race(r),a<e&&(a+=1)}}*_pageStreamAll(t){const e=Math.ceil(this._schema.snapshotInfo.maxFeatureCount/this._queryInfo.pageSize);for(let s=0;s<e;s++)yield this._downloadPage(s,t)}async _downloadPage(t,e){N(this._options);const s=this._queryInfo.createPagedQuery(t,e),r=await this._fetch(s,this._options,{chunkId:t.toString()}),i=new $e(r,s.inner.toJSON(),t,!1);return N(this._options),i}};class Eu extends Dt{constructor(e,s,r){super(e.metadata,s,r),this._service=e,this._chunkId=0,this._files=new Map}destroy(){super.destroy();for(const e of this._files.values())e.free();this._files.clear()}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}get availableFields(){return this._schema.partial.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}async tryUpdate(e,s){if(Q(this.availableFields,s.availableFields)&&await this._updateFields(s.availableFields),Q(this._schema.partial.urls,s.urls)){for(const r of s.urls)this._files.has(r)||await this._insert(r);for(const r of this._files.keys())if(!s.urls.includes(r))throw new P("unsupported","Removing parquet files is not supported",{previous:this._schema.partial.urls,next:s.urls})}return this._schema.partial=s,!0}async load(e){return this._promise==null&&(this._promise=this._download()),this._promise}unload(e){}_onOverride(){}async _updateFields(e){await this._promise;const s=new Set(e),r=ri(s,new Set(this.availableFields)),i=this._fieldsIndex;if(i==null)return;const a=Array.from(r).map(n=>i.get(n)?.column);if(r.size)for(const n of this._files.values())await n.ensureFields(new Uint32Array(a))}async _insert(e){const s=await wi(e,{geometryInfo:this._service.geometryInfo,outSpatialReference:this._service.outSpatialReference,getCustomParameters:()=>this._schema.full.customParameters}),r=this._files.size;this._files.set(e,s),N(this._options);const i=s.fields().map(c=>({name:c.name,alias:c.name,type:c.type,column:s.columnForFieldName(c.name)})),{timeZoneByFieldName:a}=this._service.metadata.fieldsIndex,n=Xe.fromJSON({fields:i,timeZoneByFieldName:a});this._fieldsIndex=n;const o=new Uint32Array(Array.from(this.availableFields.values()).map(c=>n.get(c)?.column).filter(c=>c!=null));await s.readAllChunks(o,this._signal,c=>{if(this._signal.aborted)return;const l=this._chunkId++,h=new is(this.metadata,n,c,l,r),u=new $e(h,null,l,!1);this.store.insert(u)})}async _download(){try{await Promise.all(this._schema.partial.urls.map(s=>this._insert(s)));const e=new $e(E.empty(this.metadata),null,-1,!0);this.store.insert(e)}catch(e){throw console.error(e),e}}}class Jt extends Tt{constructor(e,s,r,i,a){super(),this._metadata=e,this._reader=s,this._tile=r,this._page=i,this._end=a,this.chunkId=`${this._tile.key.id}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=`${this._tile.key.normalizedId}.${this._page}${this.end?"e":""}`}get reader(){return this._reader??E.empty(this._metadata)}get first(){return this._page===0}get end(){return this._end}get tile(){return this._tile}get queryInfo(){return{type:"parquet",chunkId:this.chunkId,queryJSON:null,page:this._page,size:this.size(),tileId:this._tile.id,end:this.end}}get isTiled(){return!0}getTileReader(e){if(this._tile.key.id===e.key.id){const s=[];for(let i=0;i<this.reader.getSize();i++)s.push(i);const r=mi.from(this.reader,s);return r.setTransformForDisplay(e.transform),r}return null}}let Ou=class extends Dt{constructor(t,e,s){if(super(t.metadata,e,s),this._files=[],!t.geometryInfo.displayOptimization)throw new Error("InternalError: ParquetTileLoadStrategy only supports XZ-enabled parquet files");this._index=Ru.create(e.partial.urls,this.metadata,t,new Set(e.partial.availableFields),this.store,()=>e.full.customParameters)}destroy(){super.destroy();for(const t of this._files)t.free()}get about(){return{willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}get availableFields(){return this._schema.partial.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}async tryUpdate(t,e){return Q(this.availableFields,e.availableFields)&&await this._updateFields(e.availableFields),this._schema.partial=e,!0}async load(t){await(await this._index).ensureLoaded(t)}unload(t){this._index.then(e=>e.unload(t.tile))}_onOverride(){}async _updateFields(t){return(await this._index).updateFields(t)}},Ru=class Aa{static async create(e,s,r,i,a,n){const o=await Promise.all(e.map(p=>wi(p,{geometryInfo:r.geometryInfo,outSpatialReference:r.outSpatialReference,getCustomParameters:n})));if(o.length!==1)throw new Error("InternalError: experimental parquet XZ display optimization only supports a single file.");const[c]=o,l=c.fields().map(p=>({name:p.name,alias:p.name,type:p.type,column:c.columnForFieldName(p.name)})),{timeZoneByFieldName:h}=r.metadata.fieldsIndex,u=Xe.fromJSON({fields:l,timeZoneByFieldName:h}),d=new Uint32Array(Array.from(i.values()).map(p=>u.get(p)?.column).filter(p=>p!=null)),f=r.geometryInfo.displayOptimization;if(!f)throw new Error("InternalError: tiled parquet load requires display optimization");return new Aa(s,await Promise.all(o),u,d,a,i,f)}constructor(e,s,r,i,a,n,o){this._metadata=e,this._files=s,this._fieldsIndex=r,this._fieldIndices=i,this._store=a,this._availableFields=n,this._displayOptimization=o,this.fileIndex=0,this._queue=new Ms({concurrency:Fa,process:c=>this._ensureLoaded(c)}),this._tileIdToChunkId=new Map}get file(){return this._files[0]}async ensureLoaded(e){return this._queue.push(e)}unload(e){const s=this._tileIdToChunkId.get(e.id);if(s!=null){for(const r of s)this._store.removeById(r);this._tileIdToChunkId.delete(e.id)}}async _ensureLoaded(e){const s=this._metadata.outSpatialReference,r=e.tile,{xmin:i,ymin:a,xmax:n,ymax:o}=zu(r.extent,s);let c=0;const l={extent:r.extent,extent_lat_lng:{xmin:i,ymin:a,xmax:n,ymax:o},tile_level:r.level,attributes:this._fieldIndices};if(this._displayOptimization.mode==="z"?await this.file.queryZChunks(l.extent_lat_lng,this._fieldIndices,e.signal,u=>{if(e.signal.aborted)return;const d=new is(this._metadata,this._fieldsIndex,u,c,this.fileIndex),f=new Jt(this._metadata,d,r,c++,!1);this._insertChunk(r,f)}):await this.file.queryXZChunks(l,e.signal,u=>{if(e.signal.aborted)return;const d=new is(this._metadata,this._fieldsIndex,u,c,this.fileIndex),f=new Jt(this._metadata,d,r,c++,!1);this._insertChunk(r,f)}),e.signal.aborted)return;const h=new Jt(this._metadata,null,r,c++,!0);this._insertChunk(r,h)}_insertChunk(e,s){let r=this._tileIdToChunkId.get(e.id);r==null&&(r=[],this._tileIdToChunkId.set(e.id,r)),r.push(s.chunkId),this._store.insert(s)}async updateFields(e){const s=new Set(e),r=ri(s,this._availableFields);if(this._availableFields=Ba(r,this._availableFields),r.size)for(const i of this._files){const a=Array.from(r).map(n=>this._fieldsIndex.get(n)?.column);await i.ensureFields(new Uint32Array(a))}}};function zu(t,e){const s=[t.xmin,t.ymin,t.xmax,t.ymax],r=nn.fromExtent(yi(s,e)),i=kn(r,e,Ts.WGS84);if(!i)return null;const a=yn(new D,i,!1,!1),n=a.coords.filter((c,l)=>!(l%2)),o=a.coords.filter((c,l)=>l%2);return{xmin:Math.min(...n),ymin:Math.min(...o),xmax:Math.max(...n),ymax:Math.max(...o)}}let be=class extends Is{constructor(t){super(t)}get connectionStatus(){return this.connection?.connectionStatus}get errorString(){return this.connection?.errorString}};Z([ve()],be.prototype,"connection",void 0),Z([ve()],be.prototype,"connectionStatus",null),Z([ve()],be.prototype,"errorString",null),be=Z([Ss("esri.views.2d.layers.features.sources.StreamConnectionState")],be);let Du=class{constructor(t,e){this._metadata=t,this._onUpdate=e,this._objectIdToFeature=new Map}get size(){return this._objectIdToFeature.size}get reader(){return E.fromFeatures([...this._objectIdToFeature.values()],this._metadata)}add(t){this._objectIdToFeature.set(t.objectId,t)}forEach(t){this._objectIdToFeature.forEach(t)}removeById(t){const e=this._objectIdToFeature.get(t);return e?(this._objectIdToFeature.delete(t),e):null}clear(){this._objectIdToFeature=new Map}update(t,e){this._onUpdate(t?.length??0)}},Lu=class extends Tt{constructor(t){super(),this._reader=t,this.chunkId="stream-chunk",this.normalizedChunkId="stream-chunk"}get reader(){return this._reader}get first(){return!0}get end(){return!0}get queryInfo(){return{type:"stream",chunkId:this.chunkId,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(t){const e=this.queryFeaturesInBounds(t.bounds);return e.setTransformForDisplay(t.transform),e}},Bu=class extends Dt{constructor(t,e,s){super(t.metadata,e,s),this._service=t,this._connectionState=new be,this._forceRefresh=!1,this.events=new ii;const{timeInfo:r}=this.metadata,{purgeOptions:i}=e.full;this._stagingStore=new Du(this.metadata.weakCloneWithAdditionalFields([{name:ni,alias:"timeReceived",type:"esriFieldTypeDate"}]),a=>this.events.emit("features-updated",a)),this._manager=new ao(this._stagingStore,this.metadata.featureIdInfo,r,i),this.connect()}destroy(){super.destroy(),this.disconnect()}get about(){return{willQueryAllFeatures:!1,willQueryFullResolutionGeometry:!1}}get connectionStatus(){return this._connectionState.connectionStatus}get errorString(){return this._connectionState?.errorString}get availableFields(){return this._schema.full.availableFields}get definitionExpression(){return this._schema.full.definitionExpression}async tryUpdate(t,e){const s=this._chunk!=null;if(e.sourceRefreshVersion!==this._refreshVersion){if(this._refreshVersion=e.sourceRefreshVersion,!this._manager.checkForUpdates()&&s&&!this._forceRefresh)return this.events.emit("tick"),!0;this._chunk&&(this.store.remove(this._chunk),t.requireInvalidation()),this._forceRefresh=!1,this._chunk=new Lu(this._stagingStore.reader),this.store.insert(this._chunk),this.events.emit("tick")}return this._schema.partial=e,!0}async load(t){}unload(t){}disconnect(){this._streamConnection=vt(this._streamConnection),this._connectionState.connection=null,this._handlesGroup?.remove()}connect(){if(this._streamConnection!=null)return;const{geometryType:t,spatialReference:e}=this.metadata,{maxReconnectionAttempts:s,maxReconnectionInterval:r,geometryDefinition:i,definitionExpression:a,customParameters:n}=this._schema.full;this._streamConnection=no(this._service.source,e,this._service.outSpatialReference,t,a,i,s,r,n),this._handlesGroup=St([this._streamConnection.on("data-received",o=>this._onFeature(o)),this._streamConnection.on("message-received",o=>this._onWebSocketMessage(o))]),this._connectionState.connection=this._streamConnection}clear(){this._manager.checkForUpdates(),this._stagingStore.clear(),this._forceRefresh=!0}updateCustomParameters(t){this._streamConnection?.updateCustomParameters(t)}sendMessageToSocket(t){this._streamConnection?.sendMessageToSocket(t)}sendMessageToClient(t){this._streamConnection?.sendMessageToClient(t)}_onOverride(){}_onWebSocketMessage(t){if("type"in t)switch(t.type){case"delete":if(t.objectIds)for(const e of t.objectIds)this._manager.removeById(e);if(t.trackIds)for(const e of t.trackIds)this._manager.removeByTrackId(e);break;case"clear":this.clear()}this.events.emit("message-received",t)}_onFeature(t){try{this._manager.add(t),this.events.emit("data-received",t)}catch{}}},Ne=class extends Is{constructor(t){super(t),this.debugName="",this._updatingHandles=new co,this._idToUpdatingState=new oo}destroy(){this._updatingHandles=vt(this._updatingHandles),this._idToUpdatingState.clear()}get updating(){const t=!this.destroyed&&(this._updatingHandles?.updating||Array.from(this._idToUpdatingState.values()).some(e=>e));if(v("esri-2d-log-updating")){const e=Array.from(this._idToUpdatingState.entries()).map(([s,r])=>`-> ${s}: ${r}`).join(`
`);console.log(`${this.debugName}: Updating: ${t}
-> Handles: ${this._updatingHandles.updating}
${e}`)}return t}addUpdateTracking(t,e){const s=ft(()=>e.updating,r=>this._idToUpdatingState.set(t,r),{sync:!0});this.addHandles(s)}addPromise(t){return this._updatingHandles.addPromise(t)}};Z([ve({constructOnly:!0})],Ne.prototype,"debugName",void 0),Z([ve({readOnly:!0})],Ne.prototype,"updating",null),Ne=Z([Ss("esri.views.2d.layers.support.UpdateTracking2D")],Ne);class qu{constructor(e,s,r,i){this._aggregateAdapter=e,this._subscriptions=s,this._connection=r,this._cachedObjectIds=i,this._updateTracking=new Ne({debugName:"FeatureSource"}),this.store=new An}destroy(){this._strategy?.destroy(),this._streamMessenger?.destroy(),this._updateTracking?.destroy(),this.store.destroy()}get metadata(){return this._strategy.metadata}get streamMessenger(){return this._streamMessenger==null&&this._initStreamMessenger(),this._streamMessenger}get statistics(){return au.from(this.store)}get updateTracking(){return this._updateTracking}get usedMemory(){return this.store.usedMemory}get queryEngine(){if(!this._queryEngine){if(!this.store||!this._strategy)return null;this._queryEngine=new pi({featureStore:this.store,fieldsIndex:this.metadata.fieldsIndex,geometryType:this.metadata.geometryType,featureIdInfo:this.metadata.featureIdInfo,hasM:!1,hasZ:!1,spatialReference:this.metadata.outSpatialReference,aggregateAdapter:this._aggregateAdapter,timeInfo:this.metadata.timeInfo,definitionExpression:this._strategy?.definitionExpression,availableFields:this._strategy?.availableFields})}return this._queryEngine}get isStream(){return this._schema.type==="stream"}get hasQueryDisplayFilter(){if(!this._schema)return!1;switch(this._schema.type){case"feature":return this._schema.strategy.full.displayFilterInfo!=null;case"parquet":case"stream":return!1}}chunks(){return Array.from(this.store.chunks())}prepareCacheUpdate(e,s){const r=new Set,i=new Set;for(const a of e)this._cachedObjectIds.has(a)||(this._cachedObjectIds.add(a),r.add(a));for(const a of s)this._cachedObjectIds.delete(a),i.add(a);this.hasQueryDisplayFilter&&this._strategy.prepareCacheUpdate(r,i)}async applyCacheUpdate(){this.hasQueryDisplayFilter&&await this._updateTracking.addPromise(this._strategy.applyCacheUpdate())}cleanup(){return this.store.cleanup()}onSubscribe(e){if(this._connection.onEvent({type:"subscribe",tile:e.tile.id}),!this._strategy)return;const s=this._strategy.load(e);s.then(()=>this._connection.onEvent({type:"loaded",tile:e.tile.id})).catch(r=>this._connection.onEvent({type:"error",tile:e.tile.id,error:r})),this._updateTracking.addPromise(s)}onResume(e){this._updateTracking.addPromise(ti(this._strategy?.load(e)))}onUnsubscribe(e){this._connection.onEvent({type:"unsubscribe",tile:e.tile.id}),this._strategy?.unload(e)}async applyOverride(e){await this._strategy?.applyOverride(e)}takeOverrideUpdate(){return this._strategy?.takeOverrideUpdate()}async update(e,s){const r=this._schema;if(this._schema=e,this._queryEngine=vt(this._queryEngine),r&&r.type!==e.type)throw new Error("InternalError: Reconfiguring source types is not supported.");const i=new ou;return!r||Q(r.service,e.service)||r.strategy.type!==e.strategy.type||Q(e.strategy.full,r.strategy.full)||!await this._strategy.tryUpdate(i,e.strategy.partial)?(await this._updateStrategyType(this._schema.service,e,s),await this.store.update({metadata:this.metadata,definitionExpression:this._schema.strategy.full.definitionExpression}),!0):i.requiresInvalidation}unsafeSetQueryHistoricMoment(e){this._schema.type==="feature"&&(this._schema.strategy.full.historicMoment=e,this._strategy.unsafeSetQueryHistoricMoment(new Date(e)))}_initStreamMessenger(){this._streamMessenger==null&&(this._streamMessenger=new ut(this._connection))}async normalizeOverrides(e){const s={historicMoment:e.historicMoment,commands:{updateWeak:e.commands.updateWeak.map(Y.fromJSON),removeWeak:e.commands.removeWeak,update:e.commands.update.map(Y.fromJSON),remove:e.commands.remove,release:e.commands.release}},r=e.commands.updateByIdWeak,i=await this._queryOptimizedFeatures(r);if(i.length!==r.length){const a=new Set(i.map(n=>n.objectId));for(const n of r)a.has(n)||s.commands.removeWeak.push(n)}return s.commands.updateWeak.push(...i),s}async _queryOptimizedFeatures(e){if(e.length===0)return[];const s=[],r=(await this._strategy.queryByObjectId(e,["*"])).getCursor();for(;r.next();)s.push(r.readOptimizedFeatureWorldSpace());return s}getObjectIdsFromGlobalIds(e){const s=this.metadata.globalIdField;if(s==null)throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");const r=this.store.mapObjectIdsFromGlobalIds(e,s).values();return Array.from(r)}async _updateStrategyType(e,s,r){const i=this._createStrategy(e,s);this._connection.onEvent({type:"updateStrategyStart",about:i.about});const a=!!this._strategy;this.store.clear(),this._strategy?.destroy(),this._strategy=i,v("esri-2d-update-debug")&&console.debug(`Version[${r}] FeatureSource.updateStrategy`,{strategy:i});const n=Array.from(this._subscriptions.values());if(!n.length)return void this._connection.onEvent({type:"updateStrategyEnd"});const o=Promise.all(n.map(c=>this._strategy.load(c).then(()=>this._connection.onEvent({type:"loaded",tile:c.tile.id})).catch(l=>this._connection.onEvent({type:"error",tile:c.tile.id,error:l}))));this._updateTracking.addPromise(o),this._strategy.prepareCacheUpdate(this._cachedObjectIds);try{a&&await o}catch(c){ws(c)}this._connection.onEvent({type:"updateStrategyEnd"}),v("esri-2d-update-debug")&&console.debug(`Version[${r}] FeatureSource.updateStrategyEnd`,{strategy:i})}_createStrategy(e,s){const r={connection:this._connection,store:this.store};switch(s.type){case"feature":return this._createFeatureLoadStrategy(e,s.strategy,r);case"parquet":return this._createParquetLoadStrategy(e,s.strategy,r);case"stream":return this._createStreamLoadStrategy(e,s.strategy,r)}}_createFeatureLoadStrategy(e,s,r){switch(s.type){case"drill-down":return new Fu(e,s,r);case"paged-tile":return new Cu(e,s,r);case"snapshot":return new Au(e,s,r)}}_createParquetLoadStrategy(e,s,r){switch(s.type){case"xz":return new Ou(e,s,r);case"snapshot":return new Eu(e,s,r)}}_createStreamLoadStrategy(e,s,r){const i=new Bu(e,s,r);return this.streamMessenger.strategy=i,i}}class Nu{constructor(e,s){this.tile=e,this.version=s,this._abortController=new AbortController}get key(){return this.tile.key}get signal(){return this._abortController.signal}abort(){this._abortController.abort()}}class tr{constructor(e,s){this.key=new kt(0,0,0,0),this.bounds=_i(),this.objectIds=new Set,this.key.set(s);const r=e.getLODInfoAt(this.key);this.tileInfoView=e,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=r.resolution,this.level=r.level,this.scale=r.scale,this.minScale=e.zoomToScale(r.level-1),this.maxScale=e.zoomToScale(r.level+1)}get lod(){return this.tileInfoView.getLODInfoAt(this.key)}get id(){return this.key.id}get extent(){return yi(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createArcadeEvaluationOptions(e){return Fs(this.scale,e)}createChildTiles(){const e=this.key.getChildKeys(),s=Da.acquire();for(let r=0;r<e.length;r++)s[r]=new tr(this.tileInfoView,e[r]);return s}getQuantizationParameters(){return xi.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}class ot{constructor(e){this.inner=e,this.resolver=za()}}class ep{constructor(){this._aggregateAdapter={getFeatureObjectIds:e=>this._processor.getFeatureObjectIdsForAggregate(e)},this._subscriptions=new Map,this._cachedObjectIds=new Set,this._updateRequested=!1,this._didSourceRefresh=!1,this._updateSubscriptionRequests=[],this._updateHighlightRequests=[]}destroy(){this._subscriptions.clear(),this._processor?.destroy(),this._source?.destroy(),this._handles?.remove(),this._updateOverridesRequest=null,this._tileInfoView=null}onAttach(e){v("esri-2d-update-debug")&&console.debug("Pipeline.onAttach");const s=this._connection,r=$a.fromJSON(e.tileInfoJSON);this._tileInfoView=new Za(r),this._source=new qu(this._aggregateAdapter,this._subscriptions,s,this._cachedObjectIds),this._processor=new ru(s,this._source),this._handles=St([this._source.store.events.on("changed",()=>this._requestUpdate()),this._source.store.events.on("refresh",()=>this._requestRefresh()),ft(()=>this._source.updateTracking.updating,()=>{this._requestUpdate(),ti(this._connection.layerView.setUpdating({source:this._source.updateTracking.updating,pipeline:!0}))})])}onDetach(){v("esri-2d-update-debug")&&console.debug("Pipeline.onDetach"),this.destroy()}set remoteClient(e){this._connection=new lo(e)}get features(){const e=this._source?.queryEngine;if(!e)throw new P("no-queryEngine","No query engine defined");return e}get aggregates(){const e=this._processor?.aggregateQueryEngine;if(!e)throw new P("no-queryEngine","No aggregate query engine defined");return e}get processor(){return this._processor}get streamMessenger(){return this._source.streamMessenger}getUsedMemory(){return this._source.usedMemory+this._processor.usedMemory}getDisplayFeatures(e){return this._processor.getDisplayFeatures(e)}getDisplayIds(e){return this._processor.getDisplayIds(e)}getObjectIdsFromGlobalIds(e){return this._source.getObjectIdsFromGlobalIds(e)}async updateSchema(e,s){return v("esri-2d-update-debug")&&this._updateSchemaRequest&&console.error("InternalError: Schema already updating"),this._updateSchemaRequest=new ot({schema:e,version:s}),this._requestUpdate(),this._updateSchemaRequest.resolver.promise}updateSubscriptions(e){const s=new ot(e);return this._updateSubscriptionRequests.push(s),this._requestUpdate(),s.resolver.promise}updateHighlight(e){const s=new ot(e);return this._updateHighlightRequests.push(s),this._requestUpdate(),s.resolver.promise}async onOverride(e){if(this._updateOverridesRequest!=null)throw new P("featurelayer","InternalError - Already processing an edit");this._updateOverridesRequest=new ot(e);const s=this._updateOverridesRequest.resolver.promise;return this._requestUpdate(),s}queryStatistics(){return this._source.statistics.toJSON()}async queryVisibleFeatures(e,s){return this.features.executeQuery(e,s)}async queryHeatmapStatistics(e){const s=Math.round(w(e.radius));let r=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const a=typeof e.fieldOffset=="string",n=e.fieldOffset??0,o=Array.from(this._subscriptions.values()),c=this._source.chunks(),l=s**2,h=3/(Math.PI*l),u=2*s,d=Math.ceil(T/u);for(const f of o){const p=f.tile,m=new Float64Array(d*d);for(const _ of c){const g=_.getTileReader(p);if(!g)continue;const b=g.getCursor();for(;b.next();){let S=1;if(e.field!=null){const sr=b.readAttribute(e.field);S=a?-1*+sr:+sr+n}const x=b.readXForDisplay()/u,I=b.readYForDisplay()/u,k=Math.floor(x),M=Math.floor(I);if(k<0||M<0||k>=d||M>=d)continue;const F=((.5+k-x)*u)**2+((.5+M-I)*u)**2;if(F>l)continue;const H=S*(h*(1-F/l)**2);m[M+k*d]+=H}}for(let _=0;_<m.length;_++)r=Math.min(r,m[_]),i=Math.max(i,m[_])}return{max:i,min:r}}async getSampleFeatures(e){const s=this._source.chunks();if(s.reduce((c,l)=>c+l.size(),0)<=e.minFeatureCount){if(!this._source.updateTracking.updating){const c=[];return this._source.store.forEachUnsafe(l=>c.push(l.readLegacyFeatureWorldSpace())),c}return null}const r=new Set,i=[],a=s.map(c=>c.reader.getCursor()),n=new Ea,o=3*e.sampleSize;for(let c=0;c<o&&i.length<e.sampleSize;c++){const l=a[n.getIntRange(0,s.length-1)];if(l.getSize()===0)continue;const h=n.getIntRange(0,l.getSize()-1);l.setIndex(h);const u=l.getObjectId();r.has(u)||(r.add(u),i.push(l.readLegacyFeatureWorldSpace()))}return i.length>=e.sampleSize?i:null}_requestUpdate(){this._updateRequested||(this._updateRequested=!0,Oa(()=>this._scheduleNextUpdate()))}_requestRefresh(){this._didSourceRefresh=!0,this._requestUpdate()}_scheduleNextUpdate(){this._updateRequested&&(this._ongoingUpdate||(this._ongoingUpdate=vs(this._doUpdate()).finally(()=>{this._ongoingUpdate=null,this._scheduleNextUpdate()}),this._updateRequested=!1))}_subscribe(e){const s=e.tileId;if(this._subscriptions.has(s))return;v("esri-2d-update-debug")&&console.debug(`Tile[${s}] Pipeline.subscribe`);const r=new tr(this._tileInfoView,s),i=new Nu(r,e.version);this._subscriptions.set(s,i),this._source.onSubscribe(i),this._processor.onSubscribe(i)}_unsubscribe(e){const s=this._subscriptions.get(e);s&&(v("esri-2d-update-debug")&&console.debug(`Tile[${e}] Pipeline.unsubscribe`),s.abort(),this._source.onUnsubscribe(s),this._processor.onUnsubscribe(s),this._subscriptions.delete(s.key.id))}async _doUpdate(){if(v("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateStart"),await this._connection.layerView.setUpdating({source:this._source.updateTracking.updating,pipeline:!0}),this._updateSubscriptionRequests.length){const a=this._updateSubscriptionRequests;this._updateSubscriptionRequests=[];for(const n of a)this._doUpdateSubscriptions(n.inner),n.resolver.resolve()}if(this._updateHighlightRequests.length){const a=this._updateHighlightRequests,n=new Set,o=new Set;for(const c of a)for(const{objectId:l,highlightFlags:h}of c.inner.highlights)h?(n.add(l),o.delete(l)):(o.add(l),n.delete(l));this._source.prepareCacheUpdate(n,o)}const e=this._updateSchemaRequest;this._updateSchemaRequest=null;let s=!1;if(e!=null){const{schema:a,version:n}=e.inner;s=await this._doUpdateSchema(a,n)}this._processor.requiresInvalidation()&&(s=!0),this._didSourceRefresh&&(s=!0,this._didSourceRefresh=!1),s&&(this._processor.invalidate(),await this._connection.container.updateRenderState(this._processor.version));const r=this._updateOverridesRequest;if(this._updateOverridesRequest=null,r!=null){v("esri-2d-update-debug")&&console.debug("Pipeline.applyOverride",r.inner),r.inner.historicMoment!=null&&this._source.unsafeSetQueryHistoricMoment(r.inner.historicMoment);const a=await this._source.normalizeOverrides(r.inner);await this._source.applyOverride(a),v("esri-2d-update-debug")&&console.debug("Pipeline.endOverride",r.inner)}if(await this._source.applyCacheUpdate(),this._updateHighlightRequests.length){const a=this._updateHighlightRequests;this._updateHighlightRequests=[];for(const n of a)this._processor.updateHighlight(n.inner),n.resolver.resolve()}const i=this._source.cleanup();this._processor.removeChunks(i);try{const a=this._source.takeOverrideUpdate();if(a!=null&&this._subscriptions.size){v("esri-2d-update-debug")&&console.debug("Pipeline.applyOverrideChangesStart"),await this._connection.container.lockForOverrides();try{await this._processor.applyOverrideUpdate(a)}catch(n){v("esri-2d-update-debug")&&console.debug("InternalError",n)}await this._connection.container.unlockForOverrides(),v("esri-2d-update-debug")&&console.debug("Pipeline.applyOverrideChangesEnd")}this._subscriptions.size&&(v("esri-2d-update-debug")&&console.debug("Pipeline.updateChunksStart"),await this._processor.updateChunks(),v("esri-2d-update-debug")&&console.debug("Pipeline.updateChunksEnd"))}catch(a){ws(a)}r?.resolver.resolve(),e?.resolver.resolve(),e==null&&s&&await this._connection.container.trySwapRenderState(),this._connection.onEvent({type:"performance",usedMemory:this.getUsedMemory()}),this._updateRequested?(v("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateEnd [updateRequested=true]"),await this._connection.layerView.setUpdating({source:this._source.updateTracking.updating,pipeline:!0})):(v("esri-2d-update-debug")&&console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"),await this._connection.layerView.setUpdating({source:this._source.updateTracking.updating,pipeline:this._updateRequested}))}async _doUpdateSchema(e,s){v("esri-2d-update-debug")&&console.debug(`Version[${s}] Pipeline.updateStart`,{schema:e});const r={tileInfo:this._tileInfoView?.tileInfo},i=await this._source.update(e.source,s),a=Array.from(this._subscriptions.values()),n=this._processor.update(e,s,r,i,a);return v("esri-2d-update-debug")&&console.debug(`Version[${s}] Pipeline.updateEnd`),n}_doUpdateSubscriptions(e){v("esri-2d-update-debug")&&console.debug("Pipeline.updateSubscriptions",e);for(const s of e.subscribe)this._subscribe(s);for(const s of e.unsubscribe)this._unsubscribe(s)}}export{ep as default};
