import{r as $,o as O,E as z}from"./vec32-3aXs3jbn.js";import{I as H,u as f}from"./projectionUtils-CxkhtTt4.js";import{R as F,a6 as g}from"./Point-vWR8_ZMt.js";import{i as M,_ as h,m as v,a as j}from"./jsonMap-Bs3hmeCU.js";import{c as N}from"./reactiveUtils-SO2Ko3sy.js";import{_ as A}from"./mat4-BAXvdiEz.js";import{e as L}from"./mat4f64-q_b6UJoq.js";import{n as _}from"./collectionUtils-DoXnmzlX.js";import{l as I}from"./projectBoundingSphere-CL6AtYQu.js";import{K as y,M as q}from"./aaBoundingRect-aK0fPvVw.js";import{A as P}from"./sphere-BzYvaOhL.js";import{ab as B,ac as b}from"./ShadowCastClear.glsl-BvoFxLds.js";import{u as K}from"./Texture-CeSIfj9V.js";function ne(e,r,t,s){const n=H(r,s);if(n==null)return!1;const o=n.source.spatialReferenceId,a=n.dest.spatialReferenceId;if(o===a&&o!==0||F(r,s))return t[0]=1,t[1]=1,t[2]=1,!0;if(o===1){const c=$(e),m=c/Math.sqrt(e[0]*e[0]+e[1]*e[1]),i=c/g.radius;if(a===3)return t[0]=m*i,t[1]=m*i,t[2]=1,!0;if(a===2||a===5){const u=f;return t[0]=u*m*i,t[1]=u*i,t[2]=1,!0}}else if(o===11){if(a===2||a===5)return t[0]=f,t[1]=f,t[2]=1,!0;if(a===3){const c=e[1]/g.radius;return t[0]=1,t[1]=1/Math.cos(c),t[2]=1,!0}}return!1}let p=class extends N{constructor(e){super(e),this._tmpEvent=new B,this._renderCoordsHelper=e.view.renderCoordsHelper,this._renderSR=this._renderCoordsHelper.spatialReference,this._layerElevationSource=e.layerElevationSource}initialize(){this._intersector=new K(this.view.state.viewingMode),this._intersector.options.store=0,this._intersector.options.normalRequired=!1,this._tmpEvent.context=this.intersectionHandler.isGround?"ground":"scene"}get spatialReference(){return this.view?.elevationProvider?.spatialReference}getElevation(e,r,t,s){const n=this._renderCoordsHelper,o=O(l,e,r,t);if(!n.toRenderCoords(o,s,o))return M.getLogger(this).error("could not project point to compute elevation"),null;const{layerElevationSource:a,_intersector:c,intersectionHandler:m}=this,i=a.fullExtent,u=i!=null&&Number.isFinite(i.xmin)&&Number.isFinite(i.xmax)&&Number.isFinite(i.ymin)&&Number.isFinite(i.ymax)&&Number.isFinite(i.zmin)&&Number.isFinite(i.zmax)?new b(i.zmin,i.zmax):a.elevationRange;if(u==null)return null;const E=a.elevationOffset,w=u.elevationRangeMin+E,C=u.elevationRangeMax+E,x=n.setAltitude(G,C,o),R=n.setAltitude(T,w,o);return c.reset(x,R,this.view.state.camera),m.intersect(c,null,x,R,null,!0),c.results.min.getIntersectionPoint(o)?n.getAltitude(o):null}getSphereElevationBounds(e,r){return I(e,r,S,this._renderSR),this._layerElevationSource.getElevationRange(S)}getRootElevationBounds(){const e=this.layerElevationSource.fullExtent;return e?.hasZ?new b(e.zmin,e.zmax):null}notifyObjectsChanged(e){this.spatialReference&&(this._computeLayerExtent(r=>{for(const t of e)r(t)},this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}notifyObjectsChangedFunctional(e){this.spatialReference&&(this._computeLayerExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}notifyObjectChanged(e){this.spatialReference&&(this._computeObjectExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}_computeObjectExtent(e,r){y(r),this._expandExtent(e,r)}_computeLayerExtent(e,r){y(r),e(t=>{this._expandExtent(t,r)})}_expandExtent(e,r){const t=this.spatialReference;if(t==null||e==null)return;A(d,e.quaternion),d[12]=e.center[0],d[13]=e.center[1],d[14]=e.center[2];const s=e.halfSize;for(let n=0;n<8;++n)l[0]=1&n?s[0]:-s[0],l[1]=2&n?s[1]:-s[1],l[2]=4&n?s[2]:-s[2],z(l,l,d),this._renderCoordsHelper.fromRenderCoords(l,l,t),q(r,l,r)}};h([v({constructOnly:!0})],p.prototype,"layerElevationSource",void 0),h([v({constructOnly:!0})],p.prototype,"intersectionHandler",void 0),h([v({constructOnly:!0})],p.prototype,"view",void 0),h([v()],p.prototype,"spatialReference",null),p=h([j("esri.views.3d.layers.i3s.LayerElevationProvider")],p);const d=L(),S=P(0,0,0,0),l=_(),G=_(),T=_();class ie{constructor(r,t,s,n,o){this.toMapSpace=r,this.transform=t,this.obb=s,this.geometry=n,this.elevationAlignable=o}}class se{constructor(r,t){this.position=r,this.rotationScale=t,this.origin=void 0}}export{p as E,se as a,ne as i,ie as t};
