import{a8 as A,e as X,a1 as z}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{y as E}from"./aaBoundingRect-CjwcS2F3-D7aII9DY.js";import{f as F,m as G}from"./Polygon-D6wEPb3W-CpL9Efjx.js";import{l as H,u as J,m as K,y as N,s as k}from"./jsonUtils-CmpazY1u-ateEpj4Q.js";import{u as S,h as R,l as p}from"./normalizeUtilsCommon-CnhQye_A-zWtr51r8.js";function Y(i){return M(i,!0)}function tt(i){return M(i,!1)}function M(i,t){if(i==null)return null;const e=i.spatialReference,s=A(e),n=X(i)?i.toJSON():i;if(!s)return n;const h=z(e)?102100:4326,u=S[h].maxX,x=S[h].minX;if(H(n))return T(n,u,x);if(J(n))return n.points=n.points.map(o=>T(o,u,x)),n;if(K(n))return Z(n,s);if(N(n)||k(n)){const o=F(q,n),r={xmin:o[0],ymin:o[1],xmax:o[2],ymax:o[3]},m=p(r.xmin,x)*(2*u),_=m===0?n:R(n,m);return r.xmin+=m,r.xmax+=m,r.xmax>u?L(_,u,t):r.xmin<x?L(_,x,t):_}return n}function Z(i,t){if(!t)return i;const e=j(i,t).map(s=>s.extent);return e.length<2?e[0]||i:e.length>2?(i.xmin=t.valid[0],i.xmax=t.valid[1],i):{rings:e.map(s=>[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]])}}function T(i,t,e){if(Array.isArray(i)){const s=i[0];if(s>t){const n=p(s,t);i[0]=s+n*(-2*t)}else if(s<e){const n=p(s,e);i[0]=s+n*(-2*e)}}else{const s=i.x;if(s>t){const n=p(s,t);i.x+=n*(-2*t)}else if(s<e){const n=p(s,e);i.x+=n*(-2*e)}}return i}function j(i,t){const e=[],{ymin:s,ymax:n,xmin:h,xmax:u}=i,x=i.xmax-i.xmin,[o,r]=t.valid,{x:m,frameId:_}=w(i.xmin,t),{x:a,frameId:c}=w(i.xmax,t),b=m===a&&x>0;if(x>2*r){const g={xmin:h<u?m:a,ymin:s,xmax:r,ymax:n},O={xmin:o,ymin:s,xmax:h<u?a:m,ymax:n},C={xmin:0,ymin:s,xmax:r,ymax:n},P={xmin:o,ymin:s,xmax:0,ymax:n},f=[],y=[];I(g,C)&&f.push(_),I(g,P)&&y.push(_),I(O,C)&&f.push(c),I(O,P)&&y.push(c);for(let d=_+1;d<c;d++)f.push(d),y.push(d);e.push(new l(g,[_]),new l(O,[c]),new l(C,f),new l(P,y))}else m>a||b?e.push(new l({xmin:m,ymin:s,xmax:r,ymax:n},[_]),new l({xmin:o,ymin:s,xmax:a,ymax:n},[c])):e.push(new l({xmin:m,ymin:s,xmax:a,ymax:n},[_]));return e}function w(i,t){const[e,s]=t.valid,n=2*s;let h,u=0;return i>s?(h=Math.ceil(Math.abs(i-s)/n),i-=h*n,u=h):i<e&&(h=Math.ceil(Math.abs(i-e)/n),i+=h*n,u=-h),{x:i,frameId:u}}function I(i,t){const{xmin:e,ymin:s,xmax:n,ymax:h}=t;return v(i,e,s)&&v(i,e,h)&&v(i,n,h)&&v(i,n,s)}function v(i,t,e){return t>=i.xmin&&t<=i.xmax&&e>=i.ymin&&e<=i.ymax}function L(i,t,e=!0){const s=!k(i);if(s&&G(i),e)return new B().cut(i,t);const n=s?i.rings:i.paths,h=s?4:2,u=n.length,x=-2*t;for(let o=0;o<u;o++){const r=n[o];if(r&&r.length>=h){const m=[];for(const _ of r)m.push([_[0]+x,_[1]]);n.push(m)}}return s?i.rings=n:i.paths=n,i}class l{constructor(t,e){this.extent=t,this.frameIds=e}}const q=E();class B{constructor(){this._linesIn=[],this._linesOut=[]}cut(t,e){let s;if(this._xCut=e,t.rings)this._closed=!0,s=t.rings,this._minPts=4;else{if(!t.paths)return null;this._closed=!1,s=t.paths,this._minPts=2}for(const h of s){if(!h||h.length<this._minPts)continue;let u=!0;for(const x of h)u?(this.moveTo(x),u=!1):this.lineTo(x);this._closed&&this.close()}this._pushLineIn(),this._pushLineOut(),s=[];for(const h of this._linesIn)h&&h.length>=this._minPts&&s.push(h);const n=-2*this._xCut;for(const h of this._linesOut)if(h&&h.length>=this._minPts){for(const u of h)u[0]+=n;s.push(h)}return this._closed?t.rings=s:t.paths=s,t}moveTo(t){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(t[0]),this._moveTo(t[0],t[1],this._prevSide),this._prevPt=t,this._firstPt=t}lineTo(t){const e=this._side(t[0]);if(e*this._prevSide===-1){const s=this._intersect(this._prevPt,t);this._lineTo(this._xCut,s,0),this._prevSide=0,this._lineTo(t[0],t[1],e)}else this._lineTo(t[0],t[1],e);this._prevSide=e,this._prevPt=t}close(){const t=this._firstPt,e=this._prevPt;t[0]===e[0]&&t[1]===e[1]||this.lineTo(t),this._checkClosingPt(this._lineIn),this._checkClosingPt(this._lineOut)}_moveTo(t,e,s){this._closed?(this._lineIn.push([s<=0?t:this._xCut,e]),this._lineOut.push([s>=0?t:this._xCut,e])):(s<=0&&this._lineIn.push([t,e]),s>=0&&this._lineOut.push([t,e]))}_lineTo(t,e,s){this._closed?($(this._lineIn,s<=0?t:this._xCut,e),$(this._lineOut,s>=0?t:this._xCut,e)):s<0?(this._prevSide===0&&this._pushLineOut(),this._lineIn.push([t,e])):s>0?(this._prevSide===0&&this._pushLineIn(),this._lineOut.push([t,e])):this._prevSide<0?(this._lineIn.push([t,e]),this._lineOut.push([t,e])):this._prevSide>0&&(this._lineOut.push([t,e]),this._lineIn.push([t,e]))}_checkClosingPt(t){const e=t.length;e>3&&t[0][0]===this._xCut&&t[e-2][0]===this._xCut&&t[1][0]===this._xCut&&(t[0][1]=t[e-2][1],t.pop())}_side(t){return t<this._xCut?-1:t>this._xCut?1:0}_intersect(t,e){const s=(this._xCut-t[0])/(e[0]-t[0]);return t[1]+s*(e[1]-t[1])}_pushLineIn(){this._lineIn&&this._lineIn.length>=this._minPts&&this._linesIn.push(this._lineIn),this._lineIn=[]}_pushLineOut(){this._lineOut&&this._lineOut.length>=this._minPts&&this._linesOut.push(this._lineOut),this._lineOut=[]}}function $(i,t,e){const s=i.length;s>1&&i[s-1][0]===t&&i[s-2][0]===t?i[s-1][1]=e:i.push([t,e])}export{Y as Z,tt as i};
