import{_ as b,m as P,a as Q,a1 as z,y as D,a8 as K}from"./jsonMap-Bs3hmeCU.js";import{af as V,aJ as X,aG as Y,S as ee,ar as te,aE as re,aU as se,a5 as ae,f as ne,b as M,F as oe,ah as E}from"./Point-vWR8_ZMt.js";import{g as ie,P as le,c as ce,A as he,_ as pe,Q as H,I as ue}from"./vec32-3aXs3jbn.js";import{n as m}from"./collectionUtils-DoXnmzlX.js";import{P as U,Z as fe,C as me,_ as G}from"./Polygon-CHS6Qlya.js";import{j as de}from"./euclideanLengthMeasurementUtils-DbadGjNl.js";import{y as ye,m as xe}from"./Polyline-CTW9EJXE.js";import{c as ge}from"./distanceOperator-7Mri8kdZ.js";import{c as Re,u as Me}from"./simplifyOperator-BnweB9Zr.js";import{u as we}from"./mat2d-CSvNS1Et.js";import{e as A,t as Te}from"./mat2df64-DFLy2zOC.js";import{R as ve,L as be}from"./quat-DfRdiNBH.js";import{e as O}from"./quatf64-CCm9z-pX.js";var Z;let R=Z=class extends U{constructor(s){super(s),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const s=this.center,e=this.numberOfPoints;if(this.hasZ=s?.hasZ??!1,this.rings.length!==0||!s)return;const t=V(this.radius,this.radiusUnit,"meters"),a=s.spatialReference;let o,r="geographic";if(a.isWebMercator?r="webMercator":((a.wkid&&X[a.wkid])!=null||(a.wkt2||a.wkt)&&Y(a.wkt2||a.wkt))&&(r="projected"),this.geodesic){let n;switch(r){case"webMercator":n=ee(s);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=s}o=this._createGeodesicCircle(n,t,e),r==="webMercator"&&(o=te(o))}else{let n;r==="webMercator"||r==="projected"?n=t/re(s.spatialReference):r==="geographic"&&(n=se(t,"meters",ae(s.spatialReference).radius)),o=this._createPlanarCircle(s,n,e)}this.spatialReference=o.spatialReference,this.addRing(o.rings[0])}clone(){const{center:s,numberOfPoints:e,radius:t,radiusUnit:a,geodesic:o}=this;return new Z({center:s?.clone(),numberOfPoints:e,radius:t,radiusUnit:a,geodesic:o})}_createGeodesicCircle(s,e,t){const a=[],o=[s.x,s.y];for(let r=0;r<360;r+=360/t){const n=this.hasZ?[0,0,s.z??0]:[0,0];de(n,o,r,e,ne.WGS84),a.push(n)}return a.push(a[0]),new U({rings:[a]})}_createPlanarCircle(s,e,t){const a=[],o=2*Math.PI/t;for(let r=0;r<t;++r){const n=o*r,c=[s.x+Math.cos(-n)*e,s.y+Math.sin(-n)*e];this.hasZ&&c.push(s.z??0),a.push(c)}return a.push(a[0]),new U({spatialReference:s.spatialReference,rings:[a]})}};b([P({type:M})],R.prototype,"center",void 0),b([P()],R.prototype,"geodesic",void 0),b([P()],R.prototype,"numberOfPoints",void 0),b([P()],R.prototype,"radius",void 0),b([P()],R.prototype,"radiusUnit",void 0),R=Z=b([Q("esri.geometry.Circle")],R);const We=R;function I(s,e,t=null){return t!=null?[s,e,t]:[s,e]}function i(s,e,t=null){return t!=null?{x:s,y:e,z:t}:{x:s,y:e}}class B{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(t=>this.mapToLocal(t)).filter(z)}get doUnnormalization(){return!1}}let $e=class extends B{constructor(e,t,a=null){super(t),this._defaultZ=a,this.transform=A(),this.transformInv=A(),this.transform=Te(e),we(this.transformInv,this.transform)}makeMapPoint(e,t){return I(e,t,this._defaultZ)}mapToLocal(e){return i(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return I(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}},Pe=class extends B{constructor(e,t){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=m(),this.tangentFrameUpWS=m(),this.tangentFrameRightWS=m(),this.tangentFrameForwardWS=m(),this.localFrameRightWS=m(),this.localFrameUpWS=m(),this.worldToLocalTransform=O(),this.localToWorldTransform=O(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=t,this.defaultZ=t.hasZ?t.z:null;const a=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const o=m();ie(o,this.tangentFrameForwardWS,le(a,this.tangentFrameForwardWS)),ce(this.localFrameRightWS,a,o),he(this.localFrameRightWS,this.localFrameRightWS),pe(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),ve(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),be(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,t){return I(e,t,this.defaultZ)}mapToLocal(e){const t=m();this.view.renderCoordsHelper.toRenderCoords(new M({x:e[0],y:e[1],spatialReference:this.spatialReference}),t),H(t,t,this.worldToLocalTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return a!=null?i(a.x/this.scale,a.y/this.scale):null}localToMap(e){const t=m();this.view.renderCoordsHelper.toRenderCoords(new M({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),t),H(t,t,this.localToWorldTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return a!=null?I(a.x,a.y,this.defaultZ):null}};function Ge(s,e){if(s.type==="2d")return new $e(s.state.transform,s.spatialReference,e.length>2?e[2]:null);if(s.type==="3d"){const t=e.length>2?new M({x:e[0],y:e[1],z:e[2],spatialReference:s.spatialReference}):new M({x:e[0],y:e[1],spatialReference:s.spatialReference});return new Pe(s,t)}return null}function w(s,e){const t=new M({x:s[0],y:s[1],spatialReference:e});return s.length>2&&(t.z=s[2]),t}function Be(s,e){return new xe({points:s,spatialReference:e})}function qe(s,e,t){const a=new ye({paths:s,spatialReference:e});return t&&G(a),a}function L(s,e,t,a=!0){const o=D(s);o.forEach(n=>{const c=n[0],l=n[n.length-1];K(c,l)&&n.length!==1||n.push(n[0])});let r=new U({rings:o,spatialReference:e});return r.rings.forEach(n=>{me(n)||n.reverse()}),t&&G(r),a&&!Re(r)&&E(e)&&(r=Me(r)||r),r}function Ne(s,e,t){const a=e.mapToLocalMultiple(s),o=[],r={x:a[0].x,y:a[0].y},n={x:a[1].x,y:a[1].y},c=Math.round(n.x-r.x),l=Math.round(n.y-r.y),u=Math.max(Math.abs(c),Math.abs(l));if(t){const h={x:r.x+u,y:r.y+u},d={x:r.x-u,y:r.y-u};o.push(i(h.x,d.y),i(d.x,d.y),i(d.x,h.y),i(h.x,h.y))}else{const h={x:c>0?r.x+u:r.x-u,y:l>0?r.y+u:r.y-u};o.push(i(r.x,r.y),i(h.x,r.y),i(h.x,h.y),i(r.x,h.y))}return q(L([o.map(h=>e.localToMap(h)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function Je(s,e,t){let a=e.mapToLocalMultiple(s);if(a.length===1){const l=a[0];a=[i(l.x-48,l.y+48),i(l.x+48,l.y-48),i(l.x+48,l.y-48),i(l.x-48,l.y+48)]}const o=[],r={x:a[0].x,y:a[0].y},n={x:a[1].x,y:a[1].y};if(t){const c=Math.round(n.x-r.x),l=Math.round(n.y-r.y);o.push(i(r.x-c,r.y-l),i(n.x,r.y-l),i(n.x,n.y),i(r.x-c,n.y))}else o.push(i(r.x,r.y),i(n.x,r.y),i(n.x,n.y),i(r.x,n.y));return q(L([o.map(c=>e.localToMap(c)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function q(s,e,t){const a=F(e[3],e[2],t),o=F(e[1],e[2],t),r=F(e[0],e[1],t),n=F(e[0],e[3],t);return{geometry:s,midpoints:a!=null&&o!=null&&r!=null&&n!=null?{top:a,right:o,bottom:r,left:n}:null}}function F(s,e,t){W[0]=s.x,W[1]=s.y,W[2]=0,$[0]=e.x,$[1]=e.y,$[2]=0,ue(W,W,$,.5),C.x=W[0],C.y=$[1],C.z=$[2];const a=t.localToMap(C);return a!=null?w(a,t.spatialReference):null}const C=i(0,0,0),W=m(),$=m();function Qe(s,e,t,a){const o=e.mapToLocalMultiple(s);let r=null,n=null;if(t)r=o[0],n=o[1];else{const p=o[0],f=o[1],T=Math.round(f.x-p.x),v=Math.round(f.y-p.y),y=Math.max(Math.abs(T),Math.abs(v));r=i(T>0?p.x+y/2:p.x-y/2,v>0?p.y+y/2:p.y-y/2),n=i(Math.abs(T)>Math.abs(v)?r.x-y/2:r.x,Math.abs(T)>Math.abs(v)?r.y:r.y-y/2)}const c=e.localToMap(r),l=e.localToMap(n);if(c==null||l==null)return null;e.doUnnormalization&&fe([[c,l]],e.spatialReference);const u=w(c,e.spatialReference),h=w(l,e.spatialReference),d=oe(e.spatialReference);let x=0;if(E(e.spatialReference))x=d*ge(u,h);else{const p=r.x-n.x,f=r.y-n.y;x=d*Math.sqrt(p*p+f*f)*1}const S=new We({center:u,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:L(S.rings,S.spatialReference,!1),center:u,edge:h}}function De(s,e,t){const a=e.mapToLocalMultiple(s),o=a[0],r=a[1],n=Math.round(r.x-o.x),c=Math.round(r.y-o.y),l=i(t?o.x:o.x+n/2,t?o.y:o.y+c/2),u=t?n:n/2,h=t?c:c/2,d=60,x=[],S=2*Math.PI/d;function p(g){const N=Math.cos(g),J=Math.sin(g);return i(u*N+l.x,h*J+l.y)}for(let g=0;g<d;g++)x.push(p(g*S));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=e,v=L([x.map(g=>e.localToMap(g)).filter(z)],f,T,!1),y=e.localToMap(p(Math.PI/2)),_=e.localToMap(p(0)),k=e.localToMap(p(-Math.PI/2)),j=e.localToMap(p(Math.PI));return{geometry:v,midpoints:y!=null&&_!=null&&k!=null&&j!=null?{top:w(y,f),right:w(_,f),bottom:w(k,f),left:w(j,f)}:null}}export{Be as R,L as T,Je as U,Ge as W,Ne as b,qe as j,Qe as k,De as v};
