import{aH as G,I as k,v as B}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{r as E}from"./Cyclical-BLSxUpe7-Bj8R2Yk-.js";import{P as L}from"./Polygon-D6wEPb3W-D2MPjRU4.js";import{n as W}from"./Polyline-CoiTLswR-DTxpB2Yg.js";import{a8 as z,ar as J,f as H,X as O,H as T,I as K,S as Q}from"./Point-BfTTZoMu-DeJwQYfh.js";import{u as S,l as b,f as j,h as X}from"./normalizeUtilsCommon-CnhQye_A-UWhaH-kt.js";import{f as _,P as V}from"./jsonUtils-CmpazY1u-6pDLj5sx.js";import{J as Y}from"./utils-CylVuxNi--x86XOjU.js";import{i as Z,u as tt}from"./utils-Dpg4yj1D-CeFz2JVC.js";async function et(t,n,c,o){const e=Y(t),i=n[0].spatialReference,s={...o,responseType:"json",query:{...e.query,f:"json",sr:O(i),target:JSON.stringify({geometryType:_(n[0]),geometries:n}),cutter:JSON.stringify(c)}},r=await T(e.path+"/cut",s),{cutIndexes:a,geometries:u=[]}=r.data;return{cutIndexes:a,geometries:u.map(p=>{const x=V(p);return x.spatialReference=i,x})}}async function nt(t,n,c){const o=typeof t=="string"?K(t):t,e=n[0].spatialReference,i=_(n[0]),s={...c,query:{...o.query,f:"json",sr:O(e),geometries:JSON.stringify(Z(n))}},{data:r}=await T(o.path+"/simplify",s);return tt(r.geometries,i,e)}const C=()=>B.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function rt(t){return t[0].type==="polygon"}function st(t){return t[0].type==="polyline"}function it(t,n){if(!(t instanceof W||t instanceof L)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw C().error(e),new k("internal:geometry",e)}const c=j(t),o=[];for(const e of c){const i=[];o.push(i),i.push([e[0][0],e[0][1]]);for(let s=0;s<e.length-1;s++){const r=e[s][0],a=e[s][1],u=e[s+1][0],p=e[s+1][1],x=Math.sqrt((u-r)*(u-r)+(p-a)*(p-a)),h=(p-a)/x,d=(u-r)/x,m=x/n;if(m>1){for(let $=1;$<=m-1;$++){const N=$*n,f=d*N+r,l=h*N+a;i.push([f,l])}const w=(x+Math.floor(m-1)*n)/2,P=d*w+r,v=h*w+a;i.push([P,v])}i.push([u,p])}}return ot(t)?new L({rings:o,spatialReference:t.spatialReference}):new W({paths:o,spatialReference:t.spatialReference})}function D(t,n,c){if(n){const o=it(t,1e6);t=Q(o,!0)}return c&&(t=X(t,c)),t}function F(t,n,c){if(Array.isArray(t)){const o=t[0];if(o>n){const e=b(o,n);t[0]=o+e*(-2*n)}else if(o<c){const e=b(o,c);t[0]=o+e*(-2*c)}}else{const o=t.x;if(o>n){const e=b(o,n);t=t.clone().offset(e*(-2*n),0)}else if(o<c){const e=b(o,c);t=t.clone().offset(e*(-2*c),0)}}return t}function ft(t,n){let c=-1;for(let o=0;o<n.cutIndexes.length;o++){const e=n.cutIndexes[o],i=n.geometries[o],s=j(i);for(let r=0;r<s.length;r++){const a=s[r];a.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<a.length;h++){const d=a[h][0];p=d>p?d:p}p=Number(p.toFixed(9));const x=-360*b(p,180);for(let h=0;h<a.length;h++){const d=i.getPoint(r,h);i.setPoint(r,h,d.clone().offset(x,0))}return!0}})}if(e===c){if(rt(t))for(const r of j(i))t[e]=t[e].addRing(r);else if(st(t))for(const r of j(i))t[e]=t[e].addPath(r)}else c=e,t[e]=i}return t}async function ct(t,n,c){if(!Array.isArray(t))return ct([t],n);n&&typeof n!="string"&&C().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const o=typeof n=="string"?n:n?.url??G.geometryServiceUrl;let e,i,s,r,a,u,p,x,h=0;const d=[],m=[];for(const f of t)if(f!=null)if(e||(e=f.spatialReference,i=z(e),s=e.isWebMercator,u=s?102100:4326,r=S[u].maxX,a=S[u].minX,p=S[u].plus180Line,x=S[u].minus180Line),i)if(f.type==="mesh")m.push(f);else if(f.type==="point")m.push(F(f.clone(),r,a));else if(f.type==="multipoint"){const l=f.clone();l.points=l.points.map(y=>F(y,r,a)),m.push(l)}else if(f.type==="extent"){const l=f.clone()._normalize(!1,!1,i);m.push(l.rings?new L(l):l)}else if(f.extent){const l=f.extent,y=b(l.xmin,a)*(2*r);let M=y===0?f.clone():X(f.clone(),y);l.offset(y,0);let{xmin:R,xmax:g}=l;R=Number(R.toFixed(9)),g=Number(g.toFixed(9)),l.intersects(p)&&g!==r?(h=g>h?g:h,M=D(M,s),d.push(M),m.push("cut")):l.intersects(x)&&R!==a?(h=g*(2*r)>h?g*(2*r):h,M=D(M,s,360),d.push(M),m.push("cut")):m.push(M)}else m.push(f.clone());else m.push(f);else m.push(f);let w=b(h,r),P=-90;const v=w,$=new W;for(;w>0;){const f=360*w-180;$.addPath([[f,P],[f,-1*P]]),P*=-1,w--}if(d.length>0&&v>0){const f=ft(d,await et(o,d,$,c)),l=[],y=[];for(let g=0;g<m.length;g++){const q=m[g];if(q!=="cut")y.push(q);else{const I=f.shift(),A=t[g];A!=null&&A.type==="polygon"&&A.rings&&A.rings.length>1&&I.rings.length>=A.rings.length?(l.push(I),y.push("simplify")):y.push(s?J(I):I)}}if(!l.length)return y;const M=await nt(o,l,c),R=[];for(let g=0;g<y.length;g++){const q=y[g];q!=="simplify"?R.push(q):R.push(s?J(M.shift()):M.shift())}return R}const N=[];for(let f=0;f<m.length;f++){const l=m[f];if(l!=="cut")N.push(l);else{const y=d.shift();N.push(s===!0?J(y):y)}}return N}function xt(t,n,c){const o=z(c);if(o==null)return t;const[e,i]=o.valid,s=2*i;let r=0,a=0;n>i?r=Math.ceil(Math.abs(n-i)/s):n<e&&(r=-Math.ceil(Math.abs(n-e)/s)),t>i?a=Math.ceil(Math.abs(t-i)/s):t<e&&(a=-Math.ceil(Math.abs(t-e)/s));let u=t+(r-a)*s;const p=u-n;return p>i?u-=s:p<e&&(u+=s),u}function U(t){const n=z(t);if(n==null)return null;const[c,o]=n.valid;return new E(c,o)}const Mt=U(H.WGS84),wt=U(H.WebMercator);export{Mt as $,U as D,wt as M,it as i,ct as l,xt as x};
