import{L as Y,e as f,T as d,O as F,c as D,m as o,S as m,d as H,F as l,U as y,R as w,f as E,g,$ as v,_ as T,h as k,Y as c,I as b,V as A,k as N,J as L,K as $,t as I,v as U,z as B,j as M,s as O,q as z,a as x,A as V,X as W,D as j,G as q,H as J,Q as K,W as Q,Z as X,i as Z,r as P,l as tt,n as et,u as st}from"./BufferView-Cj2sQaht-DuP-iLZg.js";import{c as _}from"./types-BKo2foNY-DE0QfIFp.js";import"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{R as h}from"./enums-B4pqBiXb-BO-3hS_8.js";import{u as rt,h as it}from"./VertexElementDescriptor-BlxU8vCE-BwuKQkTU.js";function nt(i,t=0){const e=i.stride;return Array.from(i.fields.keys()).map(s=>{const r=i.fields.get(s),n=r.constructor.ElementCount,u=ht(r.constructor.ElementType),R=r.offset,S=r.optional?.glNormalized??!1;return new it(s,n,u,R,e,S,t)})}function ht(i){switch(i){case"u8":return h.UNSIGNED_BYTE;case"u16":return h.UNSIGNED_SHORT;case"u32":return h.UNSIGNED_INT;case"i8":return h.BYTE;case"i16":return h.SHORT;case"i32":return h.INT;case"f16":return h.HALF_FLOAT;case"f32":return h.FLOAT;default:throw new Error("BufferType not supported in WebGL")}}class a{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const s of t.fields.keys()){const r=t.fields.get(s);this[s]=new r.constructor(this.buffer,r.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const s=this[t];return s&&s.elementCount===e.ElementCount&&s.elementType===e.ElementType?s:null}slice(t,e){return new a(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,s=0,r=t.count){const n=this.stride;if(n%4==0){const u=new Uint32Array(t.buffer,e*n,r*n/4);new Uint32Array(this.buffer,s*n,r*n/4).set(u)}else{const u=new Uint8Array(t.buffer,e*n,r*n);new Uint8Array(this.buffer,s*n,r*n).set(u)}return this}get usedMemory(){return this.byteLength}dispose(){}}class p{constructor(t){this._stride=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:dt(e[1].constructor)})))}freeze(){return this}get locations(){return rt(nt(this))}vec2f16(t,e){return this._appendField(t,d?Y:f,e),this}vec2f(t,e){return this._appendField(t,f,e),this}vec2f64(t,e){return this._appendField(t,F,e),this}vec3f16(t,e){return this._appendField(t,d?D:o,e),this}vec3f(t,e){return this._appendField(t,o,e),this}vec3f64(t,e){return this._appendField(t,m,e),this}vec4f16(t,e){return this._appendField(t,d?H:l,e),this}vec4f(t,e){return this._appendField(t,l,e),this}vec4f64(t,e){return this._appendField(t,y,e),this}mat3f(t,e){return this._appendField(t,w,e),this}mat3f64(t,e){return this._appendField(t,E,e),this}mat4f(t,e){return this._appendField(t,g,e),this}mat4f64(t,e){return this._appendField(t,v,e),this}vec4u8(t,e){return this._appendField(t,T,e),this}f16(t,e){return this._appendField(t,d?k:c,e),this}f32(t,e){return this._appendField(t,c,e),this}f64(t,e){return this._appendField(t,b,e),this}u8(t,e){return this._appendField(t,A,e),this}u16(t,e){return this._appendField(t,N,e),this}i8(t,e){return this._appendField(t,L,e),this}vec2i8(t,e){return this._appendField(t,$,e),this}vec2i16(t,e){return this._appendField(t,I,e),this}vec2u8(t,e){return this._appendField(t,U,e),this}vec2u16(t,e){return this._appendField(t,B,e),this}vec4u16(t,e){return this._appendField(t,M,e),this}vec4i16(t,e){return this._appendField(t,O,e),this}u32(t,e){return this._appendField(t,z,e),this}_appendField(t,e,s){this._fields.has(t)&&x(!1,`${t} already added to vertex buffer layout`);const r=e.ElementCount*_(e.ElementType),n=this._stride;this._fields.set(t,{constructor:e,size:r,offset:n,optional:s}),this._alignFields()}_alignFields(){let t=0,e=1;this._fields.forEach(s=>{const r=_(s.constructor.ElementType);t=Math.floor((t+r-1)/r)*r,s.offset=t,t+=s.size,e=Math.max(e,r)}),t=Math.floor((t+e-1)/e)*e,this._stride=t}createBuffer(t){return new a(this,t)}createView(t){return new a(this,t)}clone(){const t=new p;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,s)=>t._fields.set(s,e)),t.BufferType=this.BufferType,t}get stride(){return this._stride}get fields(){return this._fields}}function pt(){return new p}class _t{constructor(t){this.fields=new Array,t.fields.forEach((e,s)=>{const r={...e,constructor:C(e.constructor)};this.fields.push([s,r])}),this.stride=t.stride}}const ut=[c,f,o,l,w,g,b,F,m,y,E,v,A,U,V,T,N,B,W,M,z,j,q,J,L,$,K,Q,X,I,Z,O,P,tt,et,st];function C(i){return`${i.ElementType}_${i.ElementCount}`}function dt(i){return G.get(i)}const G=new Map;ut.forEach(i=>G.set(C(i),i));export{_t as _,p as a,nt as n,pt as p};
