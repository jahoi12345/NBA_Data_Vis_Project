import{l as g}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";const c=-3,f=c-1,y=!!g("esri-tests-disable-gpu-memory-measurements");let R=class{constructor(r,t,s,i=0){this.name=r,this._storage=t,this.removeFunc=s,this._defaultPriority=i,this.id=`${S++}${n}`,this.size=0,this._hit=0,this._miss=0,this._storage.register(this)}destroy(){this._storage.deregister(this),this._storage=p}get hitRate(){return this._hit/(this._hit+this._miss)}get storageSize(){return this._storage.size}getSize(r){return this._storage.getSize(this,r)}set maxSize(r){this._storage.setMaxSize(this,r)}resetHitRate(){this._hit=this._miss=0}put(r,t,s=this._defaultPriority){this._storage.put(this,r,t,t.usedMemory,s)}pop(r){const t=this._storage.pop(this,r);return t===void 0?++this._miss:++this._hit,t}get(r){const t=this._storage.get(this,r);return t===void 0?++this._miss:++this._hit,t}peek(r){return this._storage.peek(this,r)}updateSize(r){this._storage.updateSize(this,r)}clear(){this._storage.clear(this)}clearAll(){this._storage.clearAll()}*[Symbol.iterator](){yield*this._storage.values(this)}get performanceInfo(){return this._storage.performanceInfo}resetStats(){this._storage.resetStats()}};class d{get size(){return this._size}constructor(t=10485760){this._maxSize=t,this._db=new Map,this._size=0,this._hit=0,this._miss=0,this._users=new Map,this._sizeLimits=new Map}destroy(){this.clearAll(),this._sizeLimits.clear(),this._users.clear(),this._db=null}register(t){this._users.set(t.id.slice(0,-1),t)}deregister(t){this.clear(t),this._sizeLimits.delete(t),this._users.delete(t.id.slice(0,-1))}get maxSize(){return this._maxSize}set maxSize(t){this._maxSize=Math.max(t,-1),this._checkSize()}getSize(t,s){return this._db.get(t.id+s)?.size??0}put(t,s,i,h,_){s=t.id+s;const e=this._db.get(s);if(e&&(this._size-=e.size,t.size-=e.size,this._db.delete(s),e.entry!==i&&this._notifyRemove(s,e.entry,e.size,0)),h>this._maxSize)return void this._notifyRemove(s,i,h,0);if(i===void 0)return void console.warn("Refusing to cache undefined entry ");if(!h||h<0)return y||console.warn(`Refusing to cache entry with size ${h} for key ${s}`),void this._notifyRemove(s,i,0,0);const o=1+Math.max(_,f)-c;this._db.set(s,new b(i,h,o)),this._size+=h,t.size+=h,this._checkSize()}updateSize(t,s){s=t.id+s;const i=this._db.get(s);if(!i)return;this._size-=i.size,t.size-=i.size;let h=i.entry.usedMemory;for(;h>this._maxSize;){const _=this._notifyRemove(s,i.entry,h,1);if(!(_!=null&&_>0))return void this._db.delete(s);h=_}i.size=h,this._size+=h,t.size+=h,this._checkSize()}pop(t,s){s=t.id+s;const i=this._db.get(s);if(i)return this._size-=i.size,t.size-=i.size,this._db.delete(s),++this._hit,i.entry;++this._miss}get(t,s){s=t.id+s;const i=this._db.get(s);if(i!==void 0)return this._db.delete(s),i.lives=i.lifetime,this._db.set(s,i),++this._hit,i.entry;++this._miss}peek(t,s){const i=this._db.get(t.id+s);return i?++this._hit:++this._miss,i?.entry}get performanceInfo(){const t={Size:Math.round(this._size/1048576)+"/"+Math.round(this._maxSize/1048576)+"MB","Hit rate":Math.round(100*this._getHitRate())+"%",Entries:this._db.size.toString()},s={},i=new Array;this._db.forEach((e,o)=>{const a=e.lifetime;i[a]=(i[a]||0)+e.size,this._users.forEach(l=>{const{id:u,name:z}=l;if(o.startsWith(u)){const m=s[z]||0;s[z]=m+e.size}})});const h={};this._users.forEach(e=>{const o=e.name;if("hitRate"in e&&typeof e.hitRate=="number"&&!isNaN(e.hitRate)&&e.hitRate>0){const a=s[o]||0;s[o]=a,h[o]=Math.round(100*e.hitRate)+"%"}else h[o]="0%"});const _=Object.keys(s);_.sort((e,o)=>s[o]-s[e]),_.forEach(e=>t[e]=Math.round(s[e]/2**20)+"MB / "+h[e]);for(let e=i.length-1;e>=0;--e){const o=i[e];o&&(t["Priority "+(e+c-1)]=Math.round(o/this._size*100)+"%")}return t}resetStats(){this._hit=this._miss=0,this._users.forEach(t=>t.resetHitRate())}clear(t){const s=t.id;this._db.forEach((i,h)=>{h.startsWith(s)&&(this._size-=i.size,this._db.delete(h),this._notifyRemove(h,i.entry,i.size,0))}),t.size=0}clearAll(){this._db.forEach((t,s)=>this._notifyRemove(s,t.entry,t.size,0)),this._users.forEach(t=>t.size=0),this._size=0,this._db.clear()}*values(t){for(const[s,i]of this._db)s.startsWith(t.id)&&(yield i.entry)}_getHitRate(){return this._hit/(this._hit+this._miss)}_notifyRemove(t,s,i,h){const _=this._users.get(t.split(n)[0])?.removeFunc,e=_?.(s,h,i);return typeof e=="number"?e:null}_checkSize(){this._sizeLimits.forEach((t,s)=>this._checkSizeLimits(t,s)),this._checkSizeLimits(this.maxSize)}setMaxSize(t,s){s==null||s<=0?this._sizeLimits.delete(t):this._sizeLimits.set(t,s)}_checkSizeLimits(t,s){const i=s??this;if(i.size<=t)return;const h=s?.id;let _=!0;for(;_;){_=!1;for(const[e,o]of this._db)if(o.lifetime===0&&(!h||e.startsWith(h))){const a=s??this._users.get(e.split(n)[0]);if(this._purgeItem(e,o,a),i.size<=.9*t)return;_||=this._db.has(e)}}for(const[e,o]of this._db)if(!h||e.startsWith(h)){const a=s??this._users.get(e.split(n)[0]);if(this._purgeItem(e,o,a),i.size<=.9*t)return}}_purgeItem(t,s,i){if(this._db.delete(t),s.lives<=1){this._size-=s.size,i&&(i.size-=s.size);const h=this._notifyRemove(t,s.entry,s.size,1);h!=null&&h>0&&(this._size+=h,i&&(i.size+=h),s.lives=s.lifetime,s.size=h,this._db.set(t,s))}else--s.lives,this._db.set(t,s)}}const p=new d(0);let S=0;class b{constructor(t,s,i){this.entry=t,this.size=s,this.lifetime=i,this.lives=i}}const n=":";class x{constructor(t,s){this.removeFunc=s,this._storage=new d,this.id="",this.name="",this.size=0,this._storage.maxSize=t,this._storage.register(this)}destroy(){this._storage.deregister(this),this._storage.destroy(),this._storage=null}put(t,s,i=1){this._storage.put(this,t,s,i,1)}pop(t){return this._storage.pop(this,t)}get(t){return this._storage.get(this,t)}clear(){this._storage.clearAll()}get maxSize(){return this._storage.maxSize}set maxSize(t){this._storage.maxSize=t}resetHitRate(){}}export{x as M,R,c,d,f};
