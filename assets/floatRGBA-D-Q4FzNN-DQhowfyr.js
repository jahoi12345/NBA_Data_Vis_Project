import{aH as G,v as K,I as T,s as R,a5 as Q,d as J,ab as ee,S as L,a3 as te,N as se,C as re,Y as S,H as F,G as oe,q as ie,c as ne,y as le,ap as ae}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{H as ce,e as ue,x as he,A as $,c as fe,w as de,N as me}from"./lengthUtils-Dt1_RvOO-j3MEdmHu.js";import{S as pe,D as ge}from"./date-IqUzANpt-bLKO9IDT.js";import{X as _e}from"./intl-DRFqUect-DPhFaHB2.js";import{i as ye,_ as we}from"./labelUtils-BtizwBfq-Zegx4520.js";import{O as ve}from"./ArcadeExpression-BlIRq-oN-VZkrwLVE.js";import{a8 as O}from"./Point-BfTTZoMu-DeJwQYfh.js";import{s as M}from"./TileKey-C44YQC4_-BW7BBbYp.js";import{aj as Ie}from"./Polygon-D6wEPb3W-D2MPjRU4.js";import{l as Se}from"./Queue-CYlrXMwB-CYJTUII-.js";import{l as b}from"./ReactiveMap-B0by2bYu-DCsCfMj5.js";import{n as xe}from"./signal-BX9ezF8a-cf1Pn6io.js";import{s as Y}from"./mathUtils-PIGhLnI9-B1tKUlUb.js";import"./Extent-CgDMOSRD-Bod5LY6s.js";const z=()=>K.getLogger("esri.layers.support.labelFormatUtils"),B={type:"simple",evaluate:()=>null},Fe={getAttribute:(t,e)=>t.field(e)};async function Je(t,e,s){if(!t||!t.symbol||!e)return B;const o=t.where,r=ye(t);let i;if(r.type==="arcade"){const n=fe(r.expression),l=e.get(n);if(l&&(de(l)||$(l)||me(l)))i={type:"simple",evaluate(c){const a="attributes"in c?c.attributes?.[l.name]:c.field(l.name);return a==null?"":a.toString()}};else{const c=await ve(r.expression,s);if(c==null)return B;i={type:"arcade",evaluate(a,u){try{const h="attributes"in a?c.repurposeFeature(a,e):a;h.contextTimeZone=u??null;const _=c.evaluate(h,{$view:{timeZone:u}});if(_!=null)return _.toString()}catch(h){z().error(new T("arcade-expression-error","Encountered an error when evaluating label expression for feature",{error:h,feature:a,expression:r}))}return null},needsHydrationToEvaluate:()=>we(r.expression)==null}}}else i={type:"simple",evaluate:n=>r.expression.replaceAll(/{[^}]*}/g,l=>{const c=l.slice(1,-1),a=e.get(c);if(!a)return l;let u=null;return u="attributes"in n?n?.attributes?.[a.name]:n.field(a.name),u==null?"":Ce(u,a)})};if(o){let n;try{n=await ce(o,e)}catch(c){return z().error(new T("bad-where-clause","Encountered an error when evaluating where clause, ignoring",{where:o,error:c})),B}const l=i.evaluate;i.evaluate=(c,a)=>{const u="attributes"in c?void 0:Fe;try{if(n.testFeature(c,u))return l(c,a)}catch(h){z().error(new T("bad-where-clause","Encountered an error when evaluating where clause for feature",{where:o,feature:c,error:h}))}return null}}return i}function Ce(t,e){if(t==null)return"";const s=e.domain;if(s){if(s.type==="codedValue"||s.type==="coded-value"){const r=t;for(const i of s.codedValues)if(i.code===r)return i.name}else if(s.type==="range"){const{max:r,min:i}=ue(e),n=+t;if(i!=null&&r!=null&&i<=n&&n<=r)return s.name}}let o=t;return he(e)?o=pe(o,ge("short-date")):$(e)&&(o=_e(+o)),o||""}const j="arial-unicode-ms",A="woff2",N=new Map,X=new Set;let Me=class{constructor(t,e){this.fontFace=t,this.promise=e}};async function et(t){const e=ze(t),s=be(t),o=N.get(e);if(o)return o.promise;const r=new FontFace(t.family,`url('${G.fontsUrl}/woff2/${s}.${A}') format('${A}')`,{style:t.style,weight:t.weight}),i=document.fonts;if(i.has(r)&&r.status==="loading")return r.loaded;const n=r.load().then(()=>(i.add(r),r));return N.set(e,new Me(r,n)),X.add(r),n}function tt(t){return X.has(t)}function Te(t){if(!t)return j;const e=t.toLowerCase().split(" ").join("-");switch(e){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return e}}function be(t){const e=V(t)+W(t);return Te(t.family)+(e.length>0?e:"-regular")}function ze(t){const e=V(t)+W(t);return(t.family||j)+(e.length>0?e:"-regular")}function V(t){if(!t.weight)return"";switch(t.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}function W(t){if(!t.style)return"";switch(t.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}function C(t,e){return[t,e]}function x(t,e,s){return t[0]=e,t[1]=s,t}function Be(t,e,s,o,r){return t[0]=e,t[1]=s,t[2]=o,t[3]=r,t}const v=new M("0/0/0/0");let qe=class P{static create(e,s,o=null){const r=O(e.spatialReference),i=s.origin||C(e.origin.x,e.origin.y),n=C(e.size[0]*s.resolution,e.size[1]*s.resolution),l=C(-1/0,-1/0),c=C(1/0,1/0),a=C(1/0,1/0);o!=null&&(x(l,Math.max(0,Math.floor((o.xmin-i[0])/n[0])),Math.max(0,Math.floor((i[1]-o.ymax)/n[1]))),x(c,Math.max(0,Math.floor((o.xmax-i[0])/n[0])),Math.max(0,Math.floor((i[1]-o.ymin)/n[1]))),x(a,c[0]-l[0]+1,c[1]-l[1]+1));const{cols:u,rows:h}=s;let _,w,m,g;return!o&&u&&h&&(x(l,u[0],h[0]),x(c,u[1],h[1]),x(a,u[1]-u[0]+1,h[1]-h[0]+1)),e.isWrappable?(_=C(Math.ceil(Math.round((r.valid[1]-r.valid[0])/s.resolution)/e.size[0]),a[1]),w=!0,m=r.origin,g=r.valid):(_=a,w=!1),new P(s.level,s.resolution,s.scale,i,l,c,a,n,_,w,m,g)}constructor(e,s,o,r,i,n,l,c,a,u,h,_){this.level=e,this.resolution=s,this.scale=o,this.origin=r,this.first=i,this.last=n,this.size=l,this.norm=c,this.worldSize=a,this.wrap=u,this._spatialReferenceOrigin=h,this._spatialReferenceValid=_}normalizeCol(e){if(!this.wrap)return e;const s=this.worldSize[0];return e<0?s-1-Math.abs((e+1)%s):e%s}normalizeKey(e){if(!this.wrap)return;const s=this.worldSize[0],o=e.col;o<0?(e.col=o+s,e.world-=1):o>=s&&(e.col=o-s,e.world+=1)}denormalizeCol(e,s){return this.wrap?this.worldSize[0]*s+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const s=this.origin[0]+e*this.norm[0],o=this._spatialReferenceOrigin,r=this._spatialReferenceValid;return this.wrap&&o&&r?s===o[0]?r[0]:this.origin[0]===o[0]&&e===this.worldSize[0]?r[1]:s:s}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,s,o=!1){v.set(s);const r=o?v.col:this.denormalizeCol(v.col,v.world),i=v.row;return Be(e,this.getXForColumn(r),this.getYForRow(i+1),this.getXForColumn(r+1),this.getYForRow(i)),e}getTileCoords(e,s,o=!1){v.set(s);const r=o?v.col:this.denormalizeCol(v.col,v.world);return Array.isArray(e)?x(e,this.getXForColumn(r),this.getYForRow(v.row)):(e.x=this.getXForColumn(r),e.y=this.getYForRow(v.row)),e}};class k{constructor(){this.spans=[]}static{this.pool=new re(()=>new k)}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:s,colFrom:o,colTo:r}of this.spans)for(let i=o;i<=r;i++){const n=e.getWorldForColumn(i);yield new M(e.level,s,e.normalizeCol(i),n)}}forEach(e,s){const{spans:o,lodInfo:r}=this,{level:i}=r;if(o.length!==0)for(const{row:n,colFrom:l,colTo:c}of o)for(let a=l;a<=c;a++)e.call(s,i,n,r.normalizeCol(a),r.getWorldForColumn(a))}}let q=class{constructor(t,e,s){this.row=t,this.colFrom=e,this.colTo=s}};const f=new M("0/0/0/0");let ke=class D{static create(e,s){e[1]>s[1]&&([e,s]=[s,e]);const[o,r]=e,[i,n]=s,l=i-o,c=n-r,a=c!==0?l/c:0,u=(Math.ceil(r)-r)*a,h=(Math.floor(r)-r)*a;return new D(o,Math.floor(r),Math.ceil(n),a,l<0?u:h,l<0?h:u,l<0?i:o,l<0?o:i)}constructor(e,s,o,r,i,n,l,c){this.x=e,this.ymin=s,this.ymax=o,this.invM=r,this.leftAdjust=i,this.rightAdjust=n,this.leftBound=l,this.rightBound=c}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}};const y=[[0,0],[0,0],[0,0],[0,0]],Re=1e-6;let st=class{constructor(t,e=null,s=t.lods[0].level,o=t.lods[t.lods.length-1].level){this.tileInfo=t,this.fullExtent=e,this.scales=[],this._infoByScale={},this._infoByLevel={};const r=t.lods.filter(n=>n.level>=s&&n.level<=o);this.minScale=r[0].scale,this.maxScale=r[r.length-1].scale;const i=this._lodInfos=r.map(n=>qe.create(t,n,e));r.forEach((n,l)=>{this._infoByLevel[n.level]=i[l],this._infoByScale[n.scale]=i[l],this.scales[l]=n.scale},this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel[typeof t=="number"?t:t.level]}getTileBounds(t,e,s=!1){f.set(e);const o=this._infoByLevel[f.level];return o?o.getTileBounds(t,f,s):t}getTileCoords(t,e,s=!1){f.set(e);const o=this._infoByLevel[f.level];return o?o.getTileCoords(t,f,s):t}getTileCoverage(t,e=192,s=!0,o="closest"){if(!s&&(t.scale>this.minScale||t.scale<this.maxScale))return null;const r=o==="closest"?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),i=k.pool.acquire(r),n=this._wrap;let l,c,a,u=1/0,h=-1/0;const _=i.spans;y[0][0]=y[0][1]=y[1][1]=y[3][0]=-e,y[1][0]=y[2][0]=t.size[0]+e,y[2][1]=y[3][1]=t.size[1]+e;for(const d of y)t.toMap(d,d),d[0]=r.getColumnForX(d[0]),d[1]=r.getRowForY(d[1]);const w=[];let m=3;for(let d=0;d<4;d++){if(y[d][1]===y[m][1]){m=d;continue}const p=ke.create(y[d],y[m]);u=Math.min(p.ymin,u),h=Math.max(p.ymax,h),w[p.ymin]===void 0&&(w[p.ymin]=[]),w[p.ymin].push(p),m=d}if(u==null||h==null||h-u>100)return null;let g=[];for(l=u;l<h;){w[l]!=null&&(g=g.concat(w[l])),c=1/0,a=-1/0;for(let d=g.length-1;d>=0;d--){const p=g[d];c=Math.min(c,p.getLeftCol()),a=Math.max(a,p.getRightCol())}if(c=Math.floor(c),a=Math.floor(a),l>=r.first[1]&&l<=r.last[1])if(n)if(r.size[0]<r.worldSize[0]){const d=Math.floor(a/r.worldSize[0]);for(let p=Math.floor(c/r.worldSize[0]);p<=d;p++)_.push(new q(l,Math.max(r.getFirstColumnForWorld(p),c),Math.min(r.getLastColumnForWorld(p),a)))}else _.push(new q(l,c,a));else c>r.last[0]||a<r.first[0]||(c=Math.max(c,r.first[0]),a=Math.min(a,r.last[0]),_.push(new q(l,c,a)));l+=1;for(let d=g.length-1;d>=0;d--){const p=g[d];p.ymax>=l?p.incrRow():g.splice(d,1)}}return i}getTileParentId(t){f.set(t);const e=this._infoByLevel[f.level],s=this._lodInfos.indexOf(e)-1;return s<0?null:(this._getTileIdAtLOD(f,this._lodInfos[s],f),f.id)}getTileResolution(t){const e=this._infoByLevel[typeof t=="object"?t.level:t];return e?e.resolution:-1}getTileScale(t){const e=this._infoByLevel[t.level];return e?e.scale:-1}intersects(t,e){f.set(e);const s=this._infoByLevel[f.level],o=t.lodInfo;if(o.resolution>s.resolution){this._getTileIdAtLOD(f,o,f);const i=o.denormalizeCol(f.col,f.world);for(const n of t.spans)if(n.row===f.row&&n.colFrom<=i&&n.colTo>=i)return!0}if(o.resolution<s.resolution){const[i,n,l,c]=t.spans.reduce((m,g)=>(m[0]=Math.min(m[0],g.row),m[1]=Math.max(m[1],g.row),m[2]=Math.min(m[2],g.colFrom),m[3]=Math.max(m[3],g.colTo),m),[1/0,-1/0,1/0,-1/0]),a=s.denormalizeCol(f.col,f.world),u=o.getColumnForX(s.getXForColumn(a)),h=o.getRowForY(s.getYForRow(f.row)),_=o.getColumnForX(s.getXForColumn(a+1))-1,w=o.getRowForY(s.getYForRow(f.row+1))-1;return!(u>c||_<l||h>n||w<i)}const r=o.denormalizeCol(f.col,f.world);return t.spans.some(i=>i.row===f.row&&i.colFrom<=r&&i.colTo>=r)}normalizeBounds(t,e,s){if(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this._wrap){const o=O(this.tileInfo.spatialReference),r=-s*(o.valid[1]-o.valid[0]);t[0]+=r,t[2]+=r}return t}getSmallestInfoForScale(t){const e=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>e[0])return this._infoByScale[e[0]];for(let s=1;s<e.length-1;s++)if(t>e[s]+Re)return this._infoByScale[e[s-1]];return this._infoByScale[e[e.length-1]]}getClosestInfoForScale(t){const e=this.scales;return this._infoByScale[t]||(t=e.reduce((s,o)=>Math.abs(o-t)<Math.abs(s-t)?o:s,e[0])),this._infoByScale[t]}scaleToLevel(t){const e=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let s=e.length-1;s>=0;s--)if(t<e[s])return s===e.length-1?this._infoByScale[e[e.length-1]].level:this._infoByScale[e[s]].level+(e[s]-t)/(e[s]-e[s+1]);return this._infoByScale[e[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}zoomToScale(t){return this.tileInfo.zoomToScale(t)}_getTileIdAtLOD(t,e,s){const o=this._infoByLevel[s.level];return t.set(s),e.resolution<o.resolution?null:(e.resolution===o.resolution||(t.level=e.level,t.col=Math.floor(s.col*o.resolution/e.resolution+.01),t.row=Math.floor(s.row*o.resolution/e.resolution+.01)),t)}};class Le{constructor(e,s){this.item=e,this.controller=s,this.promise=null}}class Ae{constructor(e){this._schedule=null,this._task=null,this._deferreds=new b,this._controllers=new b,this._processingItems=new b,this._pausedSignal=xe(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new Se(e.peeker),this.process=e.process;const s=e.scheduler;e.priority&&s&&(this._task=s.registerTask(e.priority,this))}destroy(){this.clear(),this._schedule=R(this._schedule),this._task=R(this._task)}get updating(){return!!this._task?.updating||this.readyToRun}get length(){return this._processingItems.size+this._queue.length}abort(e){const s=this._controllers.get(e);s&&s.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach(s=>e.push(s)),this._controllers.clear(),e.forEach(s=>s.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((s,o)=>e(o))}get(e){const s=this._deferreds.get(e);return s?s.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,s){const o=this.get(e);if(o)return o;const r=new AbortController;let i=null;s&&(i=Q(s,()=>r.abort()));const n=()=>{const u=this._processingItems.get(e);u&&u.controller.abort(),l(),a.reject(L())},l=()=>{c.remove(),i?.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},c=J(r.signal,n),a=ee();return this._deferreds.set(e,a),this._controllers.set(e,r),a.promise.then(l,l),this._queue.push(e),this._scheduleNext(),a.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject(L()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const s of e)this._queue.push(s.item),s.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}get readyToRun(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(e){for(;!e.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),e.madeProgress()}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._task||this._pausedSignal.value||this._schedule||(this._schedule=te(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,s){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(s))}_processError(e,s){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(s))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(e==null)return;let s;const o=new AbortController,r=new Le(e,o);this._processingItems.set(e,r);try{s=this.process(e,o.signal)}catch(i){this._processError(r,i)}se(s)?(r.promise=s,s.then(i=>this._processResult(r,i),i=>this._processError(r,i))):this._processResult(r,s)}get test(){}}const E=[0,0];let I=class extends ie{constructor(t){super(t),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:t,process:e,scheduler:s,priority:o}=this;this._queue=new Ae({concurrency:t,scheduler:s,priority:o,process:(r,i)=>{const n=this._keyToItem.get(r);return e(n,{signal:i})},peeker:r=>this._peek(r)})}destroy(){this.clear(),this._queue=ne(this._queue)}get length(){return this._queue?this._queue.length:0}abort(t){const e=typeof t=="string"?t:t.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(t){return typeof t=="string"?this._keyToItem.has(t):this._keyToItem.has(t.id)}pause(){this._queue.pause()}push(t){const e=t.key.id;if(this._queue.has(e))return this._queue.get(e);const s=this._queue.push(e),o=this.tileInfoView.getTileScale(t.key),r=le(this._tilesByScale,o,()=>new Set),i=()=>{r.delete(t.key),r.size===0&&this._tilesByScale.delete(o),this._keyToItem.delete(e)};return r.add(t.key),this._keyToItem.set(e,t),s.then(i,i),s}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(t){if(!this.state)return t.values().next().value;const e=new Set;for(const i of t)e.add(this._keyToItem.get(i).key);const s=this.state.scale;let o,r=Number.POSITIVE_INFINITY;for(const[i,n]of this._tilesByScale)if(ae(n,l=>e.has(l))){const l=Math.abs(i-s);l<r&&(o=n,r=l)}return this._getClosestTileKey(o,t).id}_getClosestTileKey(t,e){const s=this.tileInfoView,o=this.state.center;let r,i=Number.POSITIVE_INFINITY;for(const n of t)if(e.has(n.id)){s.getTileCoords(E,n);const l=Ie(E,o);l<i&&(i=l,r=n)}return r}};S([F({constructOnly:!0})],I.prototype,"concurrency",void 0),S([F({constructOnly:!0})],I.prototype,"priority",void 0),S([F({constructOnly:!0})],I.prototype,"process",void 0),S([F({constructOnly:!0})],I.prototype,"scheduler",void 0),S([F()],I.prototype,"state",void 0),S([F({constructOnly:!0})],I.prototype,"tileInfoView",void 0),I=S([oe("esri.views.2d.tiling.TileQueue")],I);new M(0,0,0,0);function rt(t,e,s=0){const o=Y(t,0,Ee);for(let r=0;r<4;r++)e[s+r]=Math.floor(256*Z(o*U[r]))}function ot(t,e,s=0){const o=Y(t,0,$e);for(let r=0;r<3;r++)e[s+r]=Math.floor(256*Z(o*U[r]))}function H(t,e=0){let s=0;for(let o=0;o<4;o++)s+=t[e+o]*Ne[o];return s}const U=[1,256,65536,16777216],Ne=[1/256,1/65536,1/16777216,1/4294967296],Ee=H(new Uint8ClampedArray([255,255,255,255])),$e=H(new Uint8ClampedArray([255,255,255,0]));function Z(t){return t-Math.floor(t)}export{Ae as A,Ce as C,H as Z,ot as a,Je as e,st as i,j,rt as l,tt as r,et as s};
