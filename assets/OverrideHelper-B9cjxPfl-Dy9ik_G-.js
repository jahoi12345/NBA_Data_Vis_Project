import{F as b}from"./Color-CERqXxxY-BuYn26eI.js";import{G as M}from"./colorUtils-CeIi7j7j-C2WVx6th.js";import{a2 as v}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{m as C}from"./FieldsIndex-CimK-TqD--24JoCkp.js";import{G as I}from"./ArcadeExpression-BlIRq-oN-VZkrwLVE.js";import{i as x,u as d,s as k,n as O,R as S,Y as h,L as N}from"./utils-DX2muIr3-DiPfFKSl.js";import P from"./callExpressionWithFeature-CVhPXWjd-D79N-p4u.js";import"./mathUtils-PIGhLnI9-B1tKUlUb.js";import"./vec42-B8VM4vXb-B6OGOEI9.js";import"./Polygon-D6wEPb3W-D2MPjRU4.js";import"./Extent-CgDMOSRD-Bod5LY6s.js";import"./Point-BfTTZoMu-DeJwQYfh.js";import"./index-B0z_nLWi.js";import"./vec4f64-DPb6J-GU-C7c2DqbZ.js";import"./UnknownTimeZone-B697BDFv-CBbtul7O.js";import"./date-IqUzANpt-bLKO9IDT.js";import"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import"./lengthUtils-Dt1_RvOO-j3MEdmHu.js";import"./Polyline-CoiTLswR-DTxpB2Yg.js";import"./timeZoneUtils-BSc7-7qA-BAv3h8mh.js";import"./TimeOnly-BERR31kg-CQiLyUZi.js";import"./enum-BzLwmiID-CcyIdWlQ.js";import"./jsonUtils-CmpazY1u-6pDLj5sx.js";import"./quantizationUtils-Ceq-Uxsu-DjgKK_0s.js";import"./aaBoundingRect-CjwcS2F3-ri8bmh30.js";import"./reader-DcGs6kKN-DHJfK-tm.js";const T=m=>{if(!m)return[0,0,0,0];const{r:e,g:r,b:i,a:t}=m;return[e,r,i,255*t]};class a{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let t=!1;for(const o of i)if(o.primitiveName===e.primitiveName){t=!0;break}if(!t)for(const o of r)o.primitiveName===e.primitiveName&&i.push(o)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)a.findApplicableOverrides(t,r,i);if(e.symbolLayers)for(const t of e.symbolLayers)a.findApplicableOverrides(t,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const t of e.effects)a.findApplicableOverrides(t,r,i);if(e.markerPlacement&&a.findApplicableOverrides(e.markerPlacement,r,i),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const t of e.markerGraphics)a.findApplicableOverrides(t,r,i),a.findApplicableOverrides(t.symbol,r,i)}else e.type==="CIMCharacterMarker"?a.findApplicableOverrides(e.symbol,r,i):e.type==="CIMHatchFill"?a.findApplicableOverrides(e.lineSymbol,r,i):e.type==="CIMPictureMarker"&&a.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&x(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const i=d(e),t=e.primitiveName,o=[];for(const s of r)s.primitiveName===t&&o.push(d(s));return{type:"cim-effect-param",effect:i,overrides:k(o)}}static async resolveSymbolOverrides(e,r,i,t,o,s,p){if(!e?.symbol)return null;let{symbol:c,primitiveOverrides:l}=e;const f=!!l;if(!f&&!t)return c;c=v(c),l=v(l);let y=!0;if(r||(r={attributes:{}},y=!1),f){if(y||(l=l.filter(n=>!n.valueExpressionInfo?.expression.includes("$feature"))),p||(l=l.filter(n=>!n.valueExpressionInfo?.expression.includes("$view"))),l.length>0){const n=O(r.attributes),u={spatialReference:i,fields:n,geometryType:o};await a.createRenderExpressions(l,u),a.evaluateOverrides(l,r,o??"esriGeometryPoint",s,p,new C(n))}a.applyOverrides(c,l)}return t&&a.applyDictionaryTextOverrides(c,r,t,null),c}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const i=[];for(const t of e){const o=t.valueExpressionInfo;if(!o||a._expressionToRenderExpression.has(o.expression))continue;const s=I(o.expression,r.spatialReference);i.push(s),s.then(p=>a._expressionToRenderExpression.set(o.expression,p))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,r,i,t,o,s){const p={$view:{scale:o?.scale}};for(const c of e){c.value&&typeof c.value=="object"&&M(c.value)&&(c.propertyName==="Color"||c.propertyName==="StrokeColor")&&(c.value=T(c.value));const l=c.valueExpressionInfo;if(!l)continue;const f=a._expressionToRenderExpression.get(l.expression);f&&(c.value=P(f,r,p,i,s,t))}}static applyDictionaryTextOverrides(e,r,i,t,o="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const s=e.symbolLayers;if(!s)return;for(const p of s)p&&p.type==="CIMVectorMarker"&&a.applyDictionaryTextOverrides(p,r,i,t,e.type==="CIMTextSymbol"?e.textCase:o)}break;case"CIMVectorMarker":{const s=e.markerGraphics;if(!s)return;for(const p of s)p&&a.applyDictionaryTextOverrides(p,r,i,t)}break;case"CIMMarkerGraphic":{const s=e.textString;if(s&&s.includes("[")){const p=S(s,i);e.textString=h(r,p,t,o)}}}}static applyOverrides(e,r,i,t){if(e.primitiveName){for(const o of r)if(o.primitiveName===e.primitiveName){const s=N(o.propertyName);if(t&&t.push({cim:e,nocapPropertyName:s,value:e[s]}),i){let p=!1;for(const c of i)c.primitiveName===e.primitiveName&&(p=!0);p||i.push(o)}o.value!=null&&(e[s]=o.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const o of e.effects)a.applyOverrides(o,r,i,t);if(e.symbolLayers)for(const o of e.symbolLayers)a.applyOverrides(o,r,i,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const o of e.effects)a.applyOverrides(o,r,i,t);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const o of e.markerGraphics)a.applyOverrides(o,r,i,t),a.applyOverrides(o.symbol,r,i,t)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)i.value!==void 0&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(i=>Number(i));if(e==="Color"){const i=new b(r).toRgba();return i[3]*=255,i}return r}}export{a as OverrideHelper};
