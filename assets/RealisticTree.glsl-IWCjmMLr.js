import{b as vi,r as wn,s as bi,M as xi}from"./mathUtils-PIGhLnI9.js";import{aq as Sn,F as Ce,E as Pn,a as zn,I as $i,aP as yi,aC as _i,aQ as wi}from"./Polygon-BdLNJfwi.js";import{h as Ct,s as Si,p as Pi,n as zi,x as Ai,l as Mi,m as Oi,r as Ci}from"./mat4-n_G6OS58.js";import{e as Xe}from"./mat4f64-q_b6UJoq.js";import{n as Rt,r as J,l as Ri}from"./vec2f64-rIxtbMRN.js";import{E as Z,s as T,c as q,j as Gt,P as X,r as ie,g as V,u as U,o as Y,p as Tt,H as rt,K as Ti,A as I,_ as ne,R as Di,N as Vi}from"./vec32-CNF8e3LG.js";import{r as Ae,t as Me,n as D,_ as ji,b as Fi}from"./collectionUtils-Dk3LoVuX.js";import{a as Ei,r as Ui,u as Nt,n as Qe,e as vt,t as Li,s as Bi}from"./vec4f64-DPb6J-GU.js";import{e as Ii,i as Dt}from"./aaBoundingRect-CrU5VtR_.js";import{s as An,g as Hi}from"./BufferView-BMlFYMIb.js";import{bk as Mn,W as ki,az as Wi,aG as Vt,aA as Ne,bl as Gi,aB as Ni,aH as On,bm as Cn,bn as qi,Y as Zi,aZ as Rn,V as Yi,am as Xi,aw as Qi,_ as Ki,a0 as Ji,aq as qt,au as ot,bo as es,l as ce,ar as ts,ax as ns,a1 as is,a2 as ss,a3 as rs,a8 as os,a9 as as,at as ls,ad as cs,ae as us,af as H,s as hs,a as bt,bp as fs,bq as ds,br as ps,bs as ms,aE as gs,bt as vs,bu as bs,k as Zt,ak as xs,bv as Yt,bw as Xt,bx as $s,by as ys,bi as _s,bz as Qt,n as te,m as Q,M as ws,bA as Ss,bB as Ps,bC as zs,bD as As,bE as Ms}from"./Texture-Cw36TGeQ.js";import{f as xt,t as w,i as Os,j as Kt,n as k,o as Tn,y as at}from"./Emissions.glsl-B8XKMjLy.js";import{_ as Cs}from"./index-C-2WWcaK.js";import{Q as Dn,t as Rs}from"./InterleavedLayout-8W9JN4bc.js";import{_ as Jt,E as Ts,N as Ds}from"./enums-B4pqBiXb.js";import{t as Vs}from"./VertexElementDescriptor-BlxU8vCE.js";import{i as js,_ as W,y as en,c4 as Fs,c5 as Es,bm as Ue}from"./jsonMap-Bs3hmeCU.js";import{f as Vn,a5 as jn,a6 as Us,F as Fn,aC as tn}from"./Point-BN8RINcc.js";import{s as Ls,m as Bs}from"./vec42-CkbV-zLi.js";import{N as Is,$ as Hs}from"./projectionUtils-zKDw1yLq.js";import{g as ks,y as Ws,E as Gs}from"./aaBoundingBox-CtkshuSS.js";import{u as Ns}from"./meshVertexSpaceUtils-DM2fDb9e.js";import{n as $t,t as Ke}from"./projectVectorToVector-DkxXb83V.js";import{_ as qs}from"./Graphic-BiQTZi7k.js";import{f as Zs}from"./jsonUtils-UGNxUp3z.js";import{r as G,t as nn,n as ee}from"./vec3f32-WCVSSNPR.js";import{e as Ys}from"./DoubleArray-DExKNiTh.js";import{A as Xs,U as En}from"./Indices-D0_UQPPr.js";import{j as Je,k as qe,G as Qs,O as Un,I as yt,d as Ks,R as Js,K as jt,b as er,y as tr,L as nr,N as ir,a as sr}from"./plane-CYSvzg5X.js";import{s as Ft,w as rr,A as or,j as ar,k as lr}from"./sphere-9lseHxo-.js";import{t as M}from"./orientedBoundingBox-VXwBwem5.js";import{i as cr,y as ur}from"./memoryEstimations-Bd726a_p.js";import{f as hr}from"./HUDIntersectorResult-D3KkIdaq.js";import{e as fr}from"./Intersector-BDgm95L3.js";import{a as Ln}from"./spatialReferenceEllipsoidUtils-T3ZM6b8E.js";import{i as dr}from"./projectPointToVector-CELlCh-8.js";import{n as sn,M as pr,v as mr}from"./frustum-BypfKDJS.js";import{c as E,f as Le,u as gr}from"./vector-CGHTqcz0.js";import"./lengthUtils-Ceo6858g.js";const lt=()=>js.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function Te(t=Zn){return{plane:Je(t.plane),origin:Me(t.origin),basis1:Me(t.basis1),basis2:Me(t.basis2)}}function vr(t,e,n){const i=Vr.get();return i.origin=t,i.basis1=e,i.basis2=n,i.plane=Ks(0,0,0,0),tt(i),i}function et(t,e=Te()){return Et(t.origin,t.basis1,t.basis2,e)}function br(t,e){T(e.origin,t.origin),T(e.basis1,t.basis1),T(e.basis2,t.basis2),tr(e.plane,t.plane)}function Et(t,e,n,i=Te()){return T(i.origin,t),T(i.basis1,e),T(i.basis2,n),tt(i),Tr(i,"fromValues()"),i}function tt(t){yt(t.basis2,t.basis1,t.origin,t.plane)}function Bn(t,e,n){t!==n&&et(t,n);const i=V(E.get(),se(t),e);return U(n.origin,n.origin,i),n.plane[3]-=e,n}function xr(t,e,n){return In(e,n),Bn(n,Bt(t,t.origin),n),n}function $r(t,e){const n=t.basis1[0],i=t.basis2[1],[s,r]=t.origin;return Ii(s-n,r-i,s+n,r+i,e)}function In(t,e=Te()){const n=(t[2]-t[0])/2,i=(t[3]-t[1])/2;return Y(e.origin,t[0]+n,t[1]+i,0),Y(e.basis1,n,0,0),Y(e.basis2,0,i,0),er(0,0,1,0,e.plane),e}function Ut(t,e,n){return!!jt(t.plane,e,n)&&Nn(t,n)}function yr(t,e,n){if(Ut(t,e,n))return n;const i=Hn(t,e,E.get());return U(n,e.origin,V(E.get(),e.direction,Tt(e.origin,i)/ie(e.direction))),n}function Hn(t,e,n){const i=Ze.get();qn(t,e,i,Ze.get());let s=Number.POSITIVE_INFINITY;for(const r of Ht){const o=It(t,r,nt.get()),l=E.get();if(nr(i,o,l)){const c=Ti(E.get(),e.origin,l),a=Math.abs(vi(X(e.direction,c)));a<s&&(s=a,T(n,l))}}return s===Number.POSITIVE_INFINITY?kn(t,e,n):n}function _r(t,e){return(e-t)/e}function kn(t,e,n){if(Ut(t,e,n))return n;const i=Ze.get(),s=Ze.get();qn(t,e,i,s);let r=Number.POSITIVE_INFINITY;for(const o of Ht){const l=It(t,o,nt.get()),c=E.get();if(ir(i,l,c)){const a=rr(e,c);if(!Un(s,c))continue;a<r&&(r=a,T(n,c))}}return Lt(t,e.origin)<r&&Wn(t,e.origin,n),n}function Wn(t,e,n){const i=Js(t.plane,e,E.get()),s=sn(rn(t,t.basis1),i,-1,1,E.get()),r=sn(rn(t,t.basis2),i,-1,1,E.get());return q(n,U(E.get(),s,r),t.origin),n}function Gn(t,e,n){const{origin:i,basis1:s,basis2:r}=t,o=q(E.get(),e,i),l=Le(s,o),c=Le(r,o),a=Le(se(t),o);return Y(n,l,c,a)}function Lt(t,e){const n=Gn(t,e,E.get()),{basis1:i,basis2:s}=t,r=ie(i),o=ie(s),l=Math.max(Math.abs(n[0])-r,0),c=Math.max(Math.abs(n[1])-o,0),a=n[2];return l*l+c*c+a*a}function wr(t,e){return Math.sqrt(Lt(t,e))}function Sr(t,e){let n=Number.NEGATIVE_INFINITY;for(const i of Ht){const s=It(t,i,nt.get()),r=pr(s,e);r>n&&(n=r)}return Math.sqrt(n)}function Pr(t,e){return Un(t.plane,e)&&Nn(t,e)}function zr(t,e,n,i){return Rr(t,n,i)}function Bt(t,e){const n=-t.plane[3];return Le(se(t),e)-n}function Ar(t,e,n,i){const s=Bt(t,e),r=V(Dr,se(t),n-s);return U(i,e,r),i}function Mr(t,e){return rt(t.basis1,e.basis1)&&rt(t.basis2,e.basis2)&&rt(t.origin,e.origin)}function Or(t,e,n){return t!==n&&et(t,n),Ct(me,e),Si(me,me),Z(n.basis1,t.basis1,me),Z(n.basis2,t.basis2,me),Z(qe(n.plane),qe(t.plane),me),Z(n.origin,t.origin,e),Qs(n.plane,n.plane,n.origin),n}function Cr(t,e,n,i){return t!==i&&et(t,i),Pi(ct,e,n),Z(i.basis1,t.basis1,ct),Z(i.basis2,t.basis2,ct),tt(i),i}function se(t){return qe(t.plane)}function Rr(t,e,n){switch(e){case 0:T(n,t.basis1),I(n,n);break;case 1:T(n,t.basis2),I(n,n);break;case 2:T(n,se(t))}return n}function Nn(t,e){const n=q(E.get(),e,t.origin),i=Gt(t.basis1),s=Gt(t.basis2),r=X(t.basis1,n),o=X(t.basis2,n);return-r-i<0&&r-i<0&&-o-s<0&&o-s<0}function rn(t,e){const n=nt.get();return T(n.origin,t.origin),T(n.vector,e),n}function It(t,e,n){const{basis1:i,basis2:s,origin:r}=t,o=V(E.get(),i,e.origin[0]),l=V(E.get(),s,e.origin[1]);U(n.origin,o,l),U(n.origin,n.origin,r);const c=V(E.get(),i,e.direction[0]),a=V(E.get(),s,e.direction[1]);return V(n.vector,U(c,c,a),2),n}function Tr(t,e){Math.abs(X(t.basis1,t.basis2)/(ie(t.basis1)*ie(t.basis2)))>1e-6&&lt().warn(e,"Provided basis vectors are not perpendicular"),Math.abs(X(t.basis1,se(t)))>1e-6&&lt().warn(e,"Basis vectors and plane normal are not perpendicular"),Math.abs(-X(se(t),t.origin)-t.plane[3])>1e-6&&lt().warn(e,"Plane offset is not consistent with plane origin")}function qn(t,e,n,i){const s=se(t);yt(s,e.direction,e.origin,n),yt(qe(n),s,e.origin,i)}const Zn={plane:Je(),origin:Ae(0,0,0),basis1:Ae(1,0,0),basis2:Ae(0,1,0)},Ze=new Ft(Je),nt=new Ft(mr),Dr=D(),Vr=new Ft(()=>Te()),Ht=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],me=Xe(),ct=Xe(),jr=Object.freeze(Object.defineProperty({__proto__:null,altitudeAt:Bt,axisAt:zr,cameraFrustumCoverage:_r,closestPoint:kn,closestPointOnSilhouette:Hn,copy:et,copyWithoutVerify:br,create:Te,distance:wr,distance2:Lt,distanceToSilhouette:Sr,elevate:Bn,equals:Mr,extrusionContainsPoint:Pr,fromAABoundingRect:In,fromValues:Et,getExtent:$r,intersectRay:Ut,intersectRayClosestSilhouette:yr,normal:se,projectPoint:Wn,projectPointLocal:Gn,rotate:Cr,setAltitudeAt:Ar,setExtent:xr,transform:Or,up:Zn,updateUnboundedPlane:tt,wrap:vr},Symbol.toStringTag,{value:"Module"}));function Fr(t){const{value:e,operations:n}=t;return{operations:n,value:n.create(e)}}function Er(t,e,n){return t.operations.setExtent(t.value,e,n.value),n}function Ur(t,e){return t.operations.getExtent(t.value,e),e}function Lr(t){return{operations:t,value:t.create()}}function Yn(t,e,n=Lr(t)){return n.operations=t,t.copy(e,n.value),n}function Br(t){return Yn(ar,or(0,0,0,jn(t).radius))}const on=2**50;function Ir(){return Yn(jr,Et([0,0,0],[on,0,0],[0,on,0]))}function Hr(t,e,n){return t.operations.axisAt(t.value,e,2,n)}function kr(t,e,n,i){return t.operations.axisAt(t.value,e,n,i)}function Wr(t,e,n){return t.operations.intersectRay(t.value,e,n)}function Gr(t,e,n){return t.operations.intersectRayClosestSilhouette(t.value,e,n)}function Nr(t,e){return t.operations.altitudeAt(t.value,e)}function Xn(t,e,n,i){return t.operations.setAltitudeAt(t.value,e,n,i)}function qr(t,e,n,i){return e!==i&&zi(i,e),Y(ge,i[12],i[13],i[14]),Xn(t,ge,n,ge),i[12]=ge[0],i[13]=ge[1],i[14]=ge[2],i}function ut(t,e,n){return t.operations.elevate(t.value,e,n.value)}const ge=D();function Ja(t,e,n,i,s){return s[0]=X(t,e),s[1]=X(t,n),s[2]=X(t,i),s}function el(t,e,n,i,s){T(n,t),T(Ve,e),I(Ve,Ve),ne(i,Ve,n),ne(s,i,n)}function tl(t,e){return t?Ln(e):e.isGeographic?Vn.PlateCarree:e}const Ve=D();function Qn(t,e,n){return!!$t(t,e,je,n.spatialReference)&&(n.x=je[0],n.y=je[1],n.z=je[2],!0)}async function nl(t,e,n,i){return await Is(e,n.spatialReference,null,i),Qn(t,e,n)}const je=D();function an(t){return t.type==="point"}function Zr(t){return t instanceof Float32Array&&t.length>=16}function Yr(t){return Array.isArray(t)&&t.length>=16}function Xr(t){return Zr(t)||Yr(t)}const Kn=.5;function Qr(t,e){t.include(Mn),t.attributes.add("position","vec3"),t.attributes.add("normal","vec3"),t.attributes.add("centerOffsetAndDistance","vec4");const n=t.vertex;ki(n,e),Wi(n,e),n.uniforms.add(new Vt("viewport",i=>i.camera.fullViewport),new xt("polygonOffset",i=>i.shaderPolygonOffset),new Ne("cameraGroundRelative",i=>i.camera.aboveGround?1:-1)),e.hasVerticalOffset&&Gi(n),n.code.add(w`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),n.code.add(w`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.terrainDepthTest?w.float(0):w`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||Ni(n),e.draped||(n.uniforms.add(new Ne("perDistancePixelRatio",i=>Math.tan(i.camera.fovY/2)/(i.camera.fullViewport[2]/2))),n.code.add(w`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${w.float(Kn)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&On(n),e.hasScreenSizePerspective&&Cn(n),n.code.add(w`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?w`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":w`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}function kt(t){t.uniforms.add(new qi("alignPixelEnabled",e=>e.alignPixelEnabled)),t.code.add(w`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),t.code.add(w`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function Kr(t,e){const{vertex:n,fragment:i}=t;t.include(Zi,e),n.include(kt),n.main.add(w`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),i.main.add(w`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}function Jr(t){t.vertex.uniforms.add(new Ne("renderTransparentlyOccludedHUD",e=>e.hudRenderStyle===0?1:e.hudRenderStyle===1?0:.75),new Vt("viewport",e=>e.camera.fullViewport),new Rn("hudVisibilityTexture",e=>e.hudVisibility?.getTexture())),t.vertex.include(kt),t.vertex.code.add(w`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}let eo=class extends Os{constructor(e,n,i){super(e,"vec4",2,(s,r,o)=>s.setUniform4fv(e,n(r,o),i))}};function Jn(t){const e=new Yi,{signedDistanceFieldEnabled:n,occlusionTestEnabled:i,horizonCullingEnabled:s,pixelSnappingEnabled:r,hasScreenSizePerspective:o,debugDrawLabelBorder:l,hasVVSize:c,hasVVColor:a,hasRotation:u,occludedFragmentFade:h,sampleSignedDistanceFieldTexelCenter:f}=t;e.include(Qr,t),e.vertex.include(Xi,t);const{occlusionPass:b,output:y,oitPass:v}=t;if(b)return e.include(Kr,t),e;const{vertex:p,fragment:g}=e;e.include(Mn),e.include(Qi,t),e.include(Ki,t),i&&e.include(Jr),g.include(Ji),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const x=y===9,m=x&&i;m&&e.varyings.add("voccluded","float"),p.uniforms.add(new Vt("viewport",_=>_.camera.fullViewport),new qt("screenOffset",(_,N)=>Ce(Be,2*_.screenOffset[0]*N.camera.pixelRatio,2*_.screenOffset[1]*N.camera.pixelRatio)),new qt("anchorPosition",_=>Se(_)),new ot("materialColor",_=>_.color),new xt("materialRotation",_=>_.rotation),new Kt("tex",_=>_.texture)),On(p),n&&(p.uniforms.add(new ot("outlineColor",_=>_.outlineColor)),g.uniforms.add(new ot("outlineColor",_=>ln(_)?_.outlineColor:Ei),new xt("outlineSize",_=>ln(_)?_.outlineSize:0))),s&&p.uniforms.add(new eo("pointDistanceSphere",(_,N)=>{const $=N.camera.eye,j=_.origin;return Ui(j[0]-$[0],j[1]-$[1],j[2]-$[2],Us.radius)})),r&&p.include(kt),o&&(es(p),Cn(p)),l&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add("uv0","vec2"),e.attributes.add("uvi","vec4"),e.attributes.add("color","vec4"),e.attributes.add("size","vec2"),e.attributes.add("rotation","float"),(c||a)&&e.attributes.add("featureAttribute","vec4"),p.code.add(s?w`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return b > 0.0 && b < a && b * b  > a * c;
}`:w`bool behindHorizon(vec3 posModel) { return false; }`),p.main.add(w`
    ProjectHUDAux projectAux;
    vec4 posProj = projectPositionHUD(projectAux);
    forwardObjectAndLayerIdColor();

    if (rejectBySlice(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    if (behindHorizon(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec2 inputSize;
    ${k(o,w`
        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,w`
        inputSize = size;
        vec2 screenOffsetScaled = screenOffset;`)}
    ${k(c,w`inputSize *= vvScale(featureAttribute).xx;`)}

    vec2 combinedSize = inputSize * pixelRatio;
    vec4 quadOffset = vec4(0.0);

    ${k(i,w`
    bool visible = testHUDVisibility(posProj);
    if (!visible) {
      vtc = vec2(0.0);
      ${k(l,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
      return;
    }`)}
    ${k(m,w`voccluded = visible ? 0.0 : 1.0;`)}
  `);const A=w`
      vec2 uv = mix(uvi.xy, uvi.zw, bvec2(uv0));
      vec2 texSize = vec2(textureSize(tex, 0));
      uv = mix(vec2(1.0), uv / texSize, lessThan(uv, vec2(${no})));
      quadOffset.xy = (uv0 - anchorPosition) * 2.0 * combinedSize;

      ${k(u,w`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,d=r?n?w`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:w`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:w`posProj += quadOffset;`;p.main.add(w`
    ${A}
    ${a?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${k(y===10,w`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${w.float(ce)};
    ${k(n,`alphaDiscard = alphaDiscard && outlineColor.a < ${w.float(ce)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${d}
      gl_Position = posProj;
    }

    vtc = uv;

    ${k(l,w`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),g.uniforms.add(new Kt("tex",_=>_.texture)),h&&!x&&g.uniforms.add(new Rn("depthMap",_=>_.mainDepth),new Ne("occludedOpacity",_=>_.hudOccludedFragmentOpacity));const P=l?w`(isBorder > 0.0 ? 0.0 : ${w.float(ce)})`:w.float(ce),z=w`
    ${k(l,w`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    vec2 samplePos = vtc;

    ${k(f,w`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;`)}

    ${n?w`
      vec4 fillPixelColor = vcolor;

      // Get distance in output units (i.e. pixels)

      float sdf = texture(tex, samplePos).r;
      float pixelDistance = sdf * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - pixelDistance, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(pixelDistance) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${P} ||
          fillPixelColor.a + outlinePixelColor.a < ${w.float(ce)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${k(!x,w`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${P}) {
          discard;
        }

        ${k(!x,w`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-pixelDistance/vsize.x*2.0, 0.0, 1.0), clamp(pixelDistance/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:w`
          vec4 texColor = texture(tex, samplePos, -0.5);
          if (texColor.a < ${P}) {
            discard;
          }
          ${k(!x,w`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${k(h&&!x,w`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${k(!x&&l,w`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(y){case 0:case 1:e.outputs.add("fragColor","vec4",0),y===1&&e.outputs.add("fragEmission","vec4",1),v===1&&e.outputs.add("fragAlpha","float",y===1?2:1),g.main.add(w`
        ${z}
        ${k(v===2,w`fragColor.rgb /= fragColor.a;`)}
        ${k(y===1,w`fragEmission = vec4(0.0);`)}
        ${k(v===1,w`fragAlpha = fragColor.a;`)}`);break;case 10:g.main.add(w`
        ${z}
        outputObjectAndLayerIdColor();`);break;case 9:e.include(ts,t),g.main.add(w`
        ${z}
        outputHighlight(${k(m,w`voccluded == 1.0`,w`false`)});`)}return e}function ln(t){return t.outlineColor[3]>0&&t.outlineSize>0}function Se(t){return t.textureIsSignedDistanceField?to(t.anchorPosition,t.distanceFieldBoundingBox,Be):Sn(Be,t.anchorPosition),Be}function to(t,e,n){Ce(n,t[0]*(e[2]-e[0])+e[0],t[1]*(e[3]-e[1])+e[1])}const Be=Rt(),Re=32e3,no=w.float(Re),io=Object.freeze(Object.defineProperty({__proto__:null,build:Jn,calculateAnchorPosition:Se,fullUV:Re},Symbol.toStringTag,{value:"Module"}));let so=class extends is{constructor(e,n){super(e,n,new ss(io,()=>Cs(()=>Promise.resolve().then(()=>da),void 0)),Vs([ei,ni()].map(Rs))),this.primitiveType=n.occlusionPass?Jt.POINTS:Jt.TRIANGLE_STRIP}initializePipeline(e){const{oitPass:n,hasPolygonOffset:i,draped:s,output:r,depthTestEnabled:o,occlusionPass:l}=e,c=o&&!s&&n!==1&&!l&&r!==9;return rs({blending:Tn(r)?cs(n,!0):null,depthTest:o&&!s?{func:515}:null,depthWrite:c?ls:null,drawBuffers:as(n,r),colorWrite:os,polygonOffset:i?ro:null})}};const ro={factor:0,units:-4},ei=Dn().vec2u8("uv0",{glNormalized:!0}),ti=Dn().vec3f("position").vec3f("normal").vec4i16("uvi").vec4u8("color").vec2f("size").f32("rotation").vec4f("centerOffsetAndDistance").vec4f("featureAttribute"),oo=ti.clone().vec4u8("olidColor");function ni(){return ns()?oo:ti}let L=class extends us{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.hasVVSize=!1,this.hasVVColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.olidColorInstanced=!1,this.textureCoordinateType=0,this.emissionSource=0,this.discardInvisibleFragments=!0,this.hasVVInstancing=!1,this.snowCover=!1}};W([H()],L.prototype,"screenCenterOffsetUnitsEnabled",void 0),W([H()],L.prototype,"occlusionTestEnabled",void 0),W([H()],L.prototype,"signedDistanceFieldEnabled",void 0),W([H()],L.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),W([H()],L.prototype,"hasVVSize",void 0),W([H()],L.prototype,"hasVVColor",void 0),W([H()],L.prototype,"hasVerticalOffset",void 0),W([H()],L.prototype,"hasScreenSizePerspective",void 0),W([H()],L.prototype,"hasRotation",void 0),W([H()],L.prototype,"debugDrawLabelBorder",void 0),W([H()],L.prototype,"hasPolygonOffset",void 0),W([H()],L.prototype,"depthTestEnabled",void 0),W([H()],L.prototype,"pixelSnappingEnabled",void 0),W([H()],L.prototype,"draped",void 0),W([H()],L.prototype,"terrainDepthTest",void 0),W([H()],L.prototype,"cullAboveTerrain",void 0),W([H()],L.prototype,"occlusionPass",void 0),W([H()],L.prototype,"occludedFragmentFade",void 0),W([H()],L.prototype,"horizonCullingEnabled",void 0),W([H()],L.prototype,"isFocused",void 0);class ol extends hs{constructor(e,n){super(e,po),this.produces=new Map([[13,i=>at(i)&&!this.parameters.drawAsLabel],[14,i=>at(i)&&this.parameters.drawAsLabel],[12,()=>this.parameters.occlusionTest],[18,i=>this.parameters.draped&&at(i)]]),this._visible=!0,this._configuration=new L(n)}getConfiguration(e,n){const i=this.parameters.draped;return super.getConfiguration(e,n,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=i,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.hasVVSize=!!this.parameters.vvSize,this._configuration.hasVVColor=!!this.parameters.vvColor,this._configuration.occlusionPass=n.slot===12,this._configuration.occludedFragmentFade=!i&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||n.slot===12,Tn(e)&&(this._configuration.debugDrawLabelBorder=!!bt.LABELS_SHOW_BORDER),this._configuration.oitPass=n.oitPass,this._configuration.terrainDepthTest=n.terrainDepthTest,this._configuration.cullAboveTerrain=n.cullAboveTerrain,this._configuration}intersect(e,n,i,s,r,o){const{options:{selectionMode:l,hud:c,excludeLabels:a},point:u,camera:h}=i,{parameters:f}=this;if(!l||!c||a&&f.isLabel||!e.visible||!u||!h)return;const b=e.attributes.get("featureAttribute"),y=b==null?null:Nt(b.data,St),{scaleX:v,scaleY:p}=Pt(y,f,h.pixelRatio);Pn(Ie,n),e.attributes.has("featureAttribute")&&co(Ie);const g=e.attributes.get("position"),x=e.attributes.get("size"),m=e.attributes.get("normal"),A=e.attributes.get("rotation"),d=e.attributes.get("centerOffsetAndDistance");An(g.size>=3);const P=Se(f),z=this.parameters.centerOffsetUnits==="screen";for(let _=0;_<g.data.length/g.size;_++){const N=_*g.size;Y(O,g.data[N],g.data[N+1],g.data[N+2]),Z(O,O,n),Z(O,O,h.viewMatrix);const $=_*d.size;if(Y(F,d.data[$],d.data[$+1],d.data[$+2]),!z&&(O[0]+=F[0],O[1]+=F[1],F[2]!==0)){const R=F[2];I(F,O),q(O,O,V(F,F,R))}const j=_*m.size;if(Y(fe,m.data[j],m.data[j+1],m.data[j+2]),_t(fe,Ie,h,Oe),zt(this.parameters,O,Oe,h,$e),h.applyProjection(O,C),C[0]>-1){z&&(F[0]||F[1])&&(C[0]+=F[0]*h.pixelRatio,F[1]!==0&&(C[1]+=$e.alignmentEvaluator.apply(F[1])*h.pixelRatio),h.unapplyProjection(C,O)),C[0]+=this.parameters.screenOffset[0]*h.pixelRatio,C[1]+=this.parameters.screenOffset[1]*h.pixelRatio,C[0]=Math.floor(C[0]),C[1]=Math.floor(C[1]);const R=_*x.size;B[0]=x.data[R],B[1]=x.data[R+1],$e.evaluator.applyVec2(B,B);const re=ri*h.pixelRatio;let pe=0;f.textureIsSignedDistanceField&&(pe=Math.min(f.outlineSize,.5*B[0])*h.pixelRatio/2),B[0]*=v,B[1]*=p;const oe=_*A.size,K=f.rotation+A.data[oe];if(wt(u,C[0],C[1],B,re,pe,K,f,P)){const ue=i.ray;if(Z(Ye,O,Ct(si,h.viewMatrix)),C[0]=u[0],C[1]=u[1],h.unprojectFromRenderScreen(C,O)){const S=D();T(S,ue.direction);const Pe=1/ie(S);V(S,S,Pe),o(Tt(ue.origin,O)*Pe,S,-1,Ye)}}}}}intersectDraped(e,n,i,s,r){const o=e.attributes.get("position"),l=e.attributes.get("size"),c=e.attributes.get("rotation"),a=this.parameters,u=Se(a),h=e.attributes.get("featureAttribute"),f=h==null?null:Nt(h.data,St),{scaleX:b,scaleY:y}=Pt(f,a,e.screenToWorldRatio),v=ho*e.screenToWorldRatio;for(let p=0;p<o.data.length/o.size;p++){const g=p*o.size,x=o.data[g],m=o.data[g+1],A=p*l.size;B[0]=l.data[A],B[1]=l.data[A+1];let d=0;a.textureIsSignedDistanceField&&(d=Math.min(a.outlineSize,.5*B[0])*e.screenToWorldRatio/2),B[0]*=b,B[1]*=y;const P=p*c.size,z=a.rotation+c.data[P];wt(i,x,m,B,v,d,z,a,u)&&s(r.distance,r.normal,-1)}}createBufferWriter(){return new mo}applyShaderOffsetsView(e,n,i,s,r,o,l){const c=_t(n,i,r,Oe);return this._applyVerticalGroundOffsetView(e,c,r,l),zt(this.parameters,l,c,r,o),this._applyPolygonOffsetView(l,c,s[3],r,l),this._applyCenterOffsetView(l,s,l),l}applyShaderOffsetsNDC(e,n,i,s,r){return this._applyCenterOffsetNDC(e,n,i,s),r!=null&&T(r,s),this._applyPolygonOffsetNDC(s,n,i,s),s}_applyPolygonOffsetView(e,n,i,s,r){const o=s.aboveGround?1:-1;let l=Math.sign(i);l===0&&(l=o);const c=o*l;if(this.parameters.shaderPolygonOffset<=0)return T(r,e);const a=wn(Math.abs(n.cosAngle),.01,1),u=1-Math.sqrt(1-a*a)/a/s.viewport[2];return V(r,e,c>0?u:1/u),r}_applyVerticalGroundOffsetView(e,n,i,s){const r=ie(e),o=i.aboveGround?1:-1,l=i.computeRenderPixelSizeAtDist(r)*Kn,c=V(O,n.normal,o*l);return U(s,e,c),s}_applyCenterOffsetView(e,n,i){const s=this.parameters.centerOffsetUnits!=="screen";return i!==e&&T(i,e),s&&(i[0]+=n[0],i[1]+=n[1],n[2]&&(I(fe,i),Di(i,i,V(fe,fe,n[2])))),i}_applyCenterOffsetNDC(e,n,i,s){const r=this.parameters.centerOffsetUnits!=="screen";return s!==e&&T(s,e),r||(s[0]+=n[0]/i.fullWidth*2,s[1]+=n[1]/i.fullHeight*2),s}_applyPolygonOffsetNDC(e,n,i,s){const r=this.parameters.shaderPolygonOffset;if(e!==s&&T(s,e),r){const o=i.aboveGround?1:-1,l=o*Math.sign(n[3]);s[2]-=(l||o)*r}return s}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:n,outlineColor:i}=this.parameters,s=e[3]>=ce||n>=ce&&i[3]>=ce;return this._visible&&s}createGLMaterial(e){return new ao(e)}calculateRelativeScreenBounds(e,n,i=Dt()){return lo(this.parameters,e,n,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class ao extends ys{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(so,e)}}function lo(t,e,n,i){i[0]=t.anchorPosition[0]*-e[0]+t.screenOffset[0]*n,i[1]=t.anchorPosition[1]*-e[1]+t.screenOffset[1]*n}function _t(t,e,n,i){return Xr(e)&&(e=Pn(uo,e)),Vi(i.normal,t,e),Z(i.normal,i.normal,n.viewInverseTransposeMatrix),i.cosAngle=X(ii,fo),i}function co(t){const e=t[0],n=t[1],i=t[2],s=t[3],r=t[4],o=t[5],l=t[6],c=t[7],a=t[8],u=1/Math.sqrt(e*e+n*n+i*i),h=1/Math.sqrt(s*s+r*r+o*o),f=1/Math.sqrt(l*l+c*c+a*a);return t[0]=e*u,t[1]=n*u,t[2]=i*u,t[3]=s*h,t[4]=r*h,t[5]=o*h,t[6]=l*f,t[7]=c*f,t[8]=a*f,t}function wt(t,e,n,i,s,r,o,l,c){let a=e-s-i[0]*c[0],u=a+i[0]+2*s,h=n-s-i[1]*c[1],f=h+i[1]+2*s;const b=l.distanceFieldBoundingBox;return l.textureIsSignedDistanceField&&b!=null&&(a+=i[0]*b[0],h+=i[1]*b[1],u-=i[0]*(1-b[2]),f-=i[1]*(1-b[3]),a-=r,u+=r,h-=r,f+=r),Ce(cn,e,n),$i(ze,t,cn,bi(o)),ze[0]>a&&ze[0]<u&&ze[1]>h&&ze[1]<f}const $e=new fs,O=D(),fe=D(),C=Qe(),ii=D(),Ye=D(),ze=Rt(),cn=Rt(),Ie=zn(),uo=zn(),si=Xe(),Fe=Qe(),F=D(),ht=D(),St=Qe(),Oe={normal:ii,cosAngle:0},ri=1,ho=2,B=J(0,0),fo=Ae(0,0,1);class po extends ds{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1,this.color=vt(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=J(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=vt(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=Qe(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}class mo{constructor(){this.layout=ei,this.instanceLayout=ni()}elementCount(e){return e.get("position").indices.length}elementCountBaseInstance(e){return e.get("uv0").indices.length}write(e,n,i,s,r,o){const{position:l,normal:c,color:a,size:u,rotation:h,centerOffsetAndDistance:f,featureAttribute:b,uvi:y}=r;gs(i.get("position"),e,l,o),vs(i.get("normal"),n,c,o);const v=i.get("position").indices.length;let p=0,g=0,x=Re,m=Re;const A=i.get("uvi")?.data;A&&A.length>=4&&(p=A[0],g=A[1],x=A[2],m=A[3]);for(let d=0;d<v;++d){const P=o+d;y.setValues(P,p,g,x,m)}if(bs(i.get("color"),4,a,o),Zt(i.get("size"),u,o),xs(i.get("rotation"),h,o),i.get("centerOffsetAndDistance")?Yt(i.get("centerOffsetAndDistance"),f,o):Xt(f,o,v),i.get("featureAttribute")?Yt(i.get("featureAttribute"),b,o):Xt(b,o,v),s!=null){const d=i.get("position")?.indices;if(d){const P=d.length,z=r.getField("olidColor",Hi);$s(s,z,P,o)}}return{numVerticesPerItem:1,numItems:v}}writeBaseInstance(e,n){const{uv0:i}=n;Zt(e.get("uv0"),i,0)}intersect(e,n,i,s,r,o,l){const{options:{selectionMode:c,hud:a,excludeLabels:u},point:h,camera:f}=s;if(!c||!a||u&&n.isLabel||!h)return;const b=this.instanceLayout.createView(e),{position:y,normal:v,rotation:p,size:g,featureAttribute:x,centerOffsetAndDistance:m}=b,A=n.centerOffsetUnits==="screen",d=Se(n);if(y==null||v==null||p==null||g==null||m==null||f==null)return;const P=x==null?null:x.getVec(0,St),{scaleX:z,scaleY:_}=Pt(P,n,f.pixelRatio),N=y.count;for(let $=0;$<N;$++){if(y.getVec($,O),i!=null&&U(O,O,i),Z(O,O,f.viewMatrix),m.getVec($,Fe),Y(F,Fe[0],Fe[1],Fe[2]),!A&&(O[0]+=F[0],O[1]+=F[1],F[2]!==0)){const j=F[2];I(F,O),q(O,O,V(F,F,j))}if(v.getVec($,fe),_t(fe,Ie,f,Oe),zt(n,O,Oe,f,$e),f.applyProjection(O,C),C[0]>-1){A&&(F[0]||F[1])&&(C[0]+=F[0]*f.pixelRatio,F[1]!==0&&(C[1]+=$e.alignmentEvaluator.apply(F[1])*f.pixelRatio),f.unapplyProjection(C,O)),C[0]+=n.screenOffset[0]*f.pixelRatio,C[1]+=n.screenOffset[1]*f.pixelRatio,C[0]=Math.floor(C[0]),C[1]=Math.floor(C[1]),g.getVec($,B),$e.evaluator.applyVec2(B,B);const j=ri*f.pixelRatio;let R=0;n.textureIsSignedDistanceField&&(R=Math.min(n.outlineSize,.5*B[0])*f.pixelRatio/2),B[0]*=z,B[1]*=_;const re=p.get($),pe=n.rotation+re;if(wt(h,C[0],C[1],B,j,R,pe,n,d)){const oe=s.ray;if(Z(Ye,O,Ct(si,f.viewMatrix)),C[0]=h[0],C[1]=h[1],f.unprojectFromRenderScreen(C,O)){const K=D();T(K,oe.direction);const ue=1/ie(K);V(K,K,ue),l(Tt(oe.origin,O)*ue,K,$,Ye)}}}}}}function Pt(t,e,n){return t==null||e.vvSize==null?{scaleX:n,scaleY:n}:(ps(ht,e,t),{scaleX:ht[0]*n,scaleY:ht[1]*n})}function zt(t,e,n,i,s){if(!t.verticalOffset?.screenLength){const c=ie(e);return s.update(n.cosAngle,c,t.screenSizePerspective,t.screenSizePerspectiveMinPixelReferenceSize,t.screenSizePerspectiveAlignment,null),e}const r=ie(e),o=t.screenSizePerspectiveAlignment??t.screenSizePerspective,l=ms(i,r,t.verticalOffset,n.cosAngle,o,t.screenSizePerspectiveMinPixelReferenceSize);return s.update(n.cosAngle,r,t.screenSizePerspective,t.screenSizePerspectiveMinPixelReferenceSize,t.screenSizePerspectiveAlignment,null),V(n.normal,n.normal,l),U(e,e,n.normal)}function oi(t){return"declaredClass"in t}function un(t){return"declaredClass"in t}function go(t){return"declaredClass"in t}function al(t,e,n){return t?go(t)?(t.origin!==n&&(t.origin=n),t):new qs({layer:e,sourceLayer:e,origin:n,visible:t.visible,symbol:en(t.symbol),attributes:en(t.attributes),geometry:vo(t.geometry)}):null}function vo(t){return t==null?null:oi(t)?t:Zs(bo(t))}function bo(t){const{wkid:e,wkt:n,wkt2:i,latestWkid:s}=t.spatialReference,r={wkid:e,wkt:n,wkt2:i,latestWkid:s};switch(t.type){case"point":{const{x:o,y:l,z:c,m:a}=t;return{x:o,y:l,z:c,m:a,spatialReference:r}}case"polygon":{const{rings:o,hasZ:l,hasM:c}=t;return{rings:hn(o),hasZ:l,hasM:c,spatialReference:r}}case"polyline":{const{paths:o,hasZ:l,hasM:c}=t;return{paths:hn(o),hasZ:l,hasM:c,spatialReference:r}}case"extent":{const{xmin:o,xmax:l,ymin:c,ymax:a,zmin:u,zmax:h,mmin:f,mmax:b,hasZ:y,hasM:v}=t;return{xmin:o,xmax:l,ymin:c,ymax:a,zmin:u,zmax:h,mmin:f,mmax:b,hasZ:y,hasM:v,spatialReference:r}}case"multipoint":{const{points:o,hasZ:l,hasM:c}=t;return{points:li(o)?ai(o):o,hasZ:l,hasM:c,spatialReference:r}}default:return}}function hn(t){return xo(t)?t.map(e=>ai(e)):t}function ai(t){return t.map(e=>Array.from(e))}function xo(t){for(const e of t)if(e.length!==0)return li(e);return!1}function li(t){return t.length>0&&(Fs(t[0])||Es(t[0]))}function $o(t,e){if(!t)return null;let n;if(un(t)){if(e==null)return t.clone();if(un(e))return e.copy(t)}return e!=null?(n=e,n.x=t.x,n.y=t.y,n.spatialReference=t.spatialReference,t.hasZ?(n.z=t.z,n.hasZ=t.hasZ):(n.z=void 0,n.hasZ=!1),t.hasM?(n.m=t.m,n.hasM=!0):(n.m=void 0,n.hasM=!1)):(n=Ke(t.x,t.y,t.z,t.spatialReference),t.hasM&&(n.m=t.m,n.hasM=!0)),n}function ll(t){const{wkid:e,wkt:n,wkt2:i,latestWkid:s}=t,r={wkid:e,wkt:n,wkt2:i,latestWkid:s};return Vn.fromJSON(r)}function cl(t,e){if(t.type==="point")return le(t,e,!1);if(oi(t))switch(t.type){case"extent":return le(t.center,e,!1);case"polygon":return le(dn(t),e,!1);case"polyline":return le(fn(t),e,!0);case"mesh":return le(Ns(t.vertexSpace,t.spatialReference)??t.extent.center,e,!1);case"multipoint":return}else switch(t.type){case"extent":return le(yo(t),e,!0);case"polygon":return le(dn(t),e,!0);case"polyline":return le(fn(t),e,!0);case"multipoint":return}}function fn(t){const e=t.paths[0];if(!e||e.length===0)return null;const n=yi(e,_i(e)/2);return Ke(n[0],n[1],n[2],t.spatialReference)}function yo(t){return Ke(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),t.zmin!=null&&t.zmax!=null&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function dn(t){const e=t.rings[0];if(!e||e.length===0)return null;const n=wi(t.rings,!!t.hasZ);return Ke(n[0],n[1],n[2],t.spatialReference)}function le(t,e,n){const i=n?t:$o(t);return e&&t?Hs(t,i,e)?i:null:i}function ul(t){if(!t)return 0;switch(t.type){case"point":return t.z;case"extent":return t.zmax;case"polygon":return t.hasZ?t.rings.reduce((e,n)=>n.reduce((i,s)=>Math.max(i,s[2]),e),-1/0):void 0;case"polyline":return t.hasZ?t.paths.reduce((e,n)=>n.reduce((i,s)=>Math.max(i,s[2]),e),-1/0):void 0;case"mesh":return t.extent.zmax;case"multipoint":return}}function hl(t,e,n,i=0){if(t){e||(e=Dt());const s=t;let r=.5*s.width*(n-1),o=.5*s.height*(n-1);return s.width<1e-7*s.height?r+=o/20:s.height<1e-7*s.width&&(o+=r/20),Ls(e,s.xmin-r-i,s.ymin-o-i,s.xmax+r+i,s.ymax+o+i),e}return null}function fl(t,e,n=null){const i=Li(Bi);return t!=null&&(i[0]=t[0],i[1]=t[1],i[2]=t[2],t.length>3&&(i[3]=t[3])),e!=null&&(i[3]=e),n&&Bs(i,i,n),i}function dl(t,e,n,i,s,r){for(let o=0;o<3;++o)r[o]=t?.[o]!=null?t[o]:n?.[o]!=null?n[o]:s[o];return r[3]=e??i??s[3],r}function pl(t=ji,e,n,i=1){const s=new Array(3);if(e==null||n==null)s[0]=1,s[1]=1,s[2]=1;else{let r,o=0;for(let l=2;l>=0;l--){const c=t[l],a=c!=null,u=l===0&&!r&&!a,h=n[l];let f;c==="symbol-value"||u?f=h!==0?e[l]/h:1:a&&c!=="proportional"&&isFinite(c)&&(f=h!==0?c/h:1),f!=null&&(s[l]=f,r=f,o=Math.max(o,Math.abs(f)))}for(let l=2;l>=0;l--)s[l]==null?s[l]=r:s[l]===0&&(s[l]=.001*o)}for(let r=2;r>=0;r--)s[r]/=i;return Fi(s)}function _o(t){return t.isPrimitive!=null}function ml(t){return wo(_o(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function wo(t){const e=n=>n==null||n>=0;return Array.isArray(t)?t.every(e):e(t)}function gl(t,e,n,i=Xe()){return t&&Ai(i,i,-t/180*Math.PI),e&&Mi(i,i,e/180*Math.PI),n&&Oi(i,i,n/180*Math.PI),i}function vl(t,e,n){if(n.minDemResolution!=null)return n.minDemResolution;const i=Fn(e),s=ks(t)*i,r=Ws(t)*i,o=Gs(t)*(e.isGeographic?1:i);return s===0&&r===0&&o===0?n.minDemResolutionForPoints:.01*Math.max(s,r,o)}function pn(t,e){const n=t[e],i=t[e+1],s=t[e+2];return Math.sqrt(n*n+i*i+s*s)}function So(t,e){const n=t[e],i=t[e+1],s=t[e+2],r=1/Math.sqrt(n*n+i*i+s*s);t[e]*=r,t[e+1]*=r,t[e+2]*=r}function mn(t,e,n){t[e]*=n,t[e+1]*=n,t[e+2]*=n}function Po(t,e,n,i,s,r=e){(s=s||t)[r]=t[e]+n[i],s[r+1]=t[e+1]+n[i+1],s[r+2]=t[e+2]+n[i+2]}function zo(){return gn??=Ao(),gn}function Ao(){const n=new M([0,0,0,255,255,0,255,255],[0,1,2,3],2,!0);return new _s([["uv0",n]])}let gn=null;const ft=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],Mo=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],Oo=[0,0,1,0,1,1,0,1],Co=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],ci=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)ci[6*t+e]=t;const he=new Array(36);for(let t=0;t<6;t++)he[6*t]=0,he[6*t+1]=1,he[6*t+2]=2,he[6*t+3]=2,he[6*t+4]=3,he[6*t+5]=0;function Ro(t,e){Array.isArray(e)||(e=[e,e,e]);const n=new Array(24);for(let i=0;i<8;i++)n[3*i]=ft[i][0]*e[0],n[3*i+1]=ft[i][1]*e[1],n[3*i+2]=ft[i][2]*e[2];return new Q(t,[["position",new M(n,Co,3,!0)],["normal",new M(Mo,ci,3)],["uv0",new M(Oo,he,2)]])}const dt=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],To=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],Do=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],Vo=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function jo(t,e){Array.isArray(e)||(e=[e,e,e]);const n=new Array(18);for(let i=0;i<6;i++)n[3*i]=dt[i][0]*e[0],n[3*i+1]=dt[i][1]*e[1],n[3*i+2]=dt[i][2]*e[2];return new Q(t,[["position",new M(n,Do,3,!0)],["normal",new M(To,Vo,3)]])}const He=G(-.5,0,-.5),ke=G(.5,0,-.5),We=G(0,0,.5),Ge=G(0,.5,0),ve=ee(),be=ee(),ye=ee(),_e=ee(),we=ee();q(ve,He,Ge),q(be,He,ke),ne(ye,ve,be),I(ye,ye),q(ve,ke,Ge),q(be,ke,We),ne(_e,ve,be),I(_e,_e),q(ve,We,Ge),q(be,We,He),ne(we,ve,be),I(we,we);const pt=[He,ke,We,Ge],Fo=[0,-1,0,ye[0],ye[1],ye[2],_e[0],_e[1],_e[2],we[0],we[1],we[2]],Eo=[0,1,2,3,1,0,3,2,1,3,0,2],Uo=[0,0,0,1,1,1,2,2,2,3,3,3];function Lo(t,e){Array.isArray(e)||(e=[e,e,e]);const n=new Array(12);for(let i=0;i<4;i++)n[3*i]=pt[i][0]*e[0],n[3*i+1]=pt[i][1]*e[1],n[3*i+2]=pt[i][2]*e[2];return new Q(t,[["position",new M(n,Eo,3,!0)],["normal",new M(Fo,Uo,3)]])}function bl(t,e,n,i,s={uv:!0}){const r=-Math.PI,o=2*Math.PI,l=-Math.PI/2,c=Math.PI,a=Math.max(3,Math.floor(n)),u=Math.max(2,Math.floor(i)),h=(a+1)*(u+1),f=te(3*h),b=te(3*h),y=te(2*h),v=[];let p=0;for(let m=0;m<=u;m++){const A=[],d=m/u,P=l+d*c,z=Math.cos(P);for(let _=0;_<=a;_++){const N=_/a,$=r+N*o,j=Math.cos($)*z,R=Math.sin(P),re=-Math.sin($)*z;f[3*p]=j*e,f[3*p+1]=R*e,f[3*p+2]=re*e,b[3*p]=j,b[3*p+1]=R,b[3*p+2]=re,y[2*p]=N,y[2*p+1]=d,A.push(p),++p}v.push(A)}const g=new Array;for(let m=0;m<u;m++)for(let A=0;A<a;A++){const d=v[m][A],P=v[m][A+1],z=v[m+1][A+1],_=v[m+1][A];m===0?(g.push(d),g.push(z),g.push(_)):m===u-1?(g.push(d),g.push(P),g.push(z)):(g.push(d),g.push(P),g.push(z),g.push(z),g.push(_),g.push(d))}const x=[["position",new M(f,g,3,!0)],["normal",new M(b,g,3,!0)]];return s.uv&&x.push(["uv0",new M(y,g,2,!0)]),s.offset&&(x[0][0]="offset",x.push(["position",new M(Float64Array.from(s.offset),En(g.length),3,!0)])),new Q(t,x)}function Bo(t,e,n,i){const s=Io(e,n,i);return new Q(t,s)}function Io(t,e,n){const i=t;let s,r;if(n)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],r=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const a=i*(1+Math.sqrt(5))/2;s=[-i,a,0,i,a,0,-i,-a,0,i,-a,0,0,-i,a,0,i,a,0,-i,-a,0,i,-a,a,0,-i,a,0,i,-a,0,-i,-a,0,i],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let a=0;a<s.length;a+=3)mn(s,a,t/pn(s,a));let o={};function l(a,u){a>u&&([a,u]=[u,a]);const h=a.toString()+"."+u.toString();if(o[h])return o[h];let f=s.length;return s.length+=3,Po(s,3*a,s,3*u,s,f),mn(s,f,t/pn(s,f)),f/=3,o[h]=f,f}for(let a=0;a<e;a++){const u=r.length,h=new Array(4*u);for(let f=0;f<u;f+=3){const b=r[f],y=r[f+1],v=r[f+2],p=l(b,y),g=l(y,v),x=l(v,b),m=4*f;h[m]=b,h[m+1]=p,h[m+2]=x,h[m+3]=y,h[m+4]=g,h[m+5]=p,h[m+6]=v,h[m+7]=x,h[m+8]=g,h[m+9]=p,h[m+10]=g,h[m+11]=x}r=h,o={}}const c=Qt(s);for(let a=0;a<c.length;a+=3)So(c,a);return[["position",new M(Qt(s),r,3,!0)],["normal",new M(c,r,3,!0)]]}function xl(t,{normal:e,position:n,color:i,rotation:s,size:r,centerOffsetAndDistance:o,uvi:l,featureAttribute:c,olidColor:a=null}={}){const u=n?Me(n):D(),h=e?Me(e):Ae(0,0,1),f=i?[i[0],i[1],i[2],i.length>3?i[3]:255]:[255,255,255,255],b=r!=null&&r.length===2?r:[1,1],y=s!=null?[s]:[0],v=En(1),p=[["position",new M(u,v,3,!0)],["normal",new M(h,v,3,!0)],["color",new M(f,v,4,!0)],["size",new M(b,v,2)],["rotation",new M(y,v,1,!0)]];if(l&&p.push(["uvi",new M(l,v,l.length)]),o!=null){const g=[o[0],o[1],o[2],o[3]];p.push(["centerOffsetAndDistance",new M(g,v,4)])}if(c){const g=[c[0],c[1],c[2],c[3]];p.push(["featureAttribute",new M(g,v,4)])}return new Q(t,p,null,1,a,void 0,zo())}const Ho=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function $l(t,e=Ho){const n=new Array(12);for(let a=0;a<4;a++)for(let u=0;u<3;u++)n[3*a+u]=e[a][u];const i=[0,1,2,2,3,0],s=[0,0,1],r=[0,0,0,0,0,0],o=[0,0,1,0,1,1,0,1],l=[255,255,255,255],c=[["position",new M(n,i,3,!0)],["normal",new M(s,r,3,!0)],["uv0",new M(o,i,2,!0)],["color",new M(l,r,4,!0)]];return new Q(t,c)}function ko(t,e,n,i,s=!0,r=!0){let o=0;const l=e,c=t;let a=G(0,o,0),u=G(0,o+c,0),h=G(0,-1,0),f=G(0,1,0);i&&(o=c,u=G(0,0,0),a=G(0,o,0),h=G(0,1,0),f=G(0,-1,0));const b=[u,a],y=[h,f],v=n+2,p=Math.sqrt(c*c+l*l);if(i)for(let d=n-1;d>=0;d--){const P=d*(2*Math.PI/n),z=G(Math.cos(P)*l,o,Math.sin(P)*l);b.push(z);const _=G(c*Math.cos(P)/p,-l/p,c*Math.sin(P)/p);y.push(_)}else for(let d=0;d<n;d++){const P=d*(2*Math.PI/n),z=G(Math.cos(P)*l,o,Math.sin(P)*l);b.push(z);const _=G(c*Math.cos(P)/p,l/p,c*Math.sin(P)/p);y.push(_)}const g=new Array,x=new Array;if(s){for(let d=3;d<b.length;d++)g.push(1),g.push(d-1),g.push(d),x.push(0),x.push(0),x.push(0);g.push(b.length-1),g.push(2),g.push(1),x.push(0),x.push(0),x.push(0)}if(r){for(let d=3;d<b.length;d++)g.push(d),g.push(d-1),g.push(0),x.push(d),x.push(d-1),x.push(1);g.push(0),g.push(2),g.push(b.length-1),x.push(1),x.push(2),x.push(y.length-1)}const m=te(3*v);for(let d=0;d<v;d++)m[3*d]=b[d][0],m[3*d+1]=b[d][1],m[3*d+2]=b[d][2];const A=te(3*v);for(let d=0;d<v;d++)A[3*d]=y[d][0],A[3*d+1]=y[d][1],A[3*d+2]=y[d][2];return[["position",new M(m,g,3,!0)],["normal",new M(A,x,3,!0)]]}function vn(t,e,n,i,s,r=!0,o=!0){return new Q(t,ko(e,n,i,s,r,o))}function Wo(t,e,n,i,s,r,o){const l=s?nn(s):G(1,0,0),c=r?nn(r):G(0,0,0);o??=!0;const a=ee();I(a,l);const u=ee();V(u,a,Math.abs(e));const h=ee();V(h,u,-.5),U(h,h,c);const f=G(0,1,0);Math.abs(1-X(a,f))<.2&&Y(f,0,0,1);const b=ee();ne(b,a,f),I(b,b),ne(f,b,a);const y=2*i+(o?2:0),v=i+(o?2:0),p=te(3*y),g=te(3*v),x=te(2*y),m=new Array(3*i*(o?4:2)),A=new Array(3*i*(o?4:2));o&&(p[3*(y-2)]=h[0],p[3*(y-2)+1]=h[1],p[3*(y-2)+2]=h[2],x[2*(y-2)]=0,x[2*(y-2)+1]=0,p[3*(y-1)]=p[3*(y-2)]+u[0],p[3*(y-1)+1]=p[3*(y-2)+1]+u[1],p[3*(y-1)+2]=p[3*(y-2)+2]+u[2],x[2*(y-1)]=1,x[2*(y-1)+1]=1,g[3*(v-2)]=-a[0],g[3*(v-2)+1]=-a[1],g[3*(v-2)+2]=-a[2],g[3*(v-1)]=a[0],g[3*(v-1)+1]=a[1],g[3*(v-1)+2]=a[2]);const d=($,j,R)=>{m[$]=j,A[$]=R};let P=0;const z=ee(),_=ee();for(let $=0;$<i;$++){const j=$*(2*Math.PI/i);V(z,f,Math.sin(j)),V(_,b,Math.cos(j)),U(z,z,_),g[3*$]=z[0],g[3*$+1]=z[1],g[3*$+2]=z[2],V(z,z,n),U(z,z,h),p[3*$]=z[0],p[3*$+1]=z[1],p[3*$+2]=z[2],x[2*$]=$/i,x[2*$+1]=0,p[3*($+i)]=p[3*$]+u[0],p[3*($+i)+1]=p[3*$+1]+u[1],p[3*($+i)+2]=p[3*$+2]+u[2],x[2*($+i)]=$/i,x[2*$+1]=1;const R=($+1)%i;d(P++,$,$),d(P++,$+i,$),d(P++,R,R),d(P++,R,R),d(P++,$+i,$),d(P++,R+i,R)}if(o){for(let $=0;$<i;$++){const j=($+1)%i;d(P++,y-2,v-2),d(P++,$,v-2),d(P++,j,v-2)}for(let $=0;$<i;$++){const j=($+1)%i;d(P++,$+i,v-1),d(P++,y-1,v-1),d(P++,j+i,v-1)}}const N=[["position",new M(p,m,3,!0)],["normal",new M(g,A,3,!0)],["uv0",new M(x,m,2,!0)]];return new Q(t,N)}function yl(t,e,n,i,s,r){i=i||10,s=s==null||s,An(e.length>1);const o=[[0,0,0]],l=[],c=[];for(let a=0;a<i;a++){l.push([0,-a-1,-(a+1)%i-1]);const u=a/i*2*Math.PI;c.push([Math.cos(u)*n,Math.sin(u)*n])}return Go(t,c,e,o,l,s,r)}function Go(t,e,n,i,s,r,o=G(0,0,0)){const l=e.length,c=te(n.length*l*3+(6*i.length||0)),a=te(n.length*l*3+(i?6:0)),u=new Array,h=new Array;let f=0,b=0;const y=D(),v=D(),p=D(),g=D(),x=D(),m=D(),A=D(),d=D(),P=D(),z=D(),_=D(),N=D(),$=D(),j=Je();Y(P,0,1,0),q(v,n[1],n[0]),I(v,v),r?(U(d,n[0],o),I(p,d)):Y(p,0,0,1),bn(v,p,P,P,x,p,xn),T(g,p),T(N,x);for(let S=0;S<i.length;S++)V(m,x,i[S][0]),V(d,p,i[S][2]),U(m,m,d),U(m,m,n[0]),c[f++]=m[0],c[f++]=m[1],c[f++]=m[2];a[b++]=-v[0],a[b++]=-v[1],a[b++]=-v[2];for(let S=0;S<s.length;S++)u.push(s[S][0]>0?s[S][0]:-s[S][0]-1+i.length),u.push(s[S][1]>0?s[S][1]:-s[S][1]-1+i.length),u.push(s[S][2]>0?s[S][2]:-s[S][2]-1+i.length),h.push(0),h.push(0),h.push(0);let R=i.length;const re=i.length-1;for(let S=0;S<n.length;S++){let Pe=!1;S>0&&(T(y,v),S<n.length-1?(q(v,n[S+1],n[S]),I(v,v)):Pe=!0,U(z,y,v),I(z,z),U(_,n[S-1],g),sr(n[S],z,j),jt(j,lr(_,y),d)?(q(d,d,n[S]),I(p,d),ne(x,z,p),I(x,x)):bn(z,g,N,P,x,p,xn),T(g,p),T(N,x)),r&&(U(d,n[S],o),I($,d));for(let ae=0;ae<l;ae++)if(V(m,x,e[ae][0]),V(d,p,e[ae][1]),U(m,m,d),I(A,m),a[b++]=A[0],a[b++]=A[1],a[b++]=A[2],U(m,m,n[S]),c[f++]=m[0],c[f++]=m[1],c[f++]=m[2],!Pe){const it=(ae+1)%l;u.push(R+ae),u.push(R+l+ae),u.push(R+it),u.push(R+it),u.push(R+l+ae),u.push(R+l+it);for(let st=0;st<6;st++){const gi=u.length-6;h.push(u[gi+st]-re)}}R+=l}const pe=n[n.length-1];for(let S=0;S<i.length;S++)V(m,x,i[S][0]),V(d,p,i[S][1]),U(m,m,d),U(m,m,pe),c[f++]=m[0],c[f++]=m[1],c[f++]=m[2];const oe=b/3;a[b++]=v[0],a[b++]=v[1],a[b++]=v[2];const K=R-l;for(let S=0;S<s.length;S++)u.push(s[S][0]>=0?R+s[S][0]:-s[S][0]-1+K),u.push(s[S][2]>=0?R+s[S][2]:-s[S][2]-1+K),u.push(s[S][1]>=0?R+s[S][1]:-s[S][1]-1+K),h.push(oe),h.push(oe),h.push(oe);const ue=[["position",new M(c,u,3,!0)],["normal",new M(a,h,3,!0)]];return new Q(t,ue)}function _l(t,e,n,i,s){const r=Ys(3*e.length),o=new Array(2*(e.length-1));let l=0,c=0;for(let u=0;u<e.length;u++){for(let h=0;h<3;h++)r[l++]=e[u][h];u>0&&(o[c++]=u-1,o[c++]=u)}const a=[["position",new M(r,o,3,!0)]];if(n&&n.length===e.length&&n[0].length===3){const u=te(3*n.length);let h=0;for(let f=0;f<e.length;f++)for(let b=0;b<3;b++)u[h++]=n[f][b];a.push(["normal",new M(u,o,3,!0)])}return i&&a.push(["color",new M(i,Xs(i.length/4),4)]),new Q(t,a,null,2)}function wl(t,e,n,i,s,r=0){const o=new Array(18),l=[[-n,r,s/2],[i,r,s/2],[0,e+r,s/2],[-n,r,-s/2],[i,r,-s/2],[0,e+r,-s/2]],c=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let a=0;a<6;a++)o[3*a]=l[a][0],o[3*a+1]=l[a][1],o[3*a+2]=l[a][2];return new Q(t,[["position",new M(o,c,3,!0)]])}function Sl(t,e){const n=t.getMutableAttribute("position").data;for(let i=0;i<n.length;i+=3){const s=n[i],r=n[i+1],o=n[i+2];Y(xe,s,r,o),Z(xe,xe,e),n[i]=xe[0],n[i+1]=xe[1],n[i+2]=xe[2]}}function No(t,e=t){const n=t.attributes,i=n.get("position").data,s=n.get("normal").data;if(s){const r=e.getMutableAttribute("normal").data;for(let o=0;o<s.length;o+=3){const l=s[o+1];r[o+1]=-s[o+2],r[o+2]=l}}if(i){const r=e.getMutableAttribute("position").data;for(let o=0;o<i.length;o+=3){const l=i[o+1];r[o+1]=-i[o+2],r[o+2]=l}}}function mt(t,e,n,i,s){return!(Math.abs(X(e,t))>s)&&(ne(n,t,e),I(n,n),ne(i,n,t),I(i,i),!0)}function bn(t,e,n,i,s,r,o){return mt(t,e,s,r,o)||mt(t,n,s,r,o)||mt(t,i,s,r,o)}const xn=.99619469809,xe=D();let qo=class{constructor(e,n,i,s){this.material=e,this.buffer=n,this.numVertices=i,this.boundingInfo=s,this.bufferWriter=e.createBufferWriter()}get layout(){return this.bufferWriter.layout}get numTriangles(){return this.numVertices/3}computeUsedMemory(){return this.buffer.byteLength+ur}get renderGeometry(){return this}intersect(e,n,i,s,r,o,l,c){const a=this.bufferWriter,u=this.buffer;a.intersect(u,this.material.parameters,null,e,i,s,(h,f,b)=>ui(h,f,b,e,n,o,l,r,c))}},Zo=class{constructor(e){this.engineGeometry=e;const n=this.material,i=this.engineGeometry,s=i.attributes,r=i.boundingInfo,o=n.createBufferWriter(),l=o.layout,c=o.elementCount(s),a=l.createBuffer(c);o.write(null,null,s,null,a,0),this.renderGeometry=new qo(n,a.buffer,c,r)}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.indexCount}get numTriangles(){return this.numVertices/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce((e,n)=>e+cr(n.data,n.indices),0)}intersect(e,n,i,s,r,o,l,c){const a=this.engineGeometry;this.material.intersect(a,e.transform.transform,e,i,s,(u,h,f)=>ui(u,h,f,e,n,o,l,r,c))}};function ui(t,e,n,i,s,r,o,l,c){if(t<0||s&&!s(i.rayBegin,i.rayEnd,t))return;const a=new fr(r.layerViewUid,r.graphicUid(l),n,o,c);if((i.results.min.distance==null||t<i.results.min.distance)&&i.results.min.set(3,a,t,e,i.transform.transform),(i.results.max.distance==null||t>i.results.max.distance)&&i.results.max.set(3,a,t,e,i.transform.transform),i.options.store===2){const u=new hr(i.results.min.ray);u.set(3,a,t,e,i.transform.transform),i.results.all.push(u)}}let Yo=class{constructor(e,n=null){this.geometry=e,this.textures=n}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}},Xo=class{constructor(e,n,i){this.components=e,this.minScreenSpaceRadius=n,this.pivotOffset=i;const s=Ue(this.components.map(r=>r.geometry));this.numVertices=s.reduce((r,o)=>r+o.numVertices,0)}},Qo=class{constructor(e){this.levels=e,this.levels.sort((n,i)=>n.minScreenSpaceRadius===i.minScreenSpaceRadius?n.numVertices-i.numVertices:n.minScreenSpaceRadius-i.minScreenSpaceRadius)}get materialParameters(){return this.levels[0].components[0].geometry.material.parameters}getMaterials(){const e=[];return this.levels.forEach(n=>n.components.forEach(i=>e.push(i.geometry.material))),Ue(e)}getTextures(){const e=new Array;return this.levels.forEach(n=>n.components.forEach(i=>{i.textures!=null&&e.push(...i.textures)})),Ue(e)}getGeometries(){const e=new Array;return this.levels.forEach(n=>n.components.forEach(i=>{e.push(i.geometry)})),Ue(e)}getEngineGeometries(){return this.getGeometries().map(e=>e.engineGeometry).filter(e=>e!=null)}computeUsedMemory(){const e=this.getGeometries(),n=this.getTextures(),i=e.reduce((s,r)=>s+r.computeUsedMemory(),0);return n.reduce((s,r)=>s+r.usedMemory,0)+i}};function Cl(t){switch(t){case"sphere":case"cube":case"diamond":case"cylinder":case"cone":case"inverted-cone":case"tetrahedron":return!0}return!1}function Rl(t,e){const n=(i,s,r=!1)=>new Qo(i.map(o=>{const l=s(o.tesselation);return r&&No(l),new Xo([new Yo(new Zo(l))],o.minScreenSpaceRadius)}));switch(t){case"sphere":return n([{tesselation:0,minScreenSpaceRadius:0},{tesselation:1,minScreenSpaceRadius:8},{tesselation:2,minScreenSpaceRadius:16},{tesselation:3,minScreenSpaceRadius:50},{tesselation:4,minScreenSpaceRadius:250}],i=>Bo(e,.5,i,!0));case"cube":return n([{tesselation:0,minScreenSpaceRadius:0}],()=>Ro(e,1));case"cone":return n(gt,i=>vn(e,1,.5,i,!1),!0);case"inverted-cone":return n(gt,i=>vn(e,1,.5,i,!0),!0);case"cylinder":return n(gt,i=>Wo(e,1,.5,i,[0,0,1],[0,0,.5]));case"tetrahedron":return n([{tesselation:0,minScreenSpaceRadius:0}],()=>Lo(e,1),!0);case"diamond":return n([{tesselation:0,minScreenSpaceRadius:0}],()=>jo(e,1),!0);default:return}}const gt=[{tesselation:6,minScreenSpaceRadius:0},{tesselation:18,minScreenSpaceRadius:7},{tesselation:64,minScreenSpaceRadius:65}];function At(t,e,n){return t.canvas||(t.canvas=document.createElement("canvas")),t.canvas.width=e,t.canvas.height=n,t.canvas}function Ko(t){const{size:e}=t.definition,n=t.fontString(e);let i=$n.get(n);if(!i){const s=At(ea,0,0).getContext("2d");t.setFontProperties(s,e);const r=s.measureText(ta);i=new Jo(r.actualBoundingBoxAscent,r.actualBoundingBoxDescent),$n.set(n,i)}return i}const $n=new Map;let Jo=class{get maxHeight(){return this.maxAscent+this.maxDescent}constructor(e,n){this.maxAscent=e,this.maxDescent=n}};const ea={canvas:null},ta=(()=>{let t="";for(let e=32;e<127;e++)t+=String.fromCharCode(e);return t})(),Mt=1;class Dl{constructor(e,n,i,s){this.text=e,this._alignment=n,this._parameters=i,this._maxSize=s,this._textWidths=[],this._lineWidths=[],this._renderPixelRatio=null,this._metricsCached=null,this.key=`${e}--${this._parameters.key}-${this._alignment}`,this._lines=e.replaceAll(" ","").split(/\r?\n/)}get displayWidth(){return Math.ceil(this._displayWidth+2*this._horizontalPadding)}get displayHeight(){let e=this._metrics.firstLineAscent;for(let n=0;n<this._lines.length-1;n++)e+=this._lineSpacing;return e+=this._metrics.lastLineDescent,Math.ceil(e+2*this._haloSize+2*this._verticalPadding)}get renderedWidth(){return this._toRoundedRenderUnit(this.displayWidth)}get renderedHeight(){return this._toRoundedRenderUnit(this.displayHeight)}get firstRenderedBaselinePosition(){return this._toRenderUnit(this._firstLineYOffset+this._metrics.firstLineAscent)}get _firstLineYOffset(){return this._verticalPadding+this._haloSize}get _metrics(){if(this._metricsCached==null){const e=At(yn,Ee,Ee).getContext("2d"),n=this._parameters.definition.pixelRatio,i=this._fontSize*n;this._parameters.setFontProperties(e,i);let s=2*this._haloSize;const r=this._parameters.definition.font;r.style!=="italic"&&r.style!=="oblique"&&r.weight!=="bold"&&r.weight!=="bolder"||(s+=.3*e.measureText("A").width),this._textWidths.length=0,this._lineWidths.length=0;let o=0,l=0,c=0,a=0,u=0;this._lines.forEach((g,x)=>{const m=e.measureText(g),A=m.width/n,d=A+s;this._textWidths.push(A),this._lineWidths.push(d),o=Math.max(o,d),a=Math.max(a,m.actualBoundingBoxAscent/n),u=Math.max(u,m.actualBoundingBoxDescent/n),x===0&&(l=m.actualBoundingBoxAscent/n),x===this._lines.length-1&&(c=m.actualBoundingBoxDescent/n)});const h=Ko(this._parameters),f=Math.max(a,h.maxAscent),b=Math.max(u,h.maxDescent),y=l,v=this._parameters.definition.font.decoration==="underline"?b:c,p=o;this._metricsCached=new ia(y,v,f,b,p)}return this._metricsCached}get _lineSpacing(){return(this._midLineHeight+this._linePadding)*this._parameters.definition.lineSpacingFactor}get _midLineHeight(){return this._metrics.midLineHeight}get _linePadding(){return this._midLineHeight*na}get _midLineAscent(){return this._metrics.maxLineAscent}get _renderedFontSize(){return this._toRenderUnit(this._fontSize)}get _fontSize(){return this._parameters.definition.size}get _renderedHaloSize(){return this._toRenderUnit(this._haloSize)}get _haloSize(){return this._parameters.haloSize}get _horizontalPadding(){return this._hasBackground?this._parameters.definition.background.padding[0]:0}get _verticalPadding(){return Math.max(this._hasBackground?this._parameters.definition.background.padding[1]:0,Mt)}get _hasBackground(){return!!this._parameters.backgroundStyle}get renderPixelRatio(){if(this._renderPixelRatio==null){const e=this._parameters.definition.pixelRatio;this._renderPixelRatio=Math.min(e,Math.min(this._maxSize[0]/this.displayWidth,this._maxSize[1]/this.displayHeight))}return this._renderPixelRatio}_getLineXOffset(e){switch(this._alignment){case 0:return this._horizontalPadding;case 1:return(this.displayWidth-this._lineWidths[e])/2;case 2:return this.displayWidth-this._horizontalPadding-this._lineWidths[e]}}render(e,n,i){e.save();const s=n/=this.renderPixelRatio,r=i/=this.renderPixelRatio,o=this._haloSize,l=this._firstLineYOffset+this._metrics.firstLineAscent;n+=o,i+=l;const c=this._haloSize>0;c&&this._renderHalo(e,s,r,o,l),this._parameters.setFontProperties(e,this._renderedFontSize);for(let a=0;a<this._lines.length;++a){const u=this._lines[a],h=this._getLineXOffset(a);c&&(e.globalCompositeOperation="destination-out",e.fillStyle="rgb(0, 0, 0)",this._fillText(e,u,n+h,i),this._renderLineDecoration(e,n+h,i,this._textWidths[a])),e.globalCompositeOperation="source-over",e.fillStyle=this._parameters.textStyle,this._fillText(e,u,n+this._getLineXOffset(a),i),this._renderLineDecoration(e,n+h,i,this._textWidths[a]),i+=this._lineSpacing}if(bt.TEXT_SHOW_BASELINE){e.strokeStyle=_n,e.setLineDash([2,2]),e.lineWidth=1;let a=r+l;for(let u=0;u<this._lines.length;++u)this._drawLine(e,[s,a],[s+this.displayWidth,a]),a+=this._lineSpacing}if(bt.TEXT_SHOW_BORDER&&(e.strokeStyle=_n,e.setLineDash([]),e.lineWidth=1,this._drawBox(e,[s,r],[this.displayWidth,this.displayHeight])),this._hasBackground){const a=this._parameters.definition.background.borderRadius*this.renderPixelRatio;this._roundedRect(e,s,r,a),e.globalCompositeOperation="destination-over",e.fillStyle=this._parameters.backgroundStyle,e.fill()}e.restore()}_renderLineDecoration(e,n,i,s,r=!1){if(this._parameters.definition.font.decoration==="none"||s===0)return;const o=1,l=Math.max(this._parameters.definition.size/16,o);switch(this._parameters.definition.font.decoration){case"underline":i+=2*l;break;case"line-through":i-=.33*this._midLineAscent}const c=r?this._haloSize:0;e.strokeStyle=r?this._parameters.haloStyle:this._parameters.textStyle,e.lineWidth=this._toRenderUnit(l+2*c),e.beginPath(),e.moveTo(this._toRenderUnit(n-c),this._toRenderUnit(i)),e.lineTo(this._toRenderUnit(n+s+c),this._toRenderUnit(i)),e.stroke()}_roundedRect(e,n,i,s){n=this._toRenderUnit(n),i=this._toRenderUnit(i);const r=this.renderedWidth,o=this.renderedHeight;s!==0?(s=wn(s,0,Math.floor(o/2)),e.beginPath(),e.moveTo(n,i+s),e.arcTo(n,i,n+s,i,s),e.lineTo(n+r-s,i),e.arcTo(n+r,i,n+r,i+s,s),e.lineTo(n+r,i+o-s),e.arcTo(n+r,i+o,n+r-s,i+o,s),e.lineTo(n+s,i+o),e.arcTo(n,i+o,n,i+o-s,s),e.closePath()):e.rect(n,i,r,o)}_renderHalo(e,n,i,s,r){const o=this.renderedWidth,l=this.renderedHeight,c=At(yn,Math.max(o,Ee),Math.max(l,Ee)),a=c.getContext("2d");a.clearRect(0,0,o,l),this._parameters.setFontProperties(a,this._renderedFontSize),a.fillStyle=this._parameters.haloStyle,a.strokeStyle=this._parameters.haloStyle;const u=this._renderedHaloSize<3;a.lineJoin=u?"miter":"round",u?this._renderHaloEmulated(a,s,r):this._renderHaloNative(a,s,r);let h=r;for(let f=0;f<this._lines.length;++f){const b=this._getLineXOffset(f);this._renderLineDecoration(a,s+b,h,this._textWidths[f],!0),h+=this._lineSpacing}e.globalAlpha=this._parameters.definition.halo.color[3],e.drawImage(c,0,0,o,l,this._toRenderUnit(n),this._toRenderUnit(i),o,l),e.globalAlpha=1}_renderHaloEmulated(e,n,i){for(let s=0;s<this._lines.length;++s){const r=this._lines[s],o=this._getLineXOffset(s);for(const[l,c]of hi)this._fillText(e,r,n+o+this._haloSize*l,i+this._haloSize*c);i+=this._lineSpacing}}_renderHaloNative(e,n,i){const s=2*this._haloSize;for(let r=0;r<this._lines.length;++r){const o=this._lines[r],l=this._getLineXOffset(r),c=5,a=.1;for(let u=0;u<c;u++){const h=1-(c-1)*a+u*a;e.lineWidth=this._toRenderUnit(h*s),this._strokeText(e,o,n+l,i)}i+=this._lineSpacing}}get _displayWidth(){return this._metrics.displayWidth}_toRenderUnit(e){return e*this.renderPixelRatio}_toRoundedRenderUnit(e){return Math.round(e*this.renderPixelRatio)}_fillText(e,n,i,s){e.fillText(n,this._toRenderUnit(i),this._toRenderUnit(s))}_strokeText(e,n,i,s){e.strokeText(n,this._toRenderUnit(i),this._toRenderUnit(s))}_drawLine(e,n,i){e.beginPath(),e.moveTo(this._toRoundedRenderUnit(n[0])+.5,this._toRoundedRenderUnit(n[1])+.5),e.lineTo(this._toRoundedRenderUnit(i[0])+.5,this._toRoundedRenderUnit(i[1])+.5),e.stroke()}_drawBox(e,n,i){const s=this._toRenderUnit(n[0]),r=this._toRenderUnit(n[1]),o=this._toRenderUnit(i[0]),l=this._toRenderUnit(i[1]),c=Math.floor(s)+.5,a=Math.ceil(s+o)-.5,u=Math.floor(r)+.5,h=Math.ceil(r+l)-.5;e.beginPath(),e.moveTo(c,u),e.lineTo(a,u),e.lineTo(a,h),e.lineTo(c,h),e.lineTo(c,u),e.stroke()}}const hi=[];for(let e=0;e<360;e+=360/16)hi.push([Math.cos(Math.PI*e/180),Math.sin(Math.PI*e/180)]);const yn={canvas:null},na=.2,Ee=512,_n="rgb(255, 0, 255, 0.5)";class ia{get firstLineHeight(){return this.firstLineAscent+this.maxLineDescent}get midLineHeight(){return this.maxLineAscent+this.maxLineDescent}get lastLineHeight(){return this.maxLineAscent+this.lastLineDescent}constructor(e,n,i,s,r){this.firstLineAscent=e,this.lastLineDescent=n,this.maxLineAscent=i,this.maxLineDescent=s,this.displayWidth=r}}const Vl=Object.freeze({left:0,center:.5,right:1}),jl=Object.freeze({"bottom-left":J(0,0),bottom:J(.5,0),"bottom-right":J(1,0),left:J(0,.5),center:J(.5,.5),right:J(1,.5),"top-left":J(0,1),top:J(.5,1),"top-right":J(1,1)});function Fl(t){switch(t){case"left":return 0;case"right":return 2;default:return 1}}function El(t){switch(t){case"bottom-left":case"left":case"top-left":return"left";case"bottom":case"center":case"top":return"center";case"bottom-right":case"right":case"top-right":return"right"}}function Ul(t){switch(t){case"bottom-left":case"bottom":case"bottom-right":return"bottom";case"left":case"center":case"right":return"center";case"top-left":case"top":case"top-right":return"top"}}function Ll(t,e){switch(e){case"bottom":return t==="left"?"bottom-left":t==="right"?"bottom-right":"bottom";case"center":return t;case"top":return t==="left"?"top-left":t==="right"?"top-right":"top"}}function Bl(t){return t==="middle"?"center":t}function Il(t,e){switch(t){case"top":return Ce(e,0,Mt);case"bottom":return Ce(e,0,-Mt);default:return Sn(e,Ri)}}class Ot{constructor(e,n,i,s){this.viewingMode=e,this.spatialReference=n,this.unitInMeters=i,this._coordinateSystem=s,this._tmpCoordinateSystem=Fr(s),this.referenceEllipsoid=jn(n),this.sphericalPCPF=Ln(n)}set extent(e){e&&Er(this._coordinateSystem,e,this._coordinateSystem)}get extent(){return Ur(this._coordinateSystem,Dt())}getAltitude(e){return Nr(this._coordinateSystem,e)}setAltitude(e,n,i=e){return Xn(this._coordinateSystem,i,n,e)}setAltitudeOfTransformation(e,n){qr(this._coordinateSystem,n,e,n)}worldUpAtPosition(e,n){return Hr(this._coordinateSystem,e,n)}worldBasisAtPosition(e,n,i){return kr(this._coordinateSystem,e,n,i)}basisMatrixAtPosition(e,n){const i=this.worldBasisAtPosition(e,0,E.get()),s=this.worldBasisAtPosition(e,1,E.get()),r=this.worldBasisAtPosition(e,2,E.get());return Ci(n,i[0],i[1],i[2],0,s[0],s[1],s[2],0,r[0],r[1],r[2],0,0,0,0,1),n}headingAtPosition(e,n){const i=this.worldUpAtPosition(e,E.get()),s=this.worldBasisAtPosition(e,1,E.get()),r=gr(n,s,i);return xi(r)}intersectManifoldClosestSilhouette(e,n,i){return ut(this._coordinateSystem,n,this._tmpCoordinateSystem),Gr(this._tmpCoordinateSystem,e,i),i}intersectManifold(e,n,i){ut(this._coordinateSystem,n,this._tmpCoordinateSystem);const s=E.get();return Wr(this._tmpCoordinateSystem,e,s)?T(i,s):null}intersectInfiniteManifold(e,n,i){if(this.viewingMode===1)return this.intersectManifold(e,n,i);ut(this._coordinateSystem,n,this._tmpCoordinateSystem);const s=this._tmpCoordinateSystem.value,r=E.get();return jt(s.plane,e,r)?T(i,r):null}toRenderCoords(e,n,i){return an(e)?dr(e,n,this.spatialReference):$t(e,n,i,this.spatialReference)}fromRenderCoords(e,n,i=null){return an(n)?(i!=null&&(n.spatialReference=i),Qn(e,this.spatialReference,n)?n:null):$t(e,this.spatialReference,n,i)?n:null}static create(e,n){switch(e){case 2:return new Ot(2,n,Fn(n),Ir());case 1:return new Ot(1,n,1,Br(n))}}static renderUnitScaleFactor(e,n){return tn(e)/tn(n)}}const Wt=128,de=.5,Hl=vt(de/2,de/2,1-de/2,1-de/2);function kl(t){return t==="cross"||t==="x"}function Wl(t,e=Wt,n=e*de,i=0){const{data:s,parameters:r}=sa(t,e,n,i);return new ws(s,r)}function sa(t,e=Wt,n=e*de,i=0){return{data:ra(t,e,n,i),parameters:{mipmap:!1,wrap:{s:33071,t:33071},width:e,height:e,noUnpackFlip:!0,dataType:Ds.FLOAT,pixelFormat:6403,internalFormat:Ts.R16F,reloadable:!0}}}function ra(t,e=Wt,n=e*de,i=0){switch(t){case"circle":default:return oa(e,n);case"square":return aa(e,n);case"cross":return ca(e,n,i);case"x":return ua(e,n,i);case"kite":return la(e,n);case"triangle":return ha(e,n);case"arrow":return fa(e,n)}}function oa(t,e){const n=t/2-.5;return De(t,pi(n,n,e/2))}function aa(t,e){return fi(t,e,!1)}function la(t,e){return fi(t,e,!0)}function ca(t,e,n=0){return di(t,e,!1,n)}function ua(t,e,n=0){return di(t,e,!0,n)}function ha(t,e){return De(t,mi(t/2,e,e/2))}function fa(t,e){const n=e,i=e/2,s=t/2,r=.8*n,o=pi(s,(t-e)/2-r,Math.sqrt(r*r+i*i)),l=mi(s,n,i);return De(t,(c,a)=>Math.max(l(c,a),-o(c,a)))}function fi(t,e,n){return n&&(e/=Math.SQRT2),De(t,(i,s)=>{let r=i-.5*t+.25,o=.5*t-s-.75;if(n){const l=(r+o)/Math.SQRT2;o=(o-r)/Math.SQRT2,r=l}return Math.max(Math.abs(r),Math.abs(o))-.5*e})}function di(t,e,n,i=0){e-=i,n&&(e*=Math.SQRT2);const s=.5*e;return De(t,(r,o)=>{let l,c=r-.5*t,a=.5*t-o-1;if(n){const u=(c+a)/Math.SQRT2;a=(a-c)/Math.SQRT2,c=u}return c=Math.abs(c),a=Math.abs(a),l=c>a?c>s?Math.sqrt((c-s)*(c-s)+a*a):a:a>s?Math.sqrt(c*c+(a-s)*(a-s)):c,l-=i/2,l})}function pi(t,e,n){return(i,s)=>{const r=i-t,o=s-e;return Math.sqrt(r*r+o*o)-n}}function mi(t,e,n){const i=Math.sqrt(e*e+n*n);return(s,r)=>{const o=Math.abs(s-t)-n,l=r-t+e/2+.75,c=(e*o+n*l)/i,a=-l;return Math.max(c,a)}}function De(t,e){const n=new Float32Array(t*t);for(let i=0;i<t;i++)for(let s=0;s<t;s++)n[s+t*i]=e(s,i)/t;return n}const da=Object.freeze(Object.defineProperty({__proto__:null,build:Jn,calculateAnchorPosition:Se,fullUV:Re},Symbol.toStringTag,{value:"Module"})),Gl=Object.freeze(Object.defineProperty({__proto__:null,build:Ss},Symbol.toStringTag,{value:"Module"})),Nl=Object.freeze(Object.defineProperty({__proto__:null,build:Ps,getRadius:zs},Symbol.toStringTag,{value:"Module"})),ql=Object.freeze(Object.defineProperty({__proto__:null,build:As},Symbol.toStringTag,{value:"Module"})),Zl=Object.freeze(Object.defineProperty({__proto__:null,build:Ms},Symbol.toStringTag,{value:"Module"}));export{Ut as $,wl as A,tl as B,sa as C,jl as D,fl as E,Io as F,et as G,Et as H,ko as I,tt as J,pl as K,Go as L,_l as M,Cr as N,ul as O,Ja as P,vl as Q,ml as R,Cl as S,Wt as T,hl as U,Zo as V,Rl as W,gl as X,bn as Y,In as Z,wo as _,Wl as a,Dl as a0,At as a1,Il as a2,Bl as a3,Fl as a4,Ko as a5,Vl as a6,Ll as a7,an as a8,Qn as a9,nl as aa,el as ab,Pr as ac,Or as ad,kt as ae,Qr as af,Jr as ag,Mt as ah,El as ai,Ul as aj,_r as ak,ra as al,eo as am,Mr as an,Gl as ao,Nl as ap,ql as aq,Zl as ar,xl as b,al as c,$l as d,se as e,qo as f,Xo as g,Qo as h,ol as i,wr as j,ll as k,bl as l,Yo as m,vo as n,de as o,Wo as p,yl as q,vn as r,kl as s,dl as t,Hl as u,Ot as v,cl as w,$o as x,Sl as y,Te as z};
