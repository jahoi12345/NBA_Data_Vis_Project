import{a as H,n as I}from"./Cyclical-BLSxUpe7.js";import{H as z,I as c}from"./ShadowCastClear.glsl-L5KbQEJ_.js";import{af as w,R as N}from"./Point-C1MrKtFQ.js";import{L as T}from"./Polygon-Bn-bHOAm.js";import{n as q,_ as P}from"./vec2f64-rIxtbMRN.js";import{s as k,o as d,H as C}from"./vec32-CBRzfVYF.js";import{n as u}from"./collectionUtils-0LMOubEE.js";import{n as p}from"./projectVectorToVector-CwCL5tOr.js";import{N as b,j as L,b as U,c as V}from"./euclideanLengthMeasurementUtils-_q3RYjK-.js";function _(r,n){if(r==null||n==null)return;const e=v(r,n);return e!=null?c(e,"radians","geographic"):void 0}const v=(()=>{const r=u(),n=u();return(e,t)=>(d(r,e.x,e.y,e.z??0),d(n,t.x,t.y,t.z??0),A(r,n,e.spatialReference,t.spatialReference))})(),A=(()=>{const r=q(),n=u(),e=u();return(t,i,l,f)=>{if(C(t,i))return;const a=b(l),s=b(f);if(a&&s&&N(a,s)&&p(t,l,n,a)&&p(i,f,e,s)){const{azimuth:m}=U(D,n,e,a);return m!=null?w(m,"degrees","radians"):void 0}r[0]=i[0]-t[0],r[1]=i[1]-t[1];let o=T(P,r);return r[0]<0&&(o=E-o),o}})();function Z(r,n,e,t="absolute"){if(n&&e)switch(t){case"absolute":return _(n,e);case"relative":return M(y(r,n,e),"relative");case"relative-bilateral":return M(y(r,n,e),"relative-bilateral")}}function y(r,n,e){if(!r||!n||!e)return;const t=v(r,n),i=v(n,e);return t!=null&&i!=null?c(i-t,"radians","geographic"):void 0}function M(r,n){if(r!=null)switch(n){case"absolute":return B(r);case"relative":{const e=h(r);let t=j.normalize(e,0,!0);return t===-180&&(t=180),c(t,"degrees","geographic")}case"relative-bilateral":{const e=h(r),t=Math.abs(j.normalize(e,0,!0));return c(t,"degrees","geographic")}}}function B(r){const n=h(r),e=F.normalize(n,0,!0);return c(e,"degrees","geographic")}const rr=(()=>{const r=u();return(n,e,t,i,l,f="geodesic")=>{k(r,e);const a=h(l);if(f==="geodesic"){const g=b(t);if(g&&p(r,t,r,g))return L(n,r,a,i,g),n[2]=e[2],!!p(n,g,n,t)}const s=z(a,"geographic","arithmetic"),o=w(s,"degrees","radians"),m=e[0]+i*Math.cos(o),R=e[1]+i*Math.sin(o),$=e[2];return d(n,m,R,$),!0}})();function h(r){if(r!=null)return z(x(r),r.rotationType,"geographic")}function er(r){if(r!=null)return z(x(r),r.rotationType,"arithmetic")}function x(r){return w(r.value,r.unit,"degrees")}const D=new V,E=2*Math.PI,F=H,j=new I(-180,180);export{B as M,h as R,rr as U,_ as j,er as q,M as w,Z as x,A as y};
