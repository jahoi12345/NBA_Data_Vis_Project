import{a2 as U}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{N as V,O as tt,Q as et,R as it,S as st}from"./Polygon-D6wEPb3W-CpL9Efjx.js";import{y as rt,s as ht,u as nt,m as ot,l as at}from"./jsonUtils-CmpazY1u-ateEpj4Q.js";import{O as T}from"./OptimizedFeature-CwRGZPwv-Ddclhn0A.js";import{y as E}from"./aaBoundingRect-CjwcS2F3-D7aII9DY.js";import{G as ut}from"./Extent-CgDMOSRD-CU1qE5Kr.js";let W=class{static fromOptimized(e,t,i=!1,s=!1,r=1){return new Z().initialize(e,t,i,s,r)}static fromJSON(e,t=!1,i=!1){const[s,r]=L(e);return new z().initialize(s,r,t,i,1)}static fromOptimizedCIM(e,t,i=!1,s=!1,r=1){return new Q().initialize(e,t,i,s,r)}static fromJSONCIM(e,t=!1,i=!1,s=1){const[r,n]=L(e);return new B().initialize(r,n,t,i,s)}static fromFeatureSetReader(e){const t=e.readGeometryForDisplay(),i=e.geometryType;return t&&i?this.fromOptimized(t,i):null}static fromFeatureSetReaderCIM(e){const t=e.readGeometryForDisplay(),i=e.geometryType;return t&&i?this.fromOptimizedCIM(t,i):null}static createEmptyOptimized(e,t=!1,i=!1,s=1){return new Z().initialize(new T,e,t,i,s)}static createEmptyJSON(e,t=!1,i=!1){return new z().initialize([],e,t,i,1)}static createEmptyOptimizedCIM(e,t=!1,i=!1,s=1){return new Q().initialize(new T,e,t,i,s)}static createEmptyJSONCIM(e,t=!1,i=!1,s=1){return new B().initialize([],e,t,i,s)}asJSON(){const e=V(this);return this.geometryType==="esriGeometryEnvelope"?{xmin:e[0][0][0],ymin:e[0][0][1],xmax:e[0][2][0],ymax:e[0][2][1]}:this.geometryType==="esriGeometryMultipoint"?{points:e.flat()}:this.geometryType==="esriGeometryPoint"?{x:e[0][0][0],y:e[0][0][1]}:this.geometryType==="esriGeometryPolygon"?{rings:e}:{paths:e}}getCurrentRingArea(){if(this.pathSize<3)return 0;let e,t,i=0;if(this.seekPathStart(),!this.nextPoint())return 0;e=this.x,t=this.y;const s=e,r=t;for(;this.nextPoint();)i+=(e-this.x)*(t+this.y),e=this.x,t=this.y;return i+=(e-s)*(t+r),-.5*i}invertY(){this.yFactor*=-1}},Z=class v extends W{constructor(){super(...arguments),this._end=-1}initialize(t,i,s,r,n){return this.hasZ=s,this.hasM=r,this.geometryType=i,this._stride=2+Number(s)+Number(r),this._geometry=t,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=n,this}reset(){this.initialize(this._geometry,this.geometryType,this.hasZ,this.hasM,this.yFactor)}seekPath(t){if(t>=0&&t<this.totalSize){if(this._pathIndex<t)for(;this._pathIndex<t&&this.nextPath(););else if(this._pathIndex>t)for(;this._pathIndex>t&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(t){const i=this._pathOffset+t*this._stride;return i>=0&&i<this._end&&(this._pointOffset=i,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){return!(this.pathIndex>=this.totalSize-1)&&(this._pathIndex>=0&&(this._pathOffset+=this._stride*this.pathSize),this._pathIndex++,this._pointOffset=this._pathOffset-this._stride,this._end=this._pointOffset+this._stride+this._stride*this.pathSize,!0)}prevPath(){return!(this.pathIndex<=0)&&(this._pathIndex--,this._end=this._pathOffset,this._pathOffset-=this._stride*this.pathSize,this._pointOffset=this._pathOffset-this._stride,!0)}getCurrentPath(){const t=this._end,i=this._geometry.coords,s=this._pathOffset;return new v().initialize(new T([this.pathSize],i.slice(s,t)),this.geometryType,this.hasZ,this.hasM,this.yFactor)}pathLength(){const t=this._end,i=this._stride,s=this._geometry.coords;let r=0;for(let n=this._pathOffset+i;n<t;n+=i){const o=s[n-i],h=s[n-i+1],a=s[n]-o,l=s[n+1]-h;r+=Math.sqrt(a*a+l*l)}return r}startPath(){this._geometry.lengths.push(0)}pushPath(t){this.startPath(),this.pushPoints(t)}pushPoint(t){for(let i=0;i<this._stride;++i)this._geometry.coords.push(t[i]);this._geometry.lengths[this.totalSize-1]++}pushXY(t,i){this._geometry.coords.push(t,i),this._geometry.lengths[this.totalSize-1]++}pushPoints(t){for(const i of t)for(let s=0;s<this._stride;++s)this._geometry.coords.push(i[s]);this._geometry.lengths[this.totalSize-1]+=t.length}pushCursor(t){const i=t.asOptimized();this._geometry.coords.push(...i.coords),this._geometry.lengths.push(...i.lengths)}asOptimized(){const t=this._geometry.clone();if(this.yFactor!==1)for(let i=1;i<t.coords.length;i+=this._stride)t.coords[i]*=this.yFactor;return this.geometryType==="esriGeometryPoint"&&(t.lengths.length=0),t}isClosed(){const t=this._geometry.coords,i=this._pathOffset,s=this._end-this._stride;for(let r=0;r<this._stride;r++)if(t[i+r]!==t[s+r])return!1;return!0}clone(){return new v().initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._geometry.isPoint?1:this._geometry.lengths.reduce((t,i)=>t+i)}get pathSize(){const{lengths:t}=this._geometry;return this._geometry.isPoint?1:this._pathIndex<0||this._pathIndex>t.length-1?0:t[this._pathIndex]}get totalSize(){return this._geometry.isPoint?1:this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(t){this._geometry.coords[this._pointOffset]=t}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(t){this._geometry.coords[this._pointOffset+1]=this.yFactor*t}get z(){return this._geometry.coords[this._pointOffset+2]}set z(t){this._geometry.coords[this._pointOffset+2]=t}get m(){const t=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+t]}set m(t){this._geometry.coords[this._pointOffset+3]=t}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}};function lt(e){const t=[e.x,e.y];return e.z&&t.push(e.z),e.m&&t.push(e.m),t}function L(e){return rt(e)?[e.rings,"esriGeometryPolygon"]:ht(e)?[e.paths,"esriGeometryPolyline"]:nt(e)?[[e.points],"esriGeometryMultipoint"]:ot(e)?[[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]],"esriGeometryEnvelope"]:at(e)?[[[lt(e)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}class z extends W{initialize(t,i,s,r,n){return this._paths=t,this.geometryType=i,this.hasZ=s,this.hasM=r,this._pathIndex=this._pointIndex=-1,this.yFactor=n,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(t){return this._pathIndex=t,this._pointIndex=-1,t>=0&&t<this.totalSize&&(this._currentPath=this._paths[t],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(t){return t>=0&&t<this._currentPath.length&&(this._pointIndex=t,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this.pathIndex>0&&(this._pointIndex=-1,this._pathIndex--,this._currentPath=this._paths[this._pathIndex],!0)}pathLength(){const t=this._currentPath.length,i=this._currentPath;let s=0;for(let r=1;r<t;r++){const n=i[r-1],o=i[r],h=n[0],a=n[1],l=o[0]-h,p=o[1]-a;s+=Math.sqrt(l*l+p*p)}return s}startPath(){this._paths.push([])}getCurrentPath(){return new z().initialize([this._currentPath],this.geometryType,this.hasZ,this.hasM,this.yFactor)}pushPath(t){this._paths.push(t)}pushPoint(t){this._paths[this.totalSize-1].push(t)}pushXY(t,i){this._paths[this.totalSize-1].push([t,i])}pushPoints(t){this._paths[this.totalSize-1].push(...t)}pushCursor(t){const i=V(t);for(const s of i)this.pushPath(s)}asOptimized(){const t=new T;if(this.geometryType==="esriGeometryPoint")t.coords.push(...this._paths[0][0]),t.lengths.length=0;else for(const i of this._paths){for(const s of i)t.coords.push(s[0]),t.coords.push(s[1]*this.yFactor),this.hasZ&&t.coords.push(s[2]),this.hasM&&t.coords.push(s[this._mIndex]);t.lengths.push(i.length)}return t}isClosed(){const t=this._currentPath[0],i=this._currentPath[this._currentPath.length-1];for(let s=0;s<t.length;s++)if(t[s]!==i[s])return!1;return!0}clone(){return new z().initialize(U(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map(t=>t.length).reduce((t,i)=>t+i)}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(t){this._currentPoint[0]=t}get y(){return this.yFactor*this._currentPoint[1]}set y(t){this._currentPoint[1]=this.yFactor*t}get z(){return this._currentPoint[2]}set z(t){this._currentPoint[2]=t}get m(){return this._currentPoint[this._mIndex]}set m(t){this._currentPoint[this._mIndex]=t}get pathIndex(){return this._pathIndex}}const M=4,w=1;let Q=class H extends Z{initialize(t,i,s,r,n){return super.initialize(t,i,s,r,n),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map(o=>new Set)),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const t=new H().initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor);return t._controlPoints=this._controlPoints,t}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(t){this._controlPoints[this.pathIndex].add(t)}getControlPointAt(t){return this._controlPoints[this.pathIndex].has(t)}},B=class $ extends z{initialize(t,i,s,r,n){return super.initialize(t,i,s,r,n)}clone(){return new $().initialize(U(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][M]=w}getControlPoint(){return this._paths[this.pathIndex][this._pointIndex][M]===w}setControlPointAt(t){this._paths[this.pathIndex][t][M]=w}getControlPointAt(t){return this._paths[this.pathIndex][t][M]===w}};const pt=100*222045e-21;function Nt(e){if(e.totalSize===0)return null;const t=tt(e);if(!t)return null;const i=4*(Math.abs(t[0])+Math.abs(t[2])+Math.abs(t[1])+Math.abs(t[3])+1)*pt;let s=0,r=0;e.reset();for(let m=0;e.nextPath();m++){const g=e.getCurrentRingArea();g>r&&(r=g,s=m)}if(e.seekPath(s),e.pathSize===0)return null;e.seekPathStart();const n=et(e);if(Math.abs(r)<=2*i*i)return[(n[0]+n[2])/2,(n[1]+n[3])/2];e.seekPathStart();const o=it(e,E());if(o===null)return null;if(e.totalPoints<4)return o;const h=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],a=[NaN,NaN,NaN,NaN],l=[NaN,NaN,NaN,NaN];let p=!1,u=O(o,e,!0);u.distance===0&&(p=!0,h[0][0]=o[0],h[0][1]=o[1],u=O(o,e,!1)),a[0]=u.distance,l[0]=0;const d=[NaN,NaN];let c=!1,y=.25,f=-1,_=NaN;do if(_=NaN,h[1]=G(e,b(n[0],n[2],y),i,t),isNaN(h[1][0])||isNaN(h[1][1])||(u=O(h[1],e,!1),_=u.distance),!isNaN(_)&&_>i&&k(h[1],e))c=!0,a[1]=_,l[1]=N(h[1],o);else if(!isNaN(_)&&_>f&&(f=_,d[0]=h[1][0],d[1]=h[1][1]),y-=.01,y<.1){if(!(f>=0))break;c=!0,a[1]=f,h[1][0]=d[0],h[1][1]=d[1],l[1]=N(h[1],o)}while(!c);c=!1,y=.5,f=-1;let A=.01,J=1;do if(_=NaN,h[2]=G(e,b(n[0],n[2],y),i,t),isNaN(h[2][0])||isNaN(h[2][1])||(u=O(h[2],e,!1),_=u.distance),!isNaN(_)&&_>i&&k(h[2],e))c=!0,a[2]=_,l[2]=N(h[2],o);else if(!isNaN(_)&&_>f)f=_,d[0]=h[2][0],d[1]=h[2][1];else if(_>f&&(f=_,d[0]=h[2][0],d[1]=h[2][1]),y=.5+A*J,A+=.01,J*=-1,y<.3||y>.7){if(!(f>=0))break;c=!0,a[2]=f,h[2][0]=d[0],h[2][1]=d[1],l[2]=N(h[2],o)}while(!c);c=!1,y=.75,f=-1;do if(_=NaN,h[3]=G(e,b(n[0],n[2],y),i,t),isNaN(h[3][0])||isNaN(h[3][1])||(u=O(h[3],e,!1),_=u.distance),!isNaN(_)&&_>i&&k(h[3],e))c=!0,a[3]=_,l[3]=N(h[3],o);else if(_>f&&(f=_,d[0]=h[3][0],d[1]=h[3][1]),y+=.01,y>.9){if(!(f>=0))break;c=!0,a[3]=f,h[3][0]=d[0],h[3][1]=d[1],l[3]=N(h[3],o)}while(!c);const P=[0,1,2,3],S=p?0:1;let R;for(let m=S;m<4;m++)for(let g=S;g<3;g++){const Y=l[g],D=l[g+1];ft(Y,D)>0&&(R=P[g],P[g]=P[g+1],P[g+1]=R,l[g]=D,l[g+1]=Y)}let q=S,X=0,I=0;for(let m=S;m<4;m++){switch(m){case 0:I=2*a[P[m]];break;case 1:I=1.66666666*a[P[m]];break;case 2:I=1.33333333*a[P[m]];break;case 3:I=a[P[m]]}I>X&&(X=I,q=P[m])}return h[q]}function k(e,t){let i,s,r,n,o=0;for(t.reset();t.nextPath()&&t.nextPoint();)for(i=t.x,s=t.y;t.nextPoint();i=r,s=n)r=t.x,n=t.y,s>e[1]!=n>e[1]&&((r-i)*(e[1]-s)-(n-s)*(e[0]-i)>0?o++:o--);return o!==0}function O(e,t,i){if(i&&k(e,t))return{coord:e,distance:0};let s=1/0,r=0,n=0,o=[0,0],h=[0,0];const a=[0,0];for(t.reset();t.nextPath()&&t.nextPoint();)if(!(t.pathSize<2))for(o[0]=t.x,o[1]=t.y;t.nextPoint();o=h){h=[t.x,t.y],st(a,e,o,h);const l=N(e,a);l<s&&(s=l,r=a[0],n=a[1])}return{coord:[r,n],distance:Math.sqrt(s)}}function G(e,t,i,s){const r=[t,0];let n=1/0,o=1/0,h=!1,a=!1;const l=[[t,s[1]-1],[t,s[3]+1]],p=[0,0],u=[0,0],d=[0,0],c=[[0,0],[0,0]],y=E();for(e.reset();e.nextPath()&&e.nextPoint();)if(!(e.pathSize<2))for(c[0][0]=e.x,c[0][1]=e.y;e.nextPoint();c[0][0]=c[1][0],c[0][1]=c[1][1]){if(c[1][0]=e.x,c[1][1]=e.y,_t(y,c)===null||(u[0]=l[0][0],u[1]=l[0][1],d[0]=l[1][0],d[1]=l[1][1],ct(y,u,d)===0)||!ut(l[0],l[1],c[0],c[1],p))continue;const f=p[1];n>o?f<n&&(n=f,h=!0):f<o&&(o=f,a=!0)}return h&&a?r[1]=(n+o)/2:r[0]=r[1]=NaN,r}function _t(e,t){if(t.length<2)return null;e||(e=E());const[i,s]=t[0],[r,n]=t[1];return e[0]=Math.min(i,r),e[1]=Math.min(s,n),e[2]=Math.max(i,r),e[3]=Math.max(s,n),e}const C=1,F=4,j=3,K=12;function ct(e,t,i){let s=x(t,e),r=x(i,e);const n=e[0],o=e[1],h=e[2],a=e[3];if(s&r)return 0;if(!(s|r))return 4;const l=(s?1:0)|(r?2:0);do{const p=i[0]-t[0],u=i[1]-t[1];if(p>u)s&j?(s&C?(t[1]+=u*(n-t[0])/p,t[0]=n):(t[1]+=u*(h-t[0])/p,t[0]=h),s=x(t,e)):r&j?(r&C?(i[1]+=u*(n-i[0])/p,i[0]=n):(i[1]+=u*(h-i[0])/p,i[0]=h),r=x(i,e)):s?(s&F?(t[0]+=p*(o-t[1])/u,t[1]=o):(t[0]+=p*(a-t[1])/u,t[1]=a),s=x(t,e)):(r&F?(i[0]+=p*(o-i[1])/u,i[1]=o):(i[0]+=p*(a-i[1])/u,i[1]=a),r=x(i,e));else if(s&K?(s&F?(t[0]+=p*(o-t[1])/u,t[1]=o):(t[0]+=p*(a-t[1])/u,t[1]=a),s=x(t,e)):r&K?(r&F?(i[0]+=p*(o-i[1])/u,i[1]=o):(i[0]+=p*(a-i[1])/u,i[1]=a),r=x(i,e)):s?(s&C?(t[1]+=u*(n-t[0])/p,t[0]=n):(t[1]+=u*(h-t[0])/p,t[0]=h),s=x(t,e)):(r&C?(i[1]+=u*(n-i[0])/p,i[0]=n):(i[1]+=u*(h-i[0])/p,i[0]=h),r=x(i,e)),s&r)return 0}while(s|r);return l}function x(e,t){return(e[0]<t[0]?1:0)|(e[0]>t[2]?1:0)<<1|(e[1]<t[1]?1:0)<<2|(e[1]>t[3]?1:0)<<3}function b(e,t,i){return e+(t-e)*i}function N(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])}function ft(e,t){if(e<t)return-1;if(e>t)return 1;if(e===t)return 0;const i=isNaN(e),s=isNaN(t);return i<s?-1:i>s?1:0}export{Nt as I,W as K};
