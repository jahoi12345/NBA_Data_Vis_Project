const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngineJSON-B_JiqPb--bGYiWhlA.js","assets/geometryEngineBase-BQTefT4Y-m-Q4mmSQ.js","assets/_commonjsHelpers-DCkdB7M8-DwXtFsJ3.js","assets/intersectsOperator-15Txaz8P-Bf0O3gnS.js","assets/OperatorIntersects-Cd0VWkC0-Cu7rSpCI.js","assets/ProjectionTransformation-PJc9H7Gq-Rbz84pUM.js","assets/Point2D-CMz7woHH-BVbGGL7p.js","assets/Envelope2D-mFnl8dXR-MYac-bfa.js","assets/Transformation2D-CrydmBdC-D4jE8w-_.js","assets/SimpleGeometryCursor-B92kdZ15-B1Z6elF7.js","assets/jsonMap-Bs3hmeCU-Cusd0Fmz.js","assets/OperatorDefinitions-DP7_WWTp-DP7_WWTp.js","assets/jsonConverter-DmBmaSz7-DJD4mCIi.js","assets/Point-BfTTZoMu-DeJwQYfh.js","assets/index-B0z_nLWi.js","assets/index-Cv2ko1Ob.css","assets/reader-DcGs6kKN-DHJfK-tm.js","assets/containsOperator-tFGgcS35-TZPU481a.js","assets/crossesOperator-AiI_s6tu-mrz4LSeN.js","assets/OperatorCrosses-Dz6C6cpz-DK-wHmAx.js","assets/disjointOperator-DHvyicp1-Ba_Cmt1Z.js","assets/overlapsOperator-HumrnKUU-DpwGJhql.js","assets/OperatorOverlaps-vUip32Hp-DyJuQg00.js","assets/touchesOperator-D8_pTw4V-C04WZWqQ.js","assets/OperatorTouches-5IjJUM5G-CNZ270uL.js","assets/withinOperator-Cm3z_-jX-DPnYoyS7.js","assets/OperatorWithin-6KhEYITL-CwR94xN4.js"])))=>i.map(i=>d[i]);
import{H as O,_ as N}from"./index-B0z_nLWi.js";import{s as Ee,c as lt,aT as V,I as v,a2 as K,o as ut,B as te,bD as ct,bE as dt}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{e as ht,R as B,ah as U,F as ue}from"./Point-BfTTZoMu-DeJwQYfh.js";import{G as ft}from"./projectionUtils-BGH_5_I3-DGwchVO8.js";import{y as mt,N as yt,l as pt,B as gt}from"./aaBoundingBox-Cn49X7ge-BcYPaJ58.js";import{L as Me,y as xt}from"./aaBoundingRect-CjwcS2F3-ri8bmh30.js";import{an as _t,am as Ve,ao as Ft,ap as St,f as It}from"./Polygon-D6wEPb3W-D2MPjRU4.js";import{P as Ge,m as Ie,y as we,f as wt}from"./jsonUtils-CmpazY1u-6pDLj5sx.js";import{l as Be}from"./normalizeUtils-85zLqeMi-C1bdAKNn.js";import{H as Tt,n as Qe,X as Rt,W as vt,o as bt,$ as At,O as pe,J as ge,r as Et}from"./featureConversionUtils-BDA_FXJx-CDxX1Wik.js";import{WhereClauseCache as Mt}from"./WhereClauseCache-B0L2SmwV-NVT3RoWW.js";import{l as De}from"./fieldType-DVUzXtk_-tUuvnZJM.js";import{O as re}from"./OptimizedFeature-CwRGZPwv-Ddclhn0A.js";import{A as j,M as Vt,v as Gt,W as oe,K as $,h as ze,z as Bt,d as Qt,x as Dt,m as zt,c as Pt,N as Z,$ as Ot}from"./FixedIntervalBinParameters-8snYOK8a-DXffLEh-.js";import{t as Nt}from"./QueryEngineCapabilities-DJC_YILC-CshvWf3J.js";import{q as Pe}from"./quantizationUtils-Ceq-Uxsu-DjgKK_0s.js";import{x as Oe,h as xe,T as _e,N as ce,_ as ee,a as Le}from"./lengthUtils-Dt1_RvOO-j3MEdmHu.js";import{q as Ct}from"./utils-CUk96PkC-CJv0qCOi.js";import{X as qt,b as Ne,Z as Ce,v as jt,x as Zt,T as $t,s as kt,F as Ht,M as Lt,n as Jt,q as Ut,d as Wt,f as qe,a as de,y as Yt}from"./utils-BEeBypEk-DQLTC4jR.js";import{o as Xt,c as je}from"./SnappingCandidate-DGkpYqI6-CfPvDre4.js";import{f as Kt,m as ne}from"./date-IqUzANpt-bLKO9IDT.js";import{t as es,r as ts,o as ss,P as is}from"./Extent-CgDMOSRD-Bod5LY6s.js";import{m as rs}from"./FieldsIndex-CimK-TqD--24JoCkp.js";import{p as as}from"./Scheduler-CNrsbccs-Bcg8fWoS.js";const Q=(r,e=Q,t=e.f||(e.f=["assets/geometryEngineJSON-B_JiqPb-.js","assets/geometryEngineBase-BQTefT4Y.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/intersectsOperator-15Txaz8P.js","assets/OperatorIntersects-Cd0VWkC0.js","assets/ProjectionTransformation-PJc9H7Gq.js","assets/Point2D-CMz7woHH.js","assets/Envelope2D-mFnl8dXR.js","assets/Transformation2D-CrydmBdC.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/jsonMap-Bs3hmeCU.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-DmBmaSz7.js","assets/Point-BfTTZoMu.js","assets/reader-DcGs6kKN.js","assets/index-BzxsWNRw.js","assets/index-Cv2ko1Ob.css","assets/containsOperator-tFGgcS35.js","assets/crossesOperator-AiI_s6tu.js","assets/OperatorCrosses-Dz6C6cpz.js","assets/disjointOperator-DHvyicp1.js","assets/overlapsOperator-HumrnKUU.js","assets/OperatorOverlaps-vUip32Hp.js","assets/touchesOperator-D8_pTw4V.js","assets/OperatorTouches-5IjJUM5G.js","assets/withinOperator-Cm3z_-jX.js","assets/OperatorWithin-6KhEYITL.js"]))=>r.map(s=>t[s]),Ze=new re,ns=new re,Fe=new re,he={esriGeometryPoint:pe,esriGeometryPolyline:At,esriGeometryPolygon:bt,esriGeometryMultipoint:vt};function fe(r,e,t,s=r.hasZ,i=r.hasM){if(e==null)return null;const a=r.hasZ&&s,n=r.hasM&&i;if(t){const o=ge(Fe,e,r.hasZ,r.hasM,"esriGeometryPoint",t,s,i);return pe(o,a,n)}return pe(e,a,n)}function D(r,e,t,s,i,a,n=e,o=t){const u=e&&n,l=t&&o,c=s!=null?"coords"in s?s:s.geometry:null;if(c==null)return null;if(i){let d=Rt(ns,c,e,t,r,i,n,o);return a&&(d=ge(Fe,d,u,l,r,a)),he[r]?.(d,u,l)??null}if(a){const d=ge(Fe,c,e,t,r,a,n,o);return he[r]?.(d,u,l)??null}return Et(Ze,c,e,t,n,o),he[r]?.(Ze,u,l)??null}function se(r){return r&&Je in r?JSON.parse(JSON.stringify(r,os)):r}const Je="_geVersion",os=(r,e)=>r===Je?void 0:e,Ue=new Mt(50,500),ie="unsupported-query",We=" as ",Ye=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),Xe=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),ls=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...Ye,...Xe]);function Te(r,e,t={}){const s=k(e,r);if(!s){const a=Ue.getError(e,r);throw new v(ie,"invalid SQL expression",{expression:e,error:a})}const i=t.expressionName||"expression";if(t.validateStandardized&&!s.isStandardized)throw new v(ie,`${i} is not standard`,{expression:e});if(t.validateAggregate&&!s.isAggregate)throw new v(ie,`${i} does not contain a valid aggregate function`,{expression:e});return s.fieldNames}function us(r,e,t,s){if(!t)return!0;const i="where clause";return C(r,e,Te(r,t,{validateStandardized:!0,expressionName:i}),{expressionName:i,query:s}),!0}function cs(r,e,t,s,i){if(!t)return!0;const a="having clause",n=Te(r,t,{validateAggregate:!0,expressionName:a});if(C(r,e,n,{expressionName:a,query:i}),!k(t,r)?.getExpressions().every(o=>{const{aggregateType:u,field:l}=o,c=r.get(l)?.name;return s.some(d=>{const{onStatisticField:h,statisticType:m}=d;return r.get(h)?.name===c&&m.toLowerCase().trim()===u})}))throw new v(ie,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function k(r,e){return r?Ue.get(r,e):null}function Ke(r){return/\((.*?)\)/.test(r)?r:r.split(We)[0]}function ds(r){return r.split(We)[1]}function C(r,e,t,s={}){const i=new Map;if(hs(i,r,e,s.allowedFieldTypes??ls,t),i.size){const a=s.expressionName??"expression";throw new v(ie,`${a} contains invalid or missing fields`,{errors:Array.from(i.values()),query:s.query})}}function hs(r,e,t,s,i){const a=i.includes("*")?[...t,...i.filter(n=>n!=="*")]:i;for(const n of a)if(e.get(n))$e(r,e,t,s,n);else try{const o=Te(e,Ke(n),{validateStandardized:!0});for(const u of o)$e(r,e,t,s,u)}catch(o){r.set(n,{type:"expression-error",expression:n,error:o})}}function $e(r,e,t,s,i){const a=e.get(i);a?t.has(a.name)?s!=="all"&&s?.has(a.type)===!1&&r.set(i,{type:"invalid-type",fieldName:a.name,fieldType:De.fromJSON(a.type),allowedFieldTypes:Array.from(s,n=>De.fromJSON(n))}):r.set(i,{type:"missing-field",fieldName:a.name}):r.set(i,{type:"invalid-field",fieldName:i})}const fs=5;let ms=class{constructor(){this._storage=new Map,this._purgeInterval=fs,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const r=1e3*this._purgeInterval,e=performance.now()-r;for(const[t,s]of this._storage){if(!(s.time<e))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,r)));this._storage.delete(t)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}put(r,e){this._storage?.set(r,new ps(e)),this._scheduleSweep()}get(r){const e=this._storage?.get(r);if(e)return this._storage?.delete(r),e.time=performance.now(),this._storage?.set(r,e),e.items}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}get test(){}},ys=0,ps=class{constructor(r){this.items=r,this.time=performance.now(),this.id=ys++}},Y=class{constructor(r,e,t){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=r.returnDistinctValues??!1,this.fieldsIndex=t,this.featureAdapter=e;const s=r.outFields;if(s&&!s.includes("*")){this.outFields=s;let i=0;for(const a of s){const n=Ke(a),o=this.fieldsIndex.get(n),u=o?null:k(n,t),l=o?o.name:ds(a)||"FIELD_EXP_"+i++;this._fieldDataCache.set(a,{alias:l,clause:u})}}}countDistinctValues(r){return this.returnDistinctValues?(r.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):r.length}getAttributes(r){const e=this._processAttributesForOutFields(r);return this._processAttributesForDistinctValues(e)}getFieldValue(r,e,t){const s=t?t.name:e;let i=null;return this._fieldDataCache.has(s)?i=this._fieldDataCache.get(s)?.clause:t||(i=k(e,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:i})),t?this.featureAdapter.getAttribute(r,s):i?.calculateValue(r,this.featureAdapter)}getDataValues(r,e,t=!0){const s=e.normalizationType,i=e.normalizationTotal,a=this.fieldsIndex.get(e.field),n=xe(a)||_e(a),o=ee(a);return r.map(u=>{let l=e.field&&this.getFieldValue(u,e.field,this.fieldsIndex.get(e.field));if(e.field2?(l=`${de(l)}${e.fieldDelimiter}${de(this.getFieldValue(u,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(l=`${l}${e.fieldDelimiter}${de(this.getFieldValue(u,e.field3,this.fieldsIndex.get(e.field3)))}`)):typeof l=="string"&&t&&(n?l=l?new Date(l).getTime():null:o&&(l=l?Ct(l):null)),s&&Number.isFinite(l)){const c=s==="field"&&e.normalizationField?this.getFieldValue(u,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;l=Yt(l,s,c,i)}return l})}async getExpressionValues(r,e,t,s,i){const{arcadeUtils:a}=await Le(),n=a.hasGeometryOperations(e);n&&await a.enableGeometryOperations();const o=a.createFunction(e),u=a.getViewInfo(t),l={fields:this.fieldsIndex.fields};return r.map(c=>{const d={attributes:this.featureAdapter.getAttributes(c),layer:l,geometry:n?{...D(s.geometryType,s.hasZ,s.hasM,this.featureAdapter.getGeometry(c)),spatialReference:t?.spatialReference}:null},h=a.createExecContext(d,u,i);return a.executeFunction(o,h)})}validateItem(r,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:k(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testFeature(r,this.featureAdapter)??!1}validateItems(r,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:k(e,this.fieldsIndex)}),this._fieldDataCache.get(e)?.clause?.testSet(r,this.featureAdapter)??!1}_processAttributesForOutFields(r){const e=this.outFields;if(!e?.length)return this.featureAdapter.getAttributes(r);const t={};for(const s of e){const{alias:i,clause:a}=this._fieldDataCache.get(s);t[i]=a?a.calculateValue(r,this.featureAdapter):this.featureAdapter.getAttribute(r,i)}return t}_processAttributesForDistinctValues(r){if(r==null||!this.returnDistinctValues)return r;const e=this.outFields,t=[];if(e)for(const a of e){const{alias:n}=this._fieldDataCache.get(a);t.push(r[n])}else for(const a in r)t.push(r[a]);const s=`${(e||["*"]).join(",")}=${t.join(",")}`;let i=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++i),i>1?null:r}};const J="bin";class A{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new Y(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query;if(!t?.length)return 1;const a=new Map,n=new Map,o=new Set;for(const u of i){const{statisticType:l}=u,c=l!=="exceedslimit"?u.onStatisticField:void 0;if(!n.has(c)){const h=[];for(const m of t){const f=this._getAttributeValues(e,m,this.items,a);h.push(f)}n.set(c,this._calculateUniqueValues(h,this.items,e.returnDistinctValues))}const d=n.get(c);for(const h in d){const{data:m,items:f}=d[h],y=m.join(",");s&&!e.validateItems(f,s)||o.add(y)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;U(this.query.outSR)&&!B(t.spatialReference,this.query.outSR)?e.queryGeometry=se({spatialReference:this.query.outSR,...$(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=se({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,s){const i=this.featureAdapter,a=ke(this.hasZ,this.hasM),{point:n,mode:o}=e,u=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,c={candidates:[]},d=this.geometryType==="esriGeometryPolygon",h=this.geometryType==="esriGeometryPolyline"||this.geometryType==="esriGeometryPoint",m=this._getPointCreator(o,t,this.spatialReference,s),f=new He(null,0),y=new He(null,0),S={x:0,y:0,z:0};for(const I of this.items){const w=i.getGeometry(I);if(w==null)continue;const{coords:F}=w,x=w.isPoint?xs:w.lengths;if(f.coords=F,y.coords=F,e.returnEdge){let g=0;for(let _=0;_<x.length;_++){const p=x[_],T=g;for(let R=0;R<p;R++,g+=a){if(!d&&R===p-1)continue;const E=f;E.coordsIndex=g;const b=y;b.coordsIndex=R===p-1?T:g+a;const z=S;if(!gs(S,n,E,b))continue;const M=(n.x-z.x)/u,G=(n.y-z.y)/l,q=M*M+G*G;q<=1&&c.candidates.push(Xt(i.getObjectId(I),m(z),Math.sqrt(q),m(E),m(b)))}}}if(e.vertexMode==="all"){let g=0;for(let _=0;_<x.length;_++){const p=x[_],T=g,R=y;R.coordsIndex=T;for(let E=0;E<p;E++,g+=a){const b=f;if(b.coordsIndex=g,d&&E===p-1&&b.x===R.x&&b.y===R.y)continue;const z=(n.x-b.x)/u,M=(n.y-b.y)/l,G=z*z+M*M;G<=1&&c.candidates.push(je(i.getObjectId(I),m(b),Math.sqrt(G)))}}}else if(h&&e.vertexMode==="ends"){let g=0;const _=[];for(let p=0;p<x.length;p++){_.push(g);const T=x[p];g+=T*a,!d&&T>1&&_.push(g-a)}for(const p of _){const T=f;T.coordsIndex=p;const R=(n.x-T.x)/u,E=(n.y-T.y)/l,b=R*R+E*E;b<=1&&c.candidates.push(je(i.getObjectId(I),m(T),Math.sqrt(b)))}}}return c.candidates.sort((I,w)=>I.distance-w.distance),c}_getPointCreator(e,t,s,i){const a=i==null||B(s,i)?u=>u:u=>$(u,s,i),{hasZ:n}=this,o=0;return e==="3d"?n&&t?({x:u,y:l,z:c})=>a({x:u,y:l,z:c}):({x:u,y:l})=>a({x:u,y:l,z:o}):({x:u,y:l})=>a({x:u,y:l})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,minValue:o,maxValue:u,scale:l,timeZone:c,outStatisticTypes:d}=e,h=this.fieldsIndex.get(t),m=Oe(h)||xe(h)||_e(h),f=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:l,timeZone:c},this.items),y=qt({normalizationType:a,normalizationField:i,minValue:o,maxValue:u}),S={value:.5,fieldType:h?.type},I=ce(h)?Ne({values:f,supportsNullCount:y,percentileParams:S,outStatisticTypes:d}):Ce({values:f,minValue:o,maxValue:u,useSampleStdDev:!a,supportsNullCount:y,percentileParams:S,outStatisticTypes:d});return jt(I,d,m)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domains:i,returnAllCodedValues:a,scale:n,timeZone:o}=e,u=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:s,scale:n,timeZone:o},this.items,!1),l=Zt(u);return $t(l,i,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:u,minValue:l,maxValue:c,numClasses:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:h,timeZone:m},this.items),y=kt(f,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:u,minValue:l,maxValue:c,numClasses:d});return Ht(y,o)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:u,minValue:l,maxValue:c,numBins:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:n,scale:h,timeZone:m},this.items);return Lt(f,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:u,minValue:l,maxValue:c,numBins:d})}_sortFeatures(e,t,s){if(e.length>1&&t?.length)for(const i of t.slice().reverse()){const a=i.split(" "),n=a[0],o=this.fieldsIndex.get(n),u=!!a[1]&&a[1].toLowerCase()==="desc",l=Jt(o?.type,u);e.sort((c,d)=>{const h=s(c,n,o),m=s(d,n,o);return l(h,m)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:s,hasM:i,hasZ:a,objectIdField:n,spatialReference:o}=this,{outFields:u,outSR:l,quantizationParameters:c,resultRecordCount:d,resultOffset:h,returnZ:m,returnM:f}=e,y=d!=null&&t.length>(h||0)+d,S=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map(I=>this.fieldsIndex.get(I)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:S,geometryType:s,hasM:i&&f,hasZ:a&&m,objectIdFieldName:n,spatialReference:se(l||o),transform:c&&Pe(c)||null}}_createFeatures(e,t){const s=new Y(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:a}=this,{orderByFields:n,quantizationParameters:o,returnGeometry:u,returnCentroid:l,maxAllowableOffset:c,resultOffset:d,resultRecordCount:h,returnZ:m=!1,returnM:f=!1}=e,y=a&&m,S=i&&f;let I=[],w=0;const F=[...t];if(this._sortFeatures(F,n,(g,_,p)=>s.getFieldValue(g,_,p)),this.geometryType&&(u||l)){const g=Pe(o)??void 0,_=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(u&&!l)for(const p of F){const T=this.featureAdapter.getGeometry(p),R=this._addFeatureJSONMetadata(p,{attributes:s.getAttributes(p),geometry:D(this.geometryType,this.hasZ,this.hasM,T,c,g,y,S)});_&&T&&!R.geometry&&(R.centroid=fe(this,this.featureAdapter.getCentroid(p,this),g)),I[w++]=R}else if(!u&&l)for(const p of F)I[w++]=this._addFeatureJSONMetadata(p,{attributes:s.getAttributes(p),centroid:fe(this,this.featureAdapter.getCentroid(p,this),g)});else for(const p of F)I[w++]=this._addFeatureJSONMetadata(p,{attributes:s.getAttributes(p),centroid:fe(this,this.featureAdapter.getCentroid(p,this),g),geometry:D(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),c,g,y,S)})}else for(const g of F){const _=s.getAttributes(g);_&&(I[w++]=this._addFeatureJSONMetadata(g,{attributes:_}))}const x=d||0;if(h!=null){const g=x+h;I=I.slice(x,Math.min(I.length,g))}return I}_addFeatureJSONMetadata(e,t){const s=this.featureAdapter.getMetadata?.(e);return s!==void 0&&(t.metadata=s),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if(a.statisticType==="exceedslimit"){t=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,s=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,i=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>t;else if(this.items.length>s)e=!0;else{const a=ke(this.hasZ,this.hasM),n=this.featureAdapter;e=this.items.reduce((o,u)=>{const l=n.getGeometry(u);return o+(l!=null&&l.coords.length||0)},0)/a>i}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,s={attributes:{}}){const i=[],a=new Map,n=new Map,o=new Map,u=new Map,l=new Y(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:d,having:h,orderByFields:m,resultRecordCount:f}=e,y=d?.length,S=!!y,I=S?d[0]:null,w=S&&!this.fieldsIndex.get(I);for(const x of c??[]){const{outStatisticFieldName:g,statisticType:_}=x,p=x,T=_!=="exceedslimit"?x.onStatisticField:void 0,R=_==="percentile_disc"||_==="percentile_cont",E=_==="EnvelopeAggregate"||_==="CentroidAggregate"||_==="ConvexHullAggregate",b=S&&y===1&&(T===I||w)&&_==="count";if(S){if(!o.has(T)){const q=[];for(const le of d){const ae=this._getAttributeValues(l,le,t,a);q.push(ae)}o.set(T,this._calculateUniqueValues(q,t,!E&&l.returnDistinctValues))}const M=o.get(T);if(!M)continue;const G=Object.keys(M);for(const q of G){const{count:le,data:ae,items:ve,itemPositions:at}=M[q],be=ae.join(",");if(!h||l.validateItems(ve,h)){const L=u.get(be)||{attributes:{}};if(E){L.aggregateGeometries||(L.aggregateGeometries={});const{aggregateGeometries:P,outStatisticFieldName:W}=await this._getAggregateGeometry(p,ve);L.aggregateGeometries[W]=P}else{let P=null;if(b)P=le;else{const W=this._getAttributeValues(l,T,t,a),Ae=at.map(ot=>W[ot]);P=R&&"statisticParameters"in p?this._getPercentileValue(p,Ae):this._getStatisticValue(p,Ae,null,l.returnDistinctValues)}L.attributes[g]=P}let nt=0;d.forEach((P,W)=>L.attributes[this.fieldsIndex.get(P)?P:"EXPR_"+ ++nt]=ae[W]),u.set(be,L)}}}else if(E){s.aggregateGeometries||(s.aggregateGeometries={});const{aggregateGeometries:M,outStatisticFieldName:G}=await this._getAggregateGeometry(p,t);s.aggregateGeometries[G]=M}else{const M=this._getAttributeValues(l,T,t,a);s.attributes[g]=R&&"statisticParameters"in p?this._getPercentileValue(p,M):this._getStatisticValue(p,M,n,l.returnDistinctValues)}const z=_!=="min"&&_!=="max"||!ce(this.fieldsIndex.get(T))&&!this._isAnyDateField(T)?null:this.fieldsIndex.get(T)?.type;i.push({name:g,alias:g,type:z||"esriFieldTypeDouble"})}const F=S?Array.from(u.values()):[s];return this._sortFeatures(F,m,(x,g)=>x.attributes[g]),f&&(F.length=Math.min(f,F.length)),{fields:i,features:F}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return Oe(t)||xe(t)||_e(t)||ee(t)}async _getAggregateGeometry(e,t){const{convexHull:s,union:i}=await O(()=>N(()=>import("./geometryEngineJSON-B_JiqPb--bGYiWhlA.js"),__vite__mapDeps([0,1,2])).then(y=>y.g),Q([0,1,2])),{statisticType:a,outStatisticFieldName:n}=e,{featureAdapter:o,spatialReference:u,geometryType:l,hasZ:c,hasM:d}=this,h=t.map(y=>D(l,c,d,o.getGeometry(y))),m=s(u,h,!0)[0],f={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const y=m?_t(m):Ve(i(u,h));f.aggregateGeometries={...y,spatialReference:u},f.outStatisticFieldName=n||"extent"}else if(a==="CentroidAggregate"){const y=m?Ft(m):St(Ve(i(u,h)));f.aggregateGeometries={x:y[0],y:y[1],spatialReference:u},f.outStatisticFieldName=n||"centroid"}else a==="ConvexHullAggregate"&&(f.aggregateGeometries=m,f.outStatisticFieldName=n||"convexHull");return f}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:n}=e;let o=null;return o=s?.has(a)?s.get(a):ce(this.fieldsIndex.get(a))||this._isAnyDateField(a)?Ne({values:t,returnDistinct:i}):Ce({values:i?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,o),o[n==="var"?"variance":n]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:n,orderBy:o}=i,u=this.fieldsIndex.get(s);return Ut(t,{value:n,orderBy:o,fieldType:u?.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,s,i){if(i.has(t))return i.get(t);const a=this.fieldsIndex.get(t),n=s.map(o=>e.getFieldValue(o,t,a));return i.set(t,n),n}_calculateUniqueValues(e,t,s){const i={},a=t.length;for(let n=0;n<a;n++){const o=t[n],u=[];for(const c of e)u.push(c[n]);const l=u.join(",");i[l]==null?i[l]={count:1,data:u,items:[o],itemPositions:[n]}:(s||i[l].count++,i[l].items.push(o),i[l].itemPositions.push(n))}return i}async _getDataValues(e,t,s=!0){const i=new Y(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:n,timeZone:o}=e;return a?i.getExpressionValues(t,a,{viewingMode:"map",scale:n,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},o):i.getDataValues(t,K(e),s)}_calculateHistogramBins(e,t,s){if(t.min==null&&t.max==null)return[];const i=t.intervals,a=t.min??0,n=t.max??0,o=i.map(([u,l])=>({minValue:u,maxValue:l,count:0,items:[]}));for(let u=0;u<e.length;u++){const l=e[u],c=s[u];if(l!=null&&l>=a&&l<=n){const d=Wt(i,l);d>-1&&(o[d].count++,o[d].items.push(c))}}return o}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:s,outAlias:i,valueType:a}=t,n=[],o=[{name:i??s,alias:i??s,type:a??"esriFieldTypeString"},{name:J,alias:J,type:"esriFieldTypeInteger"}],u=new Y(e,this.featureAdapter,this.fieldsIndex),l=new Map,c=[...this.items];this._sortFeatures(c,[s],(m,f,y)=>u.getFieldValue(m,f,y));const d=this._getAttributeValues(u,s,c,l),h=this._calculateUniqueValues([d],c,u.returnDistinctValues);for(const m in h){const{items:f}=h[m],y=await this._createBinsResponse(e,f);if(n.push(...y.features.map(S=>({...S,attributes:{...S.attributes,[i??s]:m}}))),y.fields)for(const S of y.fields)o.some(I=>I.name===S.name)||o.push(S)}return{fields:o,features:n}}async _createBinsResponse(e,t){const s=e.bin;switch(t=t??this.items,s.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(Pt.fromJSON(s),e,t);case"dateBin":return this._createDateBinsResponse(zt.fromJSON(s),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(Dt.fromJSON(s),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(Qt.fromJSON(s),e,t)}}async _createAutoIntervalBinsResponse(e,t,s){const{field:i,normalizationField:a,numBins:n,normalizationType:o,normalizationTotal:u,start:l,end:c}=e,d=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},s),h=qe(d,{field:i,normalizationField:a,normalizationType:o,normalizationTotal:u,numBins:n,minValue:Z(l,!1),maxValue:Z(c,!1)}),m=this._calculateHistogramBins(d,h,s);return this._createFeaturesFromHistogramBins(m,t)}async _createDateBinsResponse(e,t,s){const{field:i,interval:a,start:n,end:o,snapToData:u,returnFullIntervalBin:l}=e,c=a.unit,d=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},s),h=ee(this.fieldsIndex.get(i)),m=Ot.toJSON(c),f=d.filter(Boolean).sort((F,x)=>F-x),y=n!=null?Z(n,h):f[0],S=o!=null?Z(o,h):f[f.length-1],I=[];if(y!=null&&S!=null){const F={zone:t.outTimeReference?.ianaTimeZone??Kt},x=ne.fromMillis(y,F),g=ne.fromMillis(S,F);if(u==="last"){let _=g;for(;_>x;){const p=_.minus({[m]:a.value});if(p<x){I.unshift([l?p.toMillis():x.toMillis(),_.toMillis()]);break}I.unshift([p.toMillis(),_.toMillis()]),_=p}}else{let _=u==="first"?x:x.startOf(m);for(;_<=g;){const p=_.plus({[m]:a.value});if(p>g){I.push([_.toMillis(),l?p.toMillis():g.toMillis()]);break}I.push([_.toMillis(),p.toMillis()]),_=p}}}const w=this._calculateHistogramBins(d,{intervals:I,min:y,max:S},s);return this._createFeaturesFromHistogramBins(w,t)}async _createFixedBoundariesBinsResponse(e,t,s){const{field:i}=e,a=await this._getDataValues({field:i,timeZone:t.outTimeReference?.ianaTimeZone},s),n=ee(this.fieldsIndex.get(i)),o=e.boundaries.map(d=>Z(d,n)).sort((d,h)=>d-h),u=[];for(let d=0;d<o.length-1;d++)u.push([o[d],o[d+1]]);const l={intervals:u,min:o.at(0),max:o.at(-1)},c=this._calculateHistogramBins(a,l,s);return this._createFeaturesFromHistogramBins(c,t)}async _createFixedIntervalBinsResponse(e,t,s){const{field:i,interval:a,start:n,end:o}=e,u=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},s),l=ee(this.fieldsIndex.get(i)),c=qe(u,{field:i,classificationMethod:"defined-interval",definedInterval:a,minValue:Z(n,l),maxValue:Z(o,l)},!0),d=this._calculateHistogramBins(u,c,s);return this._createFeaturesFromHistogramBins(d,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:s,lowerBoundaryAlias:i}=t,a=i||"lowerBoundary",n=s||"upperBoundary",o=[],u=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:n,alias:n,type:"esriFieldTypeDouble"}],l=t.bin?.stackBy?.value,c=t.bin?.stackBy?.outAlias;l&&u.push({name:J,alias:J,type:"esriFieldTypeInteger"},{name:c??l,alias:c??l,type:"esriFieldTypeString"});let d=0;const h=t.bin.type==="dateBin",m=t.outTimeReference?.ianaTimeZone;for(const f of e){const{minValue:y,maxValue:S,items:I}=f,w={attributes:{}};let F;if(w.attributes[a]=h&&m&&y!=null?ne.fromMillis(y,{zone:m}).toISO():y,w.attributes[n]=h&&m&&S!=null?ne.fromMillis(S,{zone:m}).toISO():S,l?(F=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[l],orderByFields:[l]},I),w.attributes[J]=++d,t.bin.jsonStyle==="flat"?o.push(...F.features.map(({attributes:{EXPR_1:x,...g},..._})=>({..._,attributes:c??x?{...g,[c??x]:x,...w.attributes}:{...g,...w.attributes}}))):(w.stackedAttributes=F.features.map(({attributes:{EXPR_1:x,...g}})=>c??x?{...g,[c??x]:x}:g),o.push(w))):(t.bin?.splitBy&&(w.attributes[J]=++d),F=await this._createStatisticsQueryResponse(t,I,w),o.push(w)),F.fields)for(const x of F.fields)u.some(g=>g.name===x.name)||u.push(x)}return t.binOrder==="desc"&&o.reverse(),{fields:u,features:o}}}function gs(r,e,t,s){const i=s.x-t.x,a=s.y-t.y,n=e.x-t.x,o=e.y-t.y,u=i*i+a*a;if(u===0)return!1;const l=n*i+o*a,c=Math.min(1,Math.max(0,l/u));return r.x=t.x+i*c,r.y=t.y+a*c,!0}function ke(r,e){return r?e?4:3:e?3:2}class He{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const xs=[1];function _s(r){return r==="mesh"?ss:is(r)}function et(r,e){return r?e?4:3:e?3:2}function Fs(r,e,t,s){return tt(r,e,t,s.coords[0],s.coords[1])}function Ss(r,e,t,s,i,a){const n=et(i,a),{coords:o,lengths:u}=s;if(!u)return!1;for(let l=0,c=0;l<u.length;l++,c+=n)if(!tt(r,e,t,o[c],o[c+1]))return!1;return!0}function tt(r,e,t,s,i){if(!r)return!1;const a=et(e,t),{coords:n,lengths:o}=r;let u=!1,l=0;for(const c of o)u=Is(u,n,a,l,c,s,i),l+=c*a;return u}function Is(r,e,t,s,i,a,n){let o=r,u=s;for(let l=s,c=s+i*t;l<c;l+=t){u=l+t,u===c&&(u=s);const d=e[l],h=e[l+1],m=e[u],f=e[u+1];(h<n&&f>=n||f<n&&h>=n)&&d+(n-h)/(f-h)*(m-d)<a&&(o=!o)}return o}const me="unsupported-query",Re={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!1,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultiPatch:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function ws(r){return r!=null&&Re.spatialRelationship[r]===!0}function Ts(r){return r!=null&&Re.queryGeometry[wt(r)]===!0}function Rs(r){return r!=null&&Re.layerGeometry[r]===!0}const vs={esriSpatialRelIntersects:()=>O(()=>N(()=>import("./intersectsOperator-15Txaz8P-Bf0O3gnS.js"),__vite__mapDeps([3,4,5,6,7,8,9,10,11,12,13,14,15,16])),Q([3,4,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelContains:()=>O(()=>N(()=>import("./containsOperator-tFGgcS35-TZPU481a.js"),__vite__mapDeps([17,5,6,7,8,9,10,11,12,13,14,15,16])),Q([17,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelCrosses:()=>O(()=>N(()=>import("./crossesOperator-AiI_s6tu-mrz4LSeN.js"),__vite__mapDeps([18,19,5,6,7,8,9,10,11,12,13,14,15,16])),Q([18,19,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelDisjoint:()=>O(()=>N(()=>import("./disjointOperator-DHvyicp1-Ba_Cmt1Z.js"),__vite__mapDeps([20,5,6,7,8,9,10,11,12,13,14,15,16])),Q([20,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelEnvelopeIntersects:null,esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:()=>O(()=>N(()=>import("./overlapsOperator-HumrnKUU-DpwGJhql.js"),__vite__mapDeps([21,22,5,6,7,8,9,10,11,12,13,14,15,16])),Q([21,22,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelTouches:()=>O(()=>N(()=>import("./touchesOperator-D8_pTw4V-C04WZWqQ.js"),__vite__mapDeps([23,24,5,6,7,8,9,10,11,12,13,14,15,16])),Q([23,24,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelWithin:()=>O(()=>N(()=>import("./withinOperator-Cm3z_-jX-DPnYoyS7.js"),__vite__mapDeps([25,26,5,6,7,8,9,10,11,12,13,14,15,16])),Q([25,26,5,6,7,8,9,10,11,12,13,14,15,16])),esriSpatialRelRelation:null};function bs(r){const e=vs[r];if(e==null)throw new Error(`Cannot load unsupported spatial operator: ${r}`);return e()}async function X(r,e,t,s,i){if(we(e)){if(t==="esriGeometryPoint"&&(r==="esriSpatialRelIntersects"||r==="esriSpatialRelContains")){const n=Qe(new re,e,!1,!1);return o=>Fs(n,!1,!1,o)}if(t==="esriGeometryMultipoint"){const n=Qe(new re,e,!1,!1);if(r==="esriSpatialRelContains")return o=>Ss(n,!1,!1,o,s,i)}}if(Ie(e)){if(t==="esriGeometryPoint"&&(r==="esriSpatialRelIntersects"||r==="esriSpatialRelContains"))return n=>es(e,D(t,s,i,n));if(t==="esriGeometryMultipoint"&&r==="esriSpatialRelContains")return n=>ts(e,D(t,s,i,n));if(r==="esriSpatialRelIntersects"){const n=_s(t);return o=>n(e,D(t,s,i,o))}}r==="esriSpatialRelEnvelopeIntersects"&&(r="esriSpatialRelIntersects");const a=await bs(r);return n=>a.execute(e,D(t,s,i,n))}async function st(r,e,t){const{spatialRel:s,geometry:i}=r;if(i){if(!ws(s))throw new v(me,"Unsupported query spatial relationship",{query:r});if(U(i.spatialReference)&&U(t)){if(!Ts(i))throw new v(me,"Unsupported query geometry type",{query:r});if(!Rs(e))throw new v(me,"Unsupported layer geometry type",{query:r});if(r.outSR)return oe(r.geometry?.spatialReference,r.outSR)}}}function it(r){if(Ie(r))return!0;if(we(r)){for(const e of r.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}const H="unsupported-query";async function As(r,e){const t=r.bin;if(!t.onField&&!t.onExpression?.value||t.type==="autoIntervalBin"&&t.parameters.numberOfBins==null||t.type==="dateBin"&&(t.parameters.number==null||t.parameters.unit==null)||t.type==="fixedBoundariesBin"&&t.parameters.boundaries==null||t.type==="fixedIntervalBin"&&t.parameters.interval==null)throw new v(H,"Unsupported query options",{query:r});return Se(r,e)}async function Se(r,{fieldsIndex:e,geometryType:t,spatialReference:s,availableFields:i}){if(r.geometryPrecision!=null||r.multipatchOption&&r.multipatchOption!=="xyFootprint"||r.pixelSize||r.relationParam||r.text)throw new v(H,"Unsupported query options",{query:r});return rt(e,i,r),Ms(e,i,r),Promise.all([st(r,t,s),oe(s,r.outSR)]).then(()=>r)}function rt(r,e,t){const{returnDistinctValues:s,outStatistics:i}=t,a=i?i.map(n=>n.outStatisticFieldName&&n.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in t&&t.orderByFields&&t.orderByFields.length>0){const n=" asc",o=" desc",u=t.orderByFields.map(l=>{const c=l.toLowerCase();return c.includes(n)?c.split(n)[0]:c.includes(o)?c.split(o)[0]:l}).filter(l=>!a.includes(l));C(r,e,u,{expressionName:"orderByFields",query:t})}if("outFields"in t){if(t.outFields?.length)C(r,e,t.outFields,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(s)throw new v(H,"outFields should be specified for returnDistinctValues",{query:t})}us(r,e,t.where,t)}const Es=new Set([...Ye,...Xe]);function Ms(r,e,t){const{outStatistics:s,groupByFieldsForStatistics:i,having:a}=t,n=i?.length,o=s?.length;if(a){if(!n||!o)throw new v(H,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});cs(r,e,a,s,t)}if(o){if(!Bs(s))return;const u=s.map(l=>l.onStatisticField).filter(Boolean);C(r,e,u,{expressionName:"onStatisticFields",query:t}),n&&C(r,e,i,{expressionName:"groupByFieldsForStatistics",query:t});for(const l of s){const{onStatisticField:c,statisticType:d}=l;if((d==="percentile_disc"||d==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:h}=l;if(!h)throw new v(H,"statisticParameters should be set for percentile type",{definition:l,query:t})}else r.get(c)&&d!=="count"&&d!=="min"&&d!=="max"&&C(r,e,[c],{expressionName:`outStatistics with '${d}' statistic type`,allowedFieldTypes:Es,query:t})}}}async function Vs(r,e,{fieldsIndex:t,geometryType:s,spatialReference:i,availableFields:a}){if(r.geometryPrecision!=null||r.multipatchOption||r.pixelSize||r.relationParam||r.text||r.outStatistics||r.groupByFieldsForStatistics||r.having||r.orderByFields)throw new v(H,"Unsupported query options",{query:r});return rt(t,a,r),Promise.all([Gs(t,a,e,r),st(r,s,i),oe(i,r.outSR)]).then(()=>r)}async function Gs(r,e,t,s){let i=[];if(t.valueExpression){const{arcadeUtils:a}=await Le();i=a.extractFieldNames(t.valueExpression)}if(t.field&&i.push(t.field),t.field2&&i.push(t.field2),t.field3&&i.push(t.field3),t.normalizationField&&i.push(t.normalizationField),!i.length&&!t.valueExpression)throw new v(H,"field or valueExpression is required",{params:t});C(r,e,i,{expressionName:"statistics",query:s})}function Bs(r){return r!=null&&r.every(e=>e.statisticType!=="exceedslimit")}async function Qs(r,e){if(!r)return null;const t=e.featureAdapter,{startTimeField:s,endTimeField:i}=r;let a=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;if(s&&i)await e.forEach(o=>{const u=t.getAttribute(te(o),s),l=t.getAttribute(te(o),i);u==null||isNaN(u)||(a=Math.min(a,u)),l==null||isNaN(l)||(n=Math.max(n,l))});else{const o=s||i;await e.forEach(u=>{const l=t.getAttribute(te(u),o);l==null||isNaN(l)||(a=Math.min(a,l),n=Math.max(n,l))})}return{start:a,end:n}}function Ds(r,e,t){if(!e||!r)return null;const{startTimeField:s,endTimeField:i}=r;if(!s&&!i)return null;const{start:a,end:n}=e;if(a===null&&n===null)return null;if(a===void 0&&n===void 0)return Os();const o=t.getAttributeAsTimestamp?.bind(t)??t.getAttribute.bind(t);return s&&i?zs(o,s,i,a,n):Ps(o,s||i,a,n)}function zs(r,e,t,s,i){return s!=null&&i!=null?a=>{const n=r(a,e),o=r(a,t);return(n==null||n<=i)&&(o==null||o>=s)}:s!=null?a=>{const n=r(a,t);return n==null||n>=s}:i!=null?a=>{const n=r(a,e);return n==null||n<=i}:void 0}function Ps(r,e,t,s){return t!=null&&s!=null&&t===s?i=>r(i,e)===t:t!=null&&s!=null?i=>{const a=r(i,e);return a!=null&&a>=t&&a<=s}:t!=null?i=>{const a=r(i,e);return a!=null&&a>=t}:s!=null?i=>{const a=r(i,e);return a!=null&&a<=s}:void 0}function Os(){return()=>!1}const Ns="unsupported-query";class di{constructor(e){this._changeHandle=null,this.capabilities={query:Nt},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new ms,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,e.featureIdInfo.type==="object-id"&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=ht(e.fieldsIndex)?e.fieldsIndex:rs.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>this.fieldsIndex.get(t)?.name).filter(t=>t!=null)),e.scheduler&&e.priority?this._frameTask=e.scheduler.registerTask(e.priority):this._frameTask=as}destroy(){this._changeHandle=Ee(this._changeHandle),this._frameTask=Ee(this._frameTask),this._clearCache(),lt(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}async executeQuery(e,t){const s=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryFeatureSet(e),s)}async executeQueryForCount(e={},t){const s=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForCount(e),s)}async executeQueryForExtent(e,t){const s=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForExtent(e),s)}async executeQueryForIds(e,t){return Array.from(await this.executeQueryForIdSet(e,t))}async executeQueryForIdSet(e,t){const s=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForIdSet(e),s)}async executeQueryForLatestObservations(e,t){const s=V(t);if(!this.timeInfo?.trackIdField)throw new v(Ns,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});return await this._frameTask.scheduleGenerator(()=>this._executeQueryForLatestObservations(e),s)}async executeQueryForOpaqueFeatures(e,t){const s=V(t);return(await this._frameTask.scheduleGenerator(()=>this._executeQuery(e,{}),s)).items}async executeAttributeBinsQuery(e,t){const s=V(t);return e=K(e),await this._frameTask.scheduleGenerator(()=>this._executeAttributeBinsQuery(e),s)}async executeQueryForSummaryStatistics(e={},t,s){const i=V(s);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSummaryStatistics(e,t),i)}async executeQueryForUniqueValues(e={},t,s){const i=V(s);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForUniqueValues(e,t),i)}async executeQueryForClassBreaks(e={},t,s){const i=V(s);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForClassBreaks(e,t),i)}async executeQueryForHistogram(e={},t,s){const i=V(s);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForHistogram(e,t),i)}async executeQueryForSnapping(e,t){const s=V(t);return await this._frameTask.scheduleGenerator(()=>this._executeQueryForSnapping(e,s),s)}async fetchRecomputedExtents(e){const t=V(e);this._timeExtentPromise||=Qs(this.timeInfo,this.featureStore);const[s,i]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return ut(t),{fullExtent:s,timeExtent:i}}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async*_executeQueryFeatureSet(e){try{const t=yield*this._executeQuery(e,{});return yield,await t.createQueryResponse()}catch(t){if(t!==j)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeQueryForCount(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null});return yield,t.createQueryResponseForCount()}catch(t){if(t!==j)throw t;return 0}}async*_executeQueryForExtent(e){const t=e.outSR;try{const s=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const i=s.size;if(!i)return{count:0,extent:null};const a=await this._getBounds(s.items,s.spatialReference,t??this.spatialReference);return yield,{count:i,extent:a}}catch(s){if(s===j)return{count:0,extent:null};throw s}}async*_executeQueryForIdSet(e){try{const t=yield*this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null});yield;const s=t.items,i=new Set;for(const a of s)i.add(t.featureAdapter.getObjectId(a));return i}catch(t){if(t===j)return new Set;throw t}}async*_executeQueryForLatestObservations(e){try{const t=yield*this._executeQuery(e,{});return yield,this._filterLatest(t),yield,await t.createQueryResponse()}catch(t){if(t!==j)throw t;return await new A([],e,this).createQueryResponse()}}async*_executeAttributeBinsQuery(e){let t;try{e=await Vt(e,this.definitionExpression,this.spatialReference),yield,e=await As(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const s=yield*this._executeSceneFilterQuery(e);yield,t=yield*this._executeGeometryQuery(e,s),yield,this._executeAggregateIdsQuery(t),yield,this._executeObjectIdsQuery(t),yield,this._executeTimeQuery(t),yield,this._executeAttributesQuery(t),yield}catch(s){if(s!==j)throw s;t=new A([],e,this)}return await t.createQueryBinsResponse(e)}async*_executeQueryForSummaryStatistics(e={},t){const{field:s,normalizationField:i,valueExpression:a}=t,n=yield*this._executeQueryForStatistics(e,{field:s,normalizationField:i,valueExpression:a});return yield,await n.createSummaryStatisticsResponse(t)}async*_executeQueryForUniqueValues(e={},t){const{field:s,field2:i,field3:a,valueExpression:n}=t,o=yield*this._executeQueryForStatistics(e,{field:s,field2:i,field3:a,valueExpression:n});return yield,await o.createUniqueValuesResponse(t)}async*_executeQueryForClassBreaks(e,t){const{field:s,normalizationField:i,valueExpression:a}=t,n=yield*this._executeQueryForStatistics(e,{field:s,normalizationField:i,valueExpression:a});return yield,await n.createClassBreaksResponse(t)}async*_executeQueryForHistogram(e,t){const{field:s,normalizationField:i,valueExpression:a}=t,n=yield*this._executeQueryForStatistics(e,{field:s,normalizationField:i,valueExpression:a});return yield,await n.createHistogramResponse(t)}async*_executeQueryForSnapping(e,t){const{point:s,distance:i,returnEdge:a,vertexMode:n}=e;if(!a&&n==="none")return{candidates:[]};let o=K(e.query);o=await Gt(o,this.definitionExpression,this.spatialReference),yield,o=await Se(o,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const u=!B(s.spatialReference,this.spatialReference);u&&(await oe(s.spatialReference,this.spatialReference),yield);const l=typeof i=="number"?i:i.x,c=typeof i=="number"?i:i.y,d={xmin:s.x-l,xmax:s.x+l,ymin:s.y-c,ymax:s.y+c,spatialReference:s.spatialReference},h=u?$(d,this.spatialReference):d;if(!h)return{candidates:[]};const m=(await Be(Ge(s),null,{signal:t}))[0];yield;const f=(await Be(Ge(h),null,{signal:t}))[0];if(yield,m==null||f==null)return{candidates:[]};const y=await this._searchFeatures(ye(f.toJSON()));yield;const S=new A(y,o,this);this._executeObjectIdsQuery(S),yield,this._executeTimeQuery(S),yield,this._executeAttributesQuery(S),yield,yield*this._executeGeometryQueryForSnapping(S),yield;const I=m.toJSON(),w=u?$(I,this.spatialReference):I,F=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:i;return S.createSnappingResponse({...e,point:w,distance:F},o.returnZ,s.spatialReference)}async _getBounds(e,t,s){const i=mt(pt(),yt);return await this.featureStore.forEachBounds(e,a=>gt(i,a)),Cs(i,t,s,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const s=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(i=>s.push(i)))().then(()=>te(s))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async*_executeQuery(e,t){e=K(e),e=await ze(e,this.definitionExpression,this.spatialReference),yield,e=await Se(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield,e={...e,...t};const s=yield*this._executeSceneFilterQuery(e);yield;const i=yield*this._executeGeometryQuery(e,s);return yield,this._executeAggregateIdsQuery(i),yield,this._executeObjectIdsQuery(i),yield,this._executeTimeQuery(i),yield,this._executeAttributesQuery(i),i}async*_executeSceneFilterQuery(e){if(e.sceneFilter==null)return null;const{outSR:t,returnGeometry:s,returnCentroid:i}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,o=a==null||B(a,n.spatialReference)?n:$(n,a);if(!o)return null;const u=s||i,l=U(t)&&!B(this.spatialReference,t)&&u?async f=>this._project(f,t):f=>f;yield;const c=this.featureAdapter,d=await this._searchFeatures(ye(o));if(yield,e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const f=new Set;for(const x of d)f.add(c.getObjectId(x));const y=await this._getAllFeatures();yield;const S=await X("esriSpatialRelDisjoint",o,this.geometryType,this.hasZ,this.hasM);yield;const I=x=>!f.has(c.getObjectId(x))||S(c.getGeometry(x)),w=yield*this._runSpatialFilter(y,I);yield;const F=new A(w,e,this);return await l(F)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(o,e))return await l(new A(d,e,this));const h=await X("esriSpatialRelContains",o,this.geometryType,this.hasZ,this.hasM);yield;const m=yield*this._runSpatialFilter(d,f=>h(c.getGeometry(f)));return yield,await l(new A(m,e,this))}async*_executeGeometryQuery(e,t){if(t!=null&&t.items.length===0)return t;const{geometry:s,outSR:i,returnGeometry:a,returnCentroid:n}=e,o=t?null:this._getCacheKey(e),u=o?this._cache.get(o):null;if(u)return new A(u,e,this);const l=U(i)&&!B(this.spatialReference,i),c=a||n,d=async F=>(l&&c&&await this._project(F,i),o&&this._cache.put(o,F.items),F),h=this.featureStore.featureSpatialReference,m=!s||h==null||B(h,s.spatialReference)?s:$(s,h);if(!m)return await d(t??await this._getAllFeaturesQueryEngineResult(e));yield;const f=this.featureAdapter;let y=await this._searchFeatures(ye(s));yield;const S=e.spatialRel??"esriSpatialRelIntersects";if(S==="esriSpatialRelDisjoint"){if(!y.length)return await d(t??await this._getAllFeaturesQueryEngineResult(e));const F=new Set;for(const R of y)F.add(f.getObjectId(R));let x;t!=null?x=t.items:(yield,x=await this._getAllFeatures(),yield);const g=await X(S,m,this.geometryType,this.hasZ,this.hasM);yield;const _=R=>!F.has(f.getObjectId(R))||g(f.getGeometry(R)),p=yield*this._runSpatialFilter(x,_);yield;const T=new A(p,e,this);return await d(T)}if(t!=null){const F=new dt;y=y.filter(x=>ct(t.items,x,t.items.length,F)>=0)}if(!y.length){const F=new A([],e,this);return o&&this._cache.put(o,F.items),F}if(this._canExecuteSinglePass(m,e))return await d(new A(y,e,this));const I=await X(S,m,this.geometryType,this.hasZ,this.hasM);yield;const w=yield*this._runSpatialFilter(y,F=>I(f.getGeometry(F)));return yield,await d(new A(w,e,this))}_executeAggregateIdsQuery(e){if(e.items.length===0||!e.query.aggregateIds?.length||this.aggregateAdapter==null)return;const t=new Set;for(const i of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(a=>t.add(a));const s=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(s(i)))}_executeObjectIdsQuery(e){if(e.items.length===0||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),s=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(s(i)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=Ds(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=k(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(s=>t.testFeature(s,this.featureAdapter))}}async*_executeGeometryQueryForSnapping(e){const{query:t}=e,{spatialRel:s}=t;if(!e?.items?.length||!t.geometry||!s)return;const i=await X(s,t.geometry,this.geometryType,this.hasZ,this.hasM);yield;const a=this.featureAdapter,n=u=>i(a.getGeometry(u)),o=yield*this._runSpatialFilter(e.items,n);e.items=o}*_runSpatialFilter(e,t){if(!t)return e;if(this._frameTask==null)return e.filter(a=>t(a));let s=yield;const i=new Array;for(const a of e)t(a)&&i.push(a),s.madeProgress(),s.done&&(s=yield);return i}_filterLatest(e){const{trackIdField:t,startTimeField:s,endTimeField:i}=this.timeInfo,a=i||s,n=new Map,o=this.featureAdapter.getAttribute;for(const u of e.items){const l=o(u,t),c=o(u,a),d=n.get(l);(!d||c>o(d,a))&&n.set(l,u)}e.items=Array.from(n.values())}_getCacheKey(e){const{geometry:t,spatialRel:s,returnGeometry:i,returnCentroid:a,outSR:n,resultType:o,cacheHint:u}=e;if(o!=="tile"&&!u)return null;const l=i||a;return U(n)&&!B(this.spatialReference,n)&&l?JSON.stringify([t,s,n]):JSON.stringify([t,s])}_canExecuteSinglePass(e,t){const{spatialRel:s}=t;return it(e)&&(s==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"))}async _project(e,t){if(!t||B(this.spatialReference,t))return e;const s=this.featureAdapter,i=ft()?await this._getFullExtent():void 0,a=await Bt(e.items.map(n=>D(this.geometryType,this.hasZ,this.hasM,s.getGeometry(n))),this.spatialReference,t,{areaOfInterestExtent:i});return e.items=te(a.map((n,o)=>s.cloneWithGeometry(e.items[o],Tt(n,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(i=>this.featureStore.forEachInBounds(i,a=>t.add(a))));const s=Array.from(t.values());return t.clear(),s}async*_executeQueryForStatistics(e,t){e=K(e);try{e=await ze(e,this.definitionExpression,this.spatialReference),yield,e=await Vs(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),yield;const s=yield*this._executeSceneFilterQuery(e);yield;const i=yield*this._executeGeometryQuery(e,s);return yield,this._executeAggregateIdsQuery(i),yield,this._executeObjectIdsQuery(i),yield,this._executeTimeQuery(i),yield,this._executeAttributesQuery(i),yield,i}catch(s){if(s!==j)throw s;return new A([],e,this)}}get test(){}}function ye(r){if(it(r)){if(Ie(r))return[Me(Math.min(r.xmin,r.xmax),Math.min(r.ymin,r.ymax),Math.max(r.xmin,r.xmax),Math.max(r.ymin,r.ymax))];if(we(r))return r.rings.map(e=>Me(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[It(xt(),r)]}function Cs(r,e,t,s,i){const a={xmin:r[0],ymin:r[1],xmax:r[3],ymax:r[4],spatialReference:se(s)};i&&isFinite(r[2])&&isFinite(r[5])&&(a.zmin=r[2],a.zmax=r[5],a.hasZ=!0);const n=$(a,e,t);if(n.spatialReference=se(t),n.xmax-n.xmin===0){const o=ue(n.spatialReference);n.xmin-=o,n.xmax+=o}if(n.ymax-n.ymin===0){const o=ue(n.spatialReference);n.ymin-=o,n.ymax+=o}if(i&&n.zmin!=null&&n.zmax!=null&&n.zmax-n.zmin===0){const o=ue(n.spatialReference);n.zmin-=o,n.zmax+=o}return n}export{A,Cs as B,Ds as M,X as Y,se as e,di as h};
