import{F as y,L as V,B as f,f as h,V as C}from"./Point2D-CMz7woHH-BVbGGL7p.js";import{Envelope2D as b}from"./Envelope2D-mFnl8dXR-MYac-bfa.js";import{aO as D,L as p}from"./ProjectionTransformation-PJc9H7Gq-Rbz84pUM.js";function T(){return N(new h,-1,Number.NaN)}function N(n,e,r){return{m_coordinate:n.clone(),m_vertexIndex:e,m_geometryIndex:0,m_distance:r,m_bRightSide:!1,isEmpty:G}}function G(){return Number.isNaN(this.m_distance)}function P(n,e,r=-1,i=-1){if(n.isEmpty())return 3;const t=n.getGeometryType();if(C(t))return R(n,e,r,i);if(t===f.enumPolygon)return q(n,e,r,i);if(t===f.enumPolyline)return A(n,e,r,i);if(t===f.enumEnvelope){const s=new b;return n.queryEnvelope(s),s.contains(e)?s.containsExclusive(e)?1:2:0}return 3}function R(n,e,r,i){if(r>=0||i>=0)return y("");if(n.isDegenerate(0))return n.getStartXY().equals(e)?2:3;if(!n.isCurve()){const c=h.orientationRobust(e,n.getStartXY(),n.getEndXY());return c<0?1:c>0?0:2}const t=n.getClosestCoordinate(e,!1),s=n.getTangent(t),u=n.getCoord2D(t),a=h.orientationRobust(e,u,u.add(s));return a<0?1:a>0?0:2}function q(n,e,r,i){(r>=0||i>=0)&&y("");const t=new b;n.queryEnvelope(t);const s=p(n,e,0);return s===0?0:s===1?1:2}function A(n,e,r,i){(r<0&&i>=0||r>=0&&i<0)&&y("");const t=n.querySegmentIterator();if(r<0){let u=Number.MAX_VALUE,a=0;for(;t.nextPath();)for(;t.hasNextSegment();){const c=t.nextSegment(),o=c.getClosestCoordinate(e,!1),g=c.getCoord2D(o),x=h.sqrDistance(g,e);x<u?(a=1,r=t.getStartPointIndex(),i=t.getPathIndex(),u=x):x===u&&a++}if(a===0)return 3;if(a===1)return t.resetToVertex(r,i),P(t.nextSegment(),e)}const s=v(e,t,r,i);if(s.i1!==-1&&s.i2===-1)return s.bRight1?1:0;if(s.i1!==-1&&s.i2!==-1){if(s.bRight1===s.bRight2)return s.bRight1?1:0;{t.resetToVertex(s.i1,-1);const u=t.nextSegment().getTangent(1);t.resetToVertex(s.i2,-1);const a=t.nextSegment().getTangent(0);return u.crossProduct(a)>=0?1:0}}return t.resetToVertex(r,i),P(t.nextSegment(),e)}function E(n,e,r){for(n.resetToVertex(e,r);n.hasNextSegment();)if(!n.nextSegment().isDegenerate(0))return n.getStartPointIndex();for(n.resetToVertex(e,r);n.hasPreviousSegment();)if(!n.previousSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function X(n,e){for(n.resetToVertex(e,-1),n.nextSegment();n.hasNextSegment();)if(!n.nextSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function _(n,e){for(n.resetToVertex(e,-1);n.hasPreviousSegment();)if(!n.previousSegment().isDegenerate(0))return n.getStartPointIndex();return-1}function v(n,e,r,i){const t={i1:-1,i2:-1,bRight1:!1,bRight2:!1};if(t.i1=E(e,r,i),t.i1!==-1){e.resetToVertex(t.i1,-1);const s=e.nextSegment(),u=s.getClosestCoordinate(n,!1),a=s.getCoord2D(u),c=h.sqrDistance(a,n);{const o=a.clone();o.subThis(s.getStartXY());const g=n.clone();g.subThis(s.getStartXY()),t.bRight1=o.crossProduct(g)<0}if(t.i2=X(e,t.i1),t.i2!==-1){e.resetToVertex(t.i2,-1);const o=e.nextSegment(),g=o.getClosestCoordinate(n,!1),x=o.getCoord2D(g);if(h.sqrDistance(x,n)>c)t.i2=-1;else{const l=x.clone();l.subThis(o.getStartXY());const m=n.clone();m.subThis(o.getStartXY()),t.bRight2=l.crossProduct(m)<0}}if(t.i2===-1&&(t.i2=_(e,t.i1),t.i2!==-1)){e.resetToVertex(t.i2,-1);const o=e.nextSegment(),g=o.getClosestCoordinate(n,!1),x=o.getCoord2D(g);if(h.sqrDistance(x,n)>c)t.i2=-1;else{const l=x.clone();l.subThis(o.getStartXY());const m=n.clone();m.subThis(o.getStartXY()),t.bRight2=l.crossProduct(m)<0;const d=t.i1;t.i1=t.i2,t.i2=d;const S=t.bRight1;t.bRight1=t.bRight2,t.bRight2=S}}}return t}class Y{getOperatorType(){return 10500}accelerateGeometry(e,r,i){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}getNearestCoordinate(e,r,i,t){if(r.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return T();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,r);case f.enumMultiPoint:return this.multiVertexGetNearestVertex(e,r);case f.enumPolyline:case f.enumPolygon:return this.multiPathGetNearestCoordinate(e,r,i,t);default:V("")}}getNearestVertex(e,r){if(r.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return T();switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertex(e,r);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertex(e,r);default:V("")}}getNearestVertices(e,r,i,t){if(t===0&&y(""),r.isNAN()&&y("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case f.enumPoint:return this.pointGetNearestVertices(e,r,i,t);case f.enumMultiPoint:case f.enumPolyline:case f.enumPolygon:return this.multiVertexGetNearestVertices(e,r,i,t);default:V("")}}multiPathGetNearestCoordinate(e,r,i,t){if(e.getGeometryType()===f.enumPolygon&&i){const l=new b;e.queryEnvelope(l);const m=D(null,l,!1);let d;if(d=p(e,r,t?0:m),d!==0){const S=N(r,-1,0);return t&&(S.m_bRightSide=!0),S}}const s=e.querySegmentIterator(),u=new h;let a=-1,c=-1,o=Number.MAX_VALUE,g=0;for(;s.nextPath();)for(;s.hasNextSegment();){const l=s.nextSegment(),m=l.getClosestCoordinate(r,!1),d=l.getCoord2D(m),S=h.sqrDistance(d,r);S<o?(g=1,u.assign(d),a=s.getStartPointIndex(),c=s.getPathIndex(),o=S):S===o&&g++}a===-1&&y("");const x=N(u,a,Math.sqrt(o));if(t)if(e.getGeometryType()!==f.enumPolygon){let l=!1;if(g>1){const m=P(e,r,a,c);l=m!==0&&m!==3}else{s.resetToVertex(a,c);const m=s.nextSegment();l=P(m,r)!==0}x.m_bRightSide=l}else i||p(e,r,0)!==0&&(x.m_bRightSide=!0);return x}pointGetNearestVertex(e,r){const i=e.getXY(),t=h.distance(i,r);return N(i,0,t)}multiVertexGetNearestVertex(e,r){const i=e.getAttributeStreamRef(0),t=e.getPointCount();let s=-1;const u=new h;let a=Number.MAX_VALUE;const c=new h;for(let o=0;o<t;o++){i.queryPoint2D(2*o,c);const g=h.sqrDistance(c,r);g<a&&(u.assign(c),s=o,a=g)}return N(u,s,Math.sqrt(a))}pointGetNearestVertices(e,r,i,t){const s=[];if(t!==0){const u=i*i,a=e.getXY(),c=h.sqrDistance(a,r);c<=u&&s.push(N(a,0,Math.sqrt(c)))}return s}multiVertexGetNearestVertices(e,r,i,t){const s=[];if(t!==0){const u=e.getAttributeStreamRef(0),a=e.getPointCount();s.length=t+1;const c=i*i;for(let o=0;o<a;o++){const g=u.read(2*o),x=u.read(2*o+1),l=r.x-g,m=r.y-x,d=l*l+m*m;d<=c&&s.push(N(h.construct(g,x),o,Math.sqrt(d)))}s.sort((o,g)=>o.m_distance-g.m_distance)}return s.slice(0,t)}}export{Y as M};
