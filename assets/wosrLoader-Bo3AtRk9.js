import{H as F}from"./Point-BN8RINcc.js";import{_ as T}from"./asyncUtils-w6KfWU41.js";import{f as q,i as H,s as L}from"./jsonMap-Bs3hmeCU.js";import{u as V}from"./memoryEstimations-Bd726a_p.js";import{r as z}from"./Version-BtYZEj58.js";import{b as k}from"./collectionUtils-Dk3LoVuX.js";import{q as J,l as O}from"./aaBoundingBox-CtkshuSS.js";import{A as K}from"./Indices-D0_UQPPr.js";import{M as N,P as Q,m as W,t as X}from"./Texture-Cw36TGeQ.js";import{t as Y}from"./orientedBoundingBox-VXwBwem5.js";class ${constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return this._outer.size===0}get outerSize(){return this._outer.size}get size(){let e=0;for(const r of this._outer.values())e+=r.size;return e}get(e,r){return this._outer.get(e)?.get(r)}getInner(e){return this._outer.get(e)}set(e,r,t){const n=this._outer.get(e);n?n.set(r,t):this._outer.set(e,new Map([[r,t]]))}delete(e,r){const t=this._outer.get(e);t&&(t.delete(r),t.size===0&&this._outer.delete(e))}pop(e,r){const t=this.get(e,r);return this.delete(e,r),t}*outerMap(){for(const e of this._outer)yield e}*values(){for(const e of this._outer.values())yield*e.values()}*[Symbol.iterator](){for(const[e,r]of this._outer)for(const[t,n]of r)yield[e,t,n]}forEach(e){this._outer.forEach((r,t)=>e(r,t))}forAll(e){this._outer.forEach((r,t)=>r.forEach((n,o)=>e(n,t,o)))}copy(){const e=new $;return this.forAll((r,t,n)=>e.set(t,n,r)),e}}const f=()=>H.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class Z{constructor(e,r,t){this.resource=e,this.textures=r,this.usedMemory=t}}async function ge(s,e){const r=await ee(s,e),t=await ne(r.textureDefinitions??{},e);let n=0;for(const o in t)if(t.hasOwnProperty(o)){const a=t[o];n+=a?.image?a.image.width*a.image.height*4:0}return new Z(r,t,n+V(r))}async function ee(s,e){const r=e?.streamDataRequester;if(r)return te(s,r,e);const t=await T(F(s,e));if(t.ok===!0)return t.value.data;q(t.error),C(t.error)}async function te(s,e,r){const t=await T(e.request(s,0,r));if(t.ok===!0)return t.value;q(t.error),C(t.error.details.url)}function C(s){throw new L("",`Request for object resource failed: ${s}`)}function re(s){const e=s.params,r=e.topology;let t=!0;switch(e.vertexAttributes||(f().warn("Geometry must specify vertex attributes"),t=!1),e.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const o=e.faces;if(o){if(e.vertexAttributes)for(const a in e.vertexAttributes){const u=o[a];u?.values?(u.valueType!=null&&u.valueType!=="UInt32"&&(f().warn(`Unsupported indexed geometry indices type '${u.valueType}', only UInt32 is currently supported`),t=!1),u.valuesPerElement!=null&&u.valuesPerElement!==1&&(f().warn(`Unsupported indexed geometry values per element '${u.valuesPerElement}', only 1 is currently supported`),t=!1)):(f().warn(`Indexed geometry does not specify face indices for '${a}' attribute`),t=!1)}}else f().warn("Indexed geometries must specify faces"),t=!1;break}default:f().warn(`Unsupported topology '${r}'`),t=!1}s.params.material||(f().warn("Geometry requires material"),t=!1);const n=s.params.vertexAttributes;for(const o in n)n[o].values||(f().warn("Geometries with externally defined attributes are not yet supported"),t=!1);return t}function we(s,e){const r=new Array,t=new Array,n=new Array,o=new $,a=s.resource,u=z.parse(a.version||"1.0","wosr");ae.validate(u);const A=a.model.name,g=a.model.geometries,w=a.materialDefinitions??{},v=s.textures;let x=0;const m=new Map;for(let M=0;M<g.length;M++){const d=g[M];if(!re(d))continue;const E=oe(d),P=d.params.vertexAttributes,_=[],j=i=>{if(d.params.topology==="PerAttributeArray")return null;const c=d.params.faces;for(const l in c)if(l===i)return c[l].values;return null},I=P.position,D=I.values.length/I.valuesPerElement;for(const i in P){const c=P[i],l=c.values,B=j(i)??K(D);_.push([i,new Y(l,B,c.valuesPerElement,!0)])}const p=E.texture,h=v&&v[p];if(h&&!m.has(p)){const{image:i,parameters:c}=h,l=new N(i,c);t.push(l),m.set(p,l)}const U=m.get(p),G=U?U.id:void 0,b=E.material;let y=o.get(b,p);if(y==null){const i=w[b.slice(b.lastIndexOf("/")+1)].params;i.transparency===1&&(i.transparency=0);const c=h?R(h.alphaChannelUsage):void 0,l={ambient:k(i.diffuse),diffuse:k(i.diffuse),opacity:1-(i.transparency||0),textureAlphaMode:c,textureAlphaCutoff:.33,textureId:G,doubleSided:!0,cullFace:0,colorMixMode:i.externalColorMixMode||"tint",textureAlphaPremultiplied:h?.parameters.preMultiplyAlpha??!1};e?.materialParameters&&Object.assign(l,e.materialParameters),y=new Q(l,e),o.set(b,p,y)}n.push(y);const S=new W(y,_);x+=_.find(i=>i[0]==="position")?.[1]?.indices.length??0,r.push(S)}return{engineResources:[{name:A,stageResources:{textures:t,materials:n,geometries:r},pivotOffset:a.model.pivotOffset,numberOfVertices:x,lodThreshold:null}],referenceBoundingBox:se(r)}}function se(s){const e=J();return s.forEach(r=>{const t=r.boundingInfo;t!=null&&(O(e,t.bbMin),O(e,t.bbMax))}),e}async function ne(s,e){const r=new Array;for(const o in s){const a=s[o],u=a.images[0].data;if(!u){f().warn("Externally referenced texture data is not yet supported");continue}const A=a.encoding+";base64,"+u,g="/textureDefinitions/"+o,w=a.channels==="rgba"?a.alphaChannelUsage||"transparency":"none",v={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:R(w)!==1},x=e?.disableTextures?Promise.resolve(null):X(A,e);r.push(x.then(m=>({refId:g,image:m,parameters:v,alphaChannelUsage:w})))}const t=await Promise.all(r),n={};for(const o of t)n[o.refId]=o;return n}function R(s){switch(s){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function oe(s){const e=s.params;return{id:1,material:e.material,texture:e.texture,region:e.texture}}const ae=new z(1,2,"wosr");export{we as M,ge as h,$ as t};
