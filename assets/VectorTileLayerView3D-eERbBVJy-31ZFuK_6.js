import{l as Q,I as Dt,a4 as Rt,z as J,x as yt,c as tt,o as Ct,aX as It,J as Et,w as Lt,bd as et,Y as A,H as O,G as Ut}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{r as zt,j as kt,l as At}from"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import{c as Vt}from"./LRUCache-fy84PBMi-Y56WPIvD.js";import{bb as Ft,bc as Ot,b7 as Nt,b8 as Ht,a_ as Bt,b9 as Wt,ba as $t}from"./ShadowCastClear.glsl-CeOT_rAo-BEYyVrmo.js";import{y as Gt}from"./aaBoundingRect-CjwcS2F3-ri8bmh30.js";import{m as it}from"./constants-D67WmGms-H7IOwEdB.js";import{ai as at,H as qt}from"./Point-BfTTZoMu-DeJwQYfh.js";import{G as Yt}from"./workers-BEkgoq8Q-BM_Hz460.js";import{a as z}from"./Rect-BAnET0xx--LefF6x-.js";import{O as Kt,L as xt,t as wt}from"./Texture-CFNZjV2R-CxGjQ8pI.js";import{h as jt}from"./pbf-2SIhMekG-LK438LAR.js";import{$ as Xt}from"./rasterizingUtils-CnBgARH0-BABUYc59.js";import{s as $}from"./TileKey-C44YQC4_-BW7BBbYp.js";import{p as Jt}from"./TileInfo-Bz7QlefV-CdK7c8ef.js";import{i as Zt}from"./floatRGBA-D-Q4FzNN-DQhowfyr.js";import{x as rt}from"./mathUtils-PIGhLnI9-B1tKUlUb.js";import{P as E,Q as ot,T as St}from"./definitions-Dvg4hMIw-CdK2DzFN.js";import{E as k,R as F}from"./enums-B4pqBiXb-BO-3hS_8.js";import{o as Qt,r as te}from"./vec2f32-CaVKkSa6-BjkBmyoj.js";import{o as st}from"./config-Dg972SSE-D9DBKeq5.js";import{W as lt}from"./StyleRepository-DpniiW2t-RDlLcQGj.js";import{u as ee}from"./LayerView3D-JY0KVfxL-H13gXtj0.js";import{L as ie}from"./TiledLayerView3D-kcWAoKG--DcjckKje.js";import{t as ae}from"./LayerView-BnpxrRF8-Ca-QSx3a.js";import"./index-B0z_nLWi.js";import"./Extent-CgDMOSRD-Bod5LY6s.js";import"./Polyline-CoiTLswR-DTxpB2Yg.js";import"./Polygon-D6wEPb3W-D2MPjRU4.js";import"./typeUtils-DqrRcjBx-DZ6_Gsbu.js";import"./collectionUtils-jDyktm0P-BDP2Oq99.js";import"./modeUtils-BA-mAwuS-DSb1K26b.js";import"./intl-DRFqUect-DPhFaHB2.js";import"./date-IqUzANpt-bLKO9IDT.js";import"./sanitizerUtils-BT_8V5US-CWQWUwZQ.js";import"./lengthUtils-Dt1_RvOO-j3MEdmHu.js";import"./PooledRBush-Dco5QkUp-DX3CMhf3.js";import"./GraphicsCollection-Bk6M0b7D-Dk6KdmO7.js";import"./Graphic-DgGzDmqW-d1CNicxz.js";import"./getPopupProvider-CmskPttI-CzUWpGwk.js";import"./Color-CERqXxxY-BuYn26eI.js";import"./Layer-DZvC7bne-D3VLDrab.js";import"./typeUtils-CXW_VpOn-BGgLp_TK.js";import"./lineMarkers-CDwLe3J6-CNUjJvs3.js";import"./PolygonSymbol3D-BXRHZiCQ-BjPAY2LA.js";import"./ExtrudeSymbol3DLayer-DSc1ou2x-CsVYZCeG.js";import"./aaBoundingBox-Cn49X7ge-BcYPaJ58.js";import"./mat4f64-q_b6UJoq-Dh6sWB_w.js";import"./Font-BwmnW7d2-Dwh3xjKw.js";import"./SimpleFillSymbol-CDawtd9z-CWD2KI2D.js";import"./SimpleMarkerSymbol-BGAFRS9_-CVQ5NLIA.js";import"./PictureMarkerSymbol-CaSh-vZk-xhjZ61bb.js";import"./TextSymbol-hRGhyDHs-CoS7dSjf.js";import"./HeightModelInfo-D5IdRvJ2-23y6MRiu.js";import"./projectionUtils-BGH_5_I3-DGwchVO8.js";import"./spatialReferenceEllipsoidUtils-D2JabnKt-Ce3ED0lc.js";import"./RealisticTree.glsl-WN9nrQUl-QZiY3aPA.js";import"./mat4-C96X-Nn0-BrMLOLCb.js";import"./vec2f64-rIxtbMRN-Kai9mK1i.js";import"./vec32-CewSdTn3-VRto2OOh.js";import"./vec4f64-DPb6J-GU-C7c2DqbZ.js";import"./BufferView-Cj2sQaht-avJ4OGB_.js";import"./vec42-B8VM4vXb-B6OGOEI9.js";import"./Emissions.glsl-B8XKMjLy-DXfiRNVX.js";import"./InterleavedLayout-B7roQAzV-CdGz7mlm.js";import"./MeshLocalVertexSpace-BGd1IdEs-C0HJG4wR.js";import"./projectVectorToVector-Csv3NYZI-DpBtmQMN.js";import"./vec3f32-WCVSSNPR-9V6Uhrx-.js";import"./Indices-D0_UQPPr-t1Qev6md.js";import"./vector-B8ZDYGQ6-DRILJdcx.js";import"./quatf64-CCm9z-pX-CQ7_sSji.js";import"./sphere-DLQ6p7mp-DyEe1Vll.js";import"./orientedBoundingBox-BLEx7wLU-ByGP9QG1.js";import"./quat-B7J5v7rV-CZ9akUv-.js";import"./frustum-CMzahy3--B-DC1Co-.js";import"./TilemapCache-CjhKW_vj-8gKqgQfa.js";import"./UpdatingHandles-D2RI_3Hb-dwLPjVun.js";import"./asyncUtils-w6KfWU41-HenJ0UOu.js";import"./Map-AEYszeHg-ZEOzAMWa.js";import"./Basemap-CL_uaRmk-O3l-dbYk.js";import"./PortalItem-DnxMlRVo-CI4Ns2_M.js";import"./writeUtils-DEFpwIW1-AHZYPaSV.js";import"./CollectionFlattener-D6h2Fkvj-WVl2BXw-.js";import"./resourceExtension-DOTCeiZj-C2WIbjQM.js";import"./PolygonCollection-HNNpnBH7-5UHgGprq.js";import"./mat4f32-Djp3mnm5-DzYG3LYB.js";import"./Query-BlS0WPDF-jdXS_Qhy.js";import"./Field-Cm_ZejYW-CwJZmSru.js";import"./fieldType-DVUzXtk_-tUuvnZJM.js";import"./normalizeUtils-85zLqeMi-C1bdAKNn.js";import"./normalizeUtilsCommon-CnhQye_A-UWhaH-kt.js";import"./ElevationQuery-DzlYa4L4-DkUTW9Ak.js";import"./Scheduler-CNrsbccs-Bcg8fWoS.js";import"./unitConversionUtils-4vB4Ezlp-DnY5MDxd.js";import"./Octree-DckBBpQ7-CkRPu4UJ.js";import"./axisAngleDegrees-CjbXmycq-DcVVDR1-.js";import"./edgePreprocessing-D_eX-fWy-DqE-06Ss.js";import"./vec3-B_phcnZY-DHC7I6xa.js";import"./vec33-CWJeyzxV-Me4sF5XB.js";import"./UnknownTimeZone-B697BDFv-CBbtul7O.js";import"./jsonUtils-CmpazY1u-6pDLj5sx.js";import"./SimpleObservable-CvFyr0NA-DXpoMYph.js";import"./screenUtils-BitdhK1O-L0FLPAMi.js";import"./projectPointToVector-DL7Z4uvb-CPbOlZdQ.js";import"./scaleUtils-yfx9kKWT-D9SVsyM-.js";import"./layerUtils-DZGhvm-W-CfyHx1TZ.js";import"./tagSymbols-BPcGfZon-BPcGfZon.js";import"./Queue-CYlrXMwB-CYJTUII-.js";import"./signal-BX9ezF8a-cf1Pn6io.js";import"./timeZoneUtils-BSc7-7qA-BAv3h8mh.js";import"./ReactiveMap-B0by2bYu-DCsCfMj5.js";import"./TablesMixin-Q80MT3nU-CBB9B-b6.js";import"./plane-BNdSPG2o-DTV5z6SO.js";import"./memoryEstimations-Bd726a_p-0cVCY2Jz.js";import"./VertexElementDescriptor-BlxU8vCE-BwuKQkTU.js";import"./reader-DcGs6kKN-DHJfK-tm.js";import"./Cyclical-BLSxUpe7-Bj8R2Yk-.js";import"./computeTranslationToOriginAndRotation-Bjd4esRf-vJ4LbdOU.js";import"./layerViewUtils-BTa15X3o-BjQlX2q8.js";import"./dehydratedFeatures-Ql-uVzLq-aoK2987s.js";import"./quantizationUtils-Ceq-Uxsu-DjgKK_0s.js";import"./featureConversionUtils-BDA_FXJx-CDxX1Wik.js";import"./OptimizedFeature-CwRGZPwv-Ddclhn0A.js";import"./OptimizedFeatureSet-BR8EEvDc-CgsRgxJh.js";import"./createFeatureId-CVwTD0fV-3fKpJDrk.js";import"./elevationInfoUtils-B8MpdRMP-CDlK86wO.js";import"./HUDIntersectorResult-1xTExS7z-dL9SFL6u.js";import"./intersectorUtilsConversions-pLQPEbcN-Ck-nyNYa.js";import"./Intersector-DS9YtyQY-DMoYp6i0.js";import"./DefaultLoadingContext-DXgBe4GE-Unnb_XgV.js";import"./wosrLoader-CIPfz1Cl-DlmQQkMX.js";import"./Version-BtYZEj58-LyRHDnSJ.js";import"./DoubleArray-DExKNiTh-CvVpHySW.js";import"./GeometryUtils-C354xUs0-BLAznQrw.js";import"./WorkerHandle-B930SiRy-DglEKt53.js";import"./colorUtils-CeIi7j7j-C2WVx6th.js";import"./capabilities-Bi6C4OG6-CpURufko.js";import"./imageUtils-142g71N8-Wj0XNClb.js";import"./videoUtils-Dwx3AEgj-CduhpDRk.js";import"./uuid-Oe6SV2kF-IYX19xBA.js";import"./quickselect-QQC62dOK-Br2Ahhru.js";import"./meshVertexSpaceUtils-CtG7DPVT-kybwngCt.js";import"./TileKey-CXWFOqOI-Lra6v-mg.js";import"./loadAll-BCyxerwc-B4Lp8wGC.js";import"./opacityUtils-DuFH0EC9-DWspTgn2.js";import"./persistable-CdoDQOTR-BklJqWTn.js";import"./MD5-MtSiOt06-jWr180Yc.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw-DH8sdIsE.js";import"./utils-CylVuxNi--x86XOjU.js";import"./utils-Dpg4yj1D-CeFz2JVC.js";import"./types-BKo2foNY-DE0QfIFp.js";import"./labelUtils-BtizwBfq-Zegx4520.js";import"./ArcadeExpression-BlIRq-oN-VZkrwLVE.js";import"./TimeOnly-BERR31kg-CQiLyUZi.js";import"./enum-BzLwmiID-CcyIdWlQ.js";import"./FieldsIndex-CimK-TqD--24JoCkp.js";let re=class{constructor(i,e,t){this._scale=i,this._shift=e,this._levelShift=t}getLevelRowColumn(i){const e=this.getLevelShift(i[0]),t=this._shift+e;return t?[i[0]-e,i[1]>>t,i[2]>>t]:i}getLevelShift(i){return Math.min(i,this._levelShift)}getOffset(i,e){let t=0,a=0;const o=this._shift+this.getLevelShift(i[0]);if(o){const r=(1<<o)-1,s=e/(this._scale*(1<<o-1));t=(i[2]&r)*s,a=(i[1]&r)*s}return[t,a]}getScale(i){return this._scale*(1<<this._shift+this.getLevelShift(i))}},G=class{constructor(i,e){this._width=0,this._height=0,this._free=[],this._width=i,this._height=e,this._free.push(new z(0,0,i,e))}get width(){return this._width}get height(){return this._height}allocate(i,e){if(i>this._width||e>this._height)return new z;let t=null,a=-1;for(let o=0;o<this._free.length;++o){const r=this._free[o];i<=r.width&&e<=r.height&&(t===null||r.y<=t.y&&r.x<=t.x)&&(t=r,a=o)}return t===null?new z:(this._free.splice(a,1),t.width<t.height?(t.width>i&&this._free.push(new z(t.x+i,t.y,t.width-i,e)),t.height>e&&this._free.push(new z(t.x,t.y+e,t.width,t.height-e))):(t.width>i&&this._free.push(new z(t.x+i,t.y,t.width-i,t.height)),t.height>e&&this._free.push(new z(t.x,t.y+e,i,t.height-e))),new z(t.x,t.y,i,e))}release(i){for(let e=0;e<this._free.length;++e){const t=this._free[e];if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)t.width+=i.width;else if(t.x===i.x&&t.width===i.width&&t.y+t.height===i.y)t.height+=i.height;else if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)t.x=i.x,t.width+=i.width;else{if(i.x!==t.x||i.width!==t.width||i.y+i.height!==t.y)continue;t.y=i.y,t.height+=i.height}this._free.splice(e,1),this.release(i)}this._free.push(i)}},nt=class{constructor(i,e,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=e,this._glyphSource=t,this._binPack=new G(i-4,e-4),this._glyphData.push(new Uint8Array(i*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,e){const t=[],a=this._glyphSource,o=new Set,r=1/256;for(const l of e){const n=Math.floor(l*r);o.add(n)}const s=[];return o.forEach(l=>{const n=i+l;if(this._rangePromises.has(n))s.push(this._rangePromises.get(n));else{const c=a.getRange(i,l).then(()=>{this._rangePromises.delete(n)},()=>{this._rangePromises.delete(n)});this._rangePromises.set(n,c),s.push(c)}}),Promise.all(s).then(()=>{let l=this._glyphIndex[i];l||(l={},this._glyphIndex[i]=l);for(const n of e){const c=l[n];if(c){t[n]={sdf:!0,rect:c.rect,metrics:c.metrics,page:c.page,code:n};continue}const _=a.getGlyph(i,n);if(!_?.metrics)continue;const p=_.metrics;let g;if(p.width===0)g=new z(0,0,0,0);else{const w=p.width+6,h=p.height+6;let v=w%4?4-w%4:4,y=h%4?4-h%4:4;v===1&&(v=5),y===1&&(y=5),g=this._binPack.allocate(w+v,h+y),g.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new G(this.width-4,this.height-4),g=this._binPack.allocate(w+v,h+y));const P=this._glyphData[this._currentPage],d=_.bitmap;let b,f;if(d)for(let u=0;u<h;u++){b=w*u,f=this.width*(g.y+u+1)+g.x;for(let S=0;S<w;S++)P[f+S+1]=d.at(b+S)}}l[n]={rect:g,metrics:p,tileIDs:null,page:this._currentPage},t[n]={sdf:!0,rect:g,metrics:p,page:this._currentPage,code:n},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(i){for(const e in this._glyphIndex){const t=this._glyphIndex[e];if(!t)continue;let a;for(const o in t)if(a=t[o],a.tileIDs.delete(i),a.tileIDs.size===0){const r=this._glyphData[a.page],s=a.rect;let l,n;for(let c=0;c<s.height;c++)for(l=this.width*(s.y+c)+s.x,n=0;n<s.width;n++)r[l+n]=0;delete t[o],this._dirties[a.page]=!0}}}bind(i,e,t,a=0){if(!this._textures[t]){const r=new xt(this.width,this.height);r.pixelFormat=6406,r.wrapMode=33071,this._textures[t]=new wt(i,r,new Uint8Array(this.width*this.height))}const o=this._textures[t];o.setSamplingMode(e),this._dirties[t]&&o.setData(this._glyphData[t]),i.bindTexture(o,a),this._dirties[t]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}},X=class{constructor(i){if(this._metrics=[],!i)return void(this._allBitmaps=null);const e=new Map;let t=0;for(;i.next();)switch(i.tag()){case 1:{const r=i.getMessage();for(;r.next();)switch(r.tag()){case 3:{const s=r.getMessage();let l,n,c,_,p,g,w;for(;s.next();)switch(s.tag()){case 1:l=s.getUInt32();break;case 2:n=s.getBytes();break;case 3:c=s.getUInt32();break;case 4:_=s.getUInt32();break;case 5:p=s.getSInt32();break;case 6:g=s.getSInt32();break;case 7:w=s.getUInt32();break;default:s.skip()}if(s.release(),l){const h=n?.length??0;this._metrics[l]={width:c,height:_,left:p,top:g,advance:w,startOffset:t,length:h},e.set(l,n),t+=h}break}default:r.skip()}r.release();break}default:i.skip()}const a=new Uint8Array(t),o=this._metrics;for(const[r,s]of e){const{startOffset:l,length:n}=o[r];if(s)for(let c=0;c<n;++c)a[l+c]=s[c]}this._allBitmaps=a}getMetrics(i){return this._metrics[i]}getBitmap(i){if(!this._allBitmaps)return;const e=this._metrics[i];if(e===void 0)return;const{startOffset:t,length:a}=e;return a!==0?new se(this._allBitmaps,t,a):void 0}},oe=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,e){this._ranges[i]=e}},ct=class{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,e){const t=this._getFontStack(i);if(t.getRange(e))return Promise.resolve();const a=256*e,o=a+255;if(this._baseURL){const r=this._baseURL.replace("{fontstack}",i).replace("{range}",a+"-"+o);return qt(r,{responseType:"array-buffer"}).then(s=>{t.addRange(e,new X(new jt(new Uint8Array(s.data),new DataView(s.data))))}).catch(()=>{t.addRange(e,new X)})}return t.addRange(e,new X),Promise.resolve()}getGlyph(i,e){const t=this._getFontStack(i);if(!t)return;const a=Math.floor(e/256),o=t.getRange(a);return o?{metrics:o.getMetrics(e),bitmap:o.getBitmap(e)}:void 0}_getFontStack(i){let e=this._glyphInfo[i];return e||(e=this._glyphInfo[i]=new oe),e}},se=class{constructor(i,e,t){this._array=i,this._start=e,this.length=t}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};const le="dasharray-";let ut=class bt{constructor(e,t,a=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,a>0&&(this._maxItemSize=a),this._binPack=new G(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new G(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),a=Math.floor(this._pageHeight),o=new Uint32Array(t*a);this._mosaicsData[0]=o,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let a,o,r=this._mosaicRects[e];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(le)?([a,o]=this._rasterizeDash(e),t=!0):a=this._sprites.getSpriteInfo(e),!a?.width||!a.height||a.width<0||a.height<0))return null;const s=a.width,l=a.height,[n,c,_]=this._allocateImage(s,l);return n.width<=0?null:(this._copy(n,a,c,_,t,o),r={type:"sprite",rect:n,width:s,height:l,sdf:a.sdf,simplePattern:!1,rasterizationScale:a.pixelRatio??1,samplingMode:"Linear",page:c},this._mosaicRects[e]=r,r)}getSpriteItems(e){const t={};for(const a of e)t[a.name]=this.getSpriteItem(a.name,a.repeat);return t}getMosaicItemPosition(e,t){const a=this.getSpriteItem(e,t),o=a?.rect;if(!o)return null;o.width=a.width,o.height=a.height;const r=a.width,s=a.height,l=2;return{tl:[o.x+l,o.y+l],br:[o.x+l+r,o.y+l+s],page:a.page}}bind(e,t,a=0,o=0){if(a>=this._size.length||a>=this._mosaicsData.length)return;if(!this._textures[a]){const s=new xt(this._size[a][0],this._size[a][1]);s.wrapMode=33071,this._textures[a]=new wt(e,s,new Uint8Array(this._mosaicsData[a].buffer))}const r=this._textures[a];r.setSamplingMode(t),this._dirties[a]&&r.setData(new Uint8Array(this._mosaicsData[a].buffer)),e.bindTexture(r,o),this._dirties[a]=!1}static _copyBits(e,t,a,o,r,s,l,n,c,_,p){let g=o*t+a,w=n*s+l;if(p){w-=s;for(let h=-1;h<=_;h++,g=((h+_)%_+o)*t+a,w+=s)for(let v=-1;v<=c;v++)r[w+v]=e[g+(v+c)%c]}else for(let h=0;h<_;h++){for(let v=0;v<c;v++)r[w+v]=e[g+v];g+=t,w+=s}}_copy(e,t,a,o,r,s){if(!this._sprites||this._sprites.loadStatus!=="loaded"||a>=this._mosaicsData.length)return;const l=new Uint32Array(s?s.buffer:this._sprites.image.buffer),n=this._mosaicsData[a],c=2,_=s?t.width:this._sprites.width;bt._copyBits(l,_,t.x,t.y,n,o[0],e.x+c,e.y+c,t.width,t.height,r),this._dirties[a]=!0}_allocateImage(e,t){e+=2,t+=2;const a=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<a){const l=new z(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[e,t]]}let o=e%4?4-e%4:4,r=t%4?4-t%4:4;o===1&&(o=5),r===1&&(r=5);const s=this._binPack.allocate(e+o,t+r);return s.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new G(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[s,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=/\[(.*?)\]/,a=e.match(t);if(!a)return null;const o=a[1].split(",").map(Number),r=e.slice(e.lastIndexOf("-")+1),[s,l,n]=Xt(o,r);return[{x:0,y:0,width:l,height:n,sdf:!0,pixelRatio:1},new Uint8Array(s.buffer)]}},ne=class{constructor(i,e,t,a){this._layer=i,this._styleRepository=e,this.devicePixelRatio=t,this._sourceDataMaxLOD=a,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=yt(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const e=this._layer.currentStyleInfo.glyphsUrl,t=new ct(e?at(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new nt(1024,1024,t),this._broadcastPromise=Yt("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then(a=>{if(this._layer&&(this._connection?.close(),this._connection=a,this._layer&&!this._connection.closed)){const o=a.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(o).catch(r=>It(r))}})}_requestSprite(i){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const t=i?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,t&&(this._inputSignalEventListener=ce(e),t.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:a}=e,o={...i,signal:a};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,o),this._spriteSourcePromise.then(r=>{Et(a),this._spriteMosaic=new ut(1024,1024,250),this._spriteMosaic.setSpriteSource(r)})}async updateStyle(i){const e=[];for(const t of i)t.type===4?e.push({type:4,data:{spriteSource:null}}):e.push(t);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(i){const e=new ut(1024,1024,250);return e.setSpriteSource(i),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,e}async setStyle(i,e,t){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=t,this._requestSprite();const a=new ct(this._layer.currentStyleInfo.glyphsUrl?at(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new nt(1024,1024,a),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,e){const t=await this._getRefKeys(i,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),t,e)}async fetchTilePBFs(i){const e=Object.keys(this._layer.sourceNameToSource),t={},a=await this._getRefKeys(i,t),o=[],r=[];for(let s=0;s<a.length;s++)if(a[s].value==null||e[s]==null)r.push(null);else{const l=a[s].value,n=this._getTilePayload(l,e[s],t);n.then(c=>{o.push({...c,key:l})}),r.push(n)}return Promise.all(r).then(()=>o)}async parseTileData(i,e){const t=i&&i.data;if(!t)return null;const{sourceName2DataAndRefKey:a,transferList:o}=t;return Object.keys(a).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:a,styleLayerUIDs:i.styleLayerUIDs},{...e,transferList:o}))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,e,t){const a=$.pool.acquire(i.id),o=this._layer.sourceNameToSource[e],{level:r,row:s,col:l}=a;$.pool.release(a);try{return{protobuff:await o.requestTile(r,s,l,t),sourceName:e}}catch(n){if(Lt(n))throw n;return{protobuff:null,sourceName:e}}}async _getRefKeys(i,e){const t=this._layer.sourceNameToSource,a=new Array;for(const o in t){const r=t[o].getRefKey(i,e);a.push(r)}return et(a)}_getSourcesData(i,e,t){const a=[];for(let o=0;o<e.length;o++)if(e[o].value==null||i[o]==null)a.push(null);else{const r=e[o].value,s=this._getTilePayload(r,i[o],t);a.push(s)}return et(a).then(o=>{const r={},s=[];for(let l=0;l<o.length;l++){const n=o[l].value;if(n&&n.protobuff&&n.protobuff.byteLength>0){const c=e[l].value.id;r[n.sourceName]={refKey:c,protobuff:n.protobuff},s.push(n.protobuff)}}return{sourceName2DataAndRefKey:r,transferList:s}})}};function ce(i){return()=>i.abort()}let ue=class extends Zt{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(i){const e=$.pool.acquire(i),t=e.level===0?null:$.getId(e.level-1,e.row>>1,e.col>>1,e.world);return $.pool.release(e),t}getTileCoverage(i,e,t=!0,a){const o=super.getTileCoverage(i,e,t,a);if(!o)return o;const r=1<<o.lodInfo.level;return o.spans=o.spans.filter(s=>s.row>=0&&s.row<r),o}scaleToLevel(i){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[i])return this._levelByScale[i];{const e=this._fullCacheLodInfos;if(i>e[0].scale)return e[0].level;let t,a;for(let o=0;o<e.length-1;o++)if(a=e[o+1],i>a.scale)return t=e[o],t.level+(t.scale-i)/(t.scale-a.scale);return e[e.length-1].level}}_initializeFullCacheLODs(i){let e;if(i[0].level===0)e=i.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale}));else{const t=this.tileInfo.size[0],a=this.tileInfo.spatialReference;e=Jt.create({size:t,spatialReference:a}).lods.map(o=>({level:o.level,resolution:o.resolution,scale:o.scale}))}for(let t=0;t<e.length;t++)this._levelByScale[e[t].scale]=e[t].level;this._fullCacheLodInfos=e}},ht=class extends ne{constructor(i,e,t,a){super(i,e,t,i.tileInfo.lods.length-1),this._memCache=a,this._vectorTiles=new Map,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new ue(i.tileInfo,i.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(i=>i.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear(),this._vectorTiles.clear()}async getVectorTile(i,e){const t=new $(i[0],i[1],i[2],0);let a=this._vectorTiles.get(t.id)??this._memCache.get(t.id);if(a)return a.retain(),a;const o=await this._getVectorTileData(t);if(Ct(e),!this._layer)return null;if(a=this._vectorTiles.get(t.id)??this._memCache.get(t.id),a)return a.retain(),a;const r=this._layer.tileInfo.getTileBounds(Gt(),t),s=this._tileInfoView.getTileResolution(i[0]);return a=new Nt(t,s,r[0],r[3],it,it,this._styleRepository,this),a.setData(o),o&&(a.retain(),this._memCache.put(t.id,a,Vt),this._vectorTiles.set(t.id,a)),a.neededForCoverage=!0,a.transforms.tileUnitsToPixels=Ht(1/8,0,0,0,1/8,0,0,0,1),a}updateTileSize(i){this._memCache.updateSize(i.id)}onDisposeTile(i){this._vectorTiles.delete(i.id)}_getVectorTileData(i){const e=i.id;if(this._ongoingTileRequests.has(e))return this._ongoingTileRequests.get(e);const t=new AbortController,a={signal:t.signal},o=this._getParsedVectorTileData(i,a).then(r=>(this._ongoingTileRequests.delete(e),this._ongoingRequestToController.delete(e),r)).catch(()=>(this._ongoingTileRequests.delete(e),this._ongoingRequestToController.delete(e),null));return this._ongoingTileRequests.set(e,o),this._ongoingRequestToController.set(e,t),o}_getParsedVectorTileData(i,e){return this.fetchTileData(i,e).then(t=>this.parseTileData({key:i,data:t},e))}},q=class{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(i,e){}draw(i,e,t){}drawMany(i,e,t){for(const a of e)a.visible&&this.draw(i,a,t)}};class he extends q{constructor(){super(...arguments),this._color=Bt(1,0,0,1),this._patternMatrix=Wt(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao=J(this._vao)}drawMany(e,t){const{context:a,painter:o,requestRender:r,allowDelayedRender:s}=e;this._loadWGLResources(e);const l=e.displayLevel,n=e.styleLayer,c=n.backgroundMaterial,_=o.vectorTilesMaterialManager,p=n.getPaintValue("background-color",l),g=n.getPaintValue("background-opacity",l),w=n.getPaintValue("background-pattern",l),h=w!==void 0,v=1|window.devicePixelRatio,y=e.spriteMosaic;let P,d;const b=v>St?2:1,f=this._programOptions;f.pattern=h;const u=_.getMaterialProgram(a,c,f);if(!s||r==null||u.compiled){if(a.bindVAO(this._vao),a.useProgram(u),h){const S=y.getMosaicItemPosition(w,!0);if(S!=null){const{tl:m,br:x,page:T}=S;P=x[0]-m[0],d=x[1]-m[1];const M=y.getPageSize(T);M!=null&&(y.bind(a,9729,T,E),u.setUniform4f("u_tlbr",m[0],m[1],x[0],x[1]),u.setUniform2fv("u_mosaicSize",M),u.setUniform1i("u_texture",E))}u.setUniform1f("u_opacity",g)}else{const S=p[3]*g;this._color[0]=S*p[0],this._color[1]=S*p[1],this._color[2]=S*p[2],this._color[3]=S,u.setUniform4fv("u_color",this._color)}u.setUniform1f("u_depth",n.z||0);for(const S of t){if(u.setUniform1f("u_coord_range",S.rangeX),u.setUniformMatrix3fv("u_dvsMat3",S.transforms.displayViewScreenMat3),h){const m=Math.max(2**(Math.round(l)-S.key.level),1),x=b*S.width*m,T=x/rt(P),M=x/rt(d);this._patternMatrix[0]=T,this._patternMatrix[4]=M,u.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}a.setStencilFunction(514,0,255),a.drawArrays(k.TRIANGLE_STRIP,0,4)}}else r()}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:a}=e,o=a.backgroundMaterial,r=new Int8Array([0,0,1,0,0,1,1,1]),s=new Kt(t,o.geometryLayout,r);this._vao=new $t(t,s)}}let pe=class extends q{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(i,e){const{context:t,displayLevel:a,requiredLevel:o,state:r,painter:s,spriteMosaic:l,styleLayerUID:n,requestRender:c,allowDelayedRender:_}=i;if(!e.some(f=>f.layerData.get(n)?.circleIndexCount??!1))return;const p=i.styleLayer,g=p.circleMaterial,w=s.vectorTilesMaterialManager,h=1.2,v=p.getPaintValue("circle-translate",a),y=p.getPaintValue("circle-translate-anchor",a),P=this._programOptions,d=w.getMaterialProgram(t,g,P);if(_&&c!=null&&!d.compiled)return void c();t.useProgram(d),d.setUniformMatrix3fv("u_displayMat3",y===1?r.displayMat3:r.displayViewMat3),d.setUniform2fv("u_circleTranslation",v),d.setUniform1f("u_depth",p.z),d.setUniform1f("u_antialiasingWidth",h);let b=-1;for(const f of e){if(!f.layerData.has(n))continue;f.key.level!==b&&(b=f.key.level,g.setDataUniforms(d,a,p,b,l));const u=f.layerData.get(n);if(!u.circleIndexCount)continue;u.prepareForRendering(t);const S=u.vao;S!=null&&(t.bindVAO(S),d.setUniformMatrix3fv("u_dvsMat3",f.transforms.displayViewScreenMat3),o!==f.key.level?t.setStencilFunction(514,f.stencilRef,255):t.setStencilFunction(516,255,255),t.drawElements(k.TRIANGLES,u.circleIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*u.circleIndexStart),f.triangleCount+=u.circleIndexCount/3)}}};const pt=1/65536;let de=class extends q{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(i,e){const{displayLevel:t,renderPass:a,spriteMosaic:o,styleLayerUID:r}=i;let s=!1;for(const d of e)if(d.layerData.has(r)){const b=d.layerData.get(r);if(b.fillIndexCount>0||b.outlineIndexCount>0){s=!0;break}}if(!s)return;const l=i.styleLayer,n=l.getPaintProperty("fill-pattern"),c=n!==void 0,_=c&&n.isDataDriven;let p;if(c&&!_){const d=n.getValue(t);p=o.getMosaicItemPosition(d,!0)}const g=!c&&l.getPaintValue("fill-antialias",t);let w=!0,h=1;if(!c){const d=l.getPaintProperty("fill-color"),b=l.getPaintProperty("fill-opacity");if(!d?.isDataDriven&&!b?.isDataDriven){const f=l.getPaintValue("fill-color",t);h=l.getPaintValue("fill-opacity",t)*f[3],h>=1&&(w=!1)}}if(w&&a==="opaque")return;const v=l.getPaintValue("fill-translate",t),y=l.getPaintValue("fill-translate-anchor",t);(w||a!=="translucent")&&this._drawFill(i,r,l,e,v,y,c,p,_);const P=!l.hasDataDrivenOutlineColor&&l.outlineUsesFillColor&&h<1;g&&a!=="opaque"&&!P&&this._drawOutline(i,r,l,e,v,y)}_drawFill(i,e,t,a,o,r,s,l,n){if(s&&!n&&l==null)return;const{context:c,displayLevel:_,state:p,painter:g,pixelRatio:w,spriteMosaic:h,requestRender:v,allowDelayedRender:y}=i,P=t.fillMaterial,d=g.vectorTilesMaterialManager,b=w>St?2:1,f=this._fillProgramOptions;f.pattern=s;const u=d.getMaterialProgram(c,P,f);if(y&&v!=null&&!u.compiled)return void v();if(c.useProgram(u),l!=null){const{page:m}=l,x=h.getPageSize(m);x!=null&&(h.bind(c,9729,m,E),u.setUniform2fv("u_mosaicSize",x),u.setUniform1i("u_texture",E))}u.setUniformMatrix3fv("u_displayMat3",r===1?p.displayMat3:p.displayViewMat3),u.setUniform2fv("u_fillTranslation",o),u.setUniform1f("u_depth",t.z+pt);let S=-1;for(const m of a){if(!m.layerData.has(e))continue;m.key.level!==S&&(S=m.key.level,P.setDataUniforms(u,_,t,S,h));const x=m.layerData.get(e);if(!x.fillIndexCount)continue;x.prepareForRendering(c);const T=x.fillVAO;if(T!=null){if(c.bindVAO(T),u.setUniformMatrix3fv("u_dvsMat3",m.transforms.displayViewScreenMat3),c.setStencilFunction(514,m.stencilRef,255),s){const M=Math.max(2**(Math.round(_)-m.key.level),1),C=m.rangeX/(b*m.width*M);u.setUniform1f("u_patternFactor",C)}if(n){const M=x.patternMap;if(!M)continue;for(const[C,R]of M){const N=h.getPageSize(C);N!=null&&(h.bind(c,9729,C,E),u.setUniform2fv("u_mosaicSize",N),u.setUniform1i("u_texture",E),c.drawElements(k.TRIANGLES,R[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*R[0]))}}else c.drawElements(k.TRIANGLES,x.fillIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*x.fillIndexStart);m.triangleCount+=x.fillIndexCount/3}}}_drawOutline(i,e,t,a,o,r){const{context:s,displayLevel:l,state:n,painter:c,pixelRatio:_,spriteMosaic:p,requestRender:g,allowDelayedRender:w}=i,h=t.outlineMaterial,v=c.vectorTilesMaterialManager,y=.75/_,P=this._outlineProgramOptions,d=v.getMaterialProgram(s,h,P);if(w&&g!=null&&!d.compiled)return void g();s.useProgram(d),d.setUniformMatrix3fv("u_displayMat3",r===1?n.displayMat3:n.displayViewMat3),d.setUniform2fv("u_fillTranslation",o),d.setUniform1f("u_depth",t.z+pt),d.setUniform1f("u_outline_width",y);let b=-1;for(const f of a){if(!f.layerData.has(e))continue;f.key.level!==b&&(b=f.key.level,h.setDataUniforms(d,l,t,b,p));const u=f.layerData.get(e);if(u.prepareForRendering(s),!u.outlineIndexCount)continue;const S=u.outlineVAO;S!=null&&(s.bindVAO(S),d.setUniformMatrix3fv("u_dvsMat3",f.transforms.displayViewScreenMat3),s.setStencilFunction(514,f.stencilRef,255),s.drawElements(k.TRIANGLES,u.outlineIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*u.outlineIndexStart),f.triangleCount+=u.outlineIndexCount/3)}}},me=class extends q{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(i,e){const{context:t,displayLevel:a,state:o,painter:r,pixelRatio:s,spriteMosaic:l,styleLayerUID:n,requestRender:c,allowDelayedRender:_}=i;if(!e.some(M=>M.layerData.get(n)?.lineIndexCount??!1))return;const p=i.styleLayer,g=p.lineMaterial,w=r.vectorTilesMaterialManager,h=p.getPaintValue("line-translate",a),v=p.getPaintValue("line-translate-anchor",a),y=p.getPaintProperty("line-pattern"),P=y!==void 0,d=P&&y.isDataDriven;let b,f;if(P&&!d){const M=y.getValue(a);b=l.getMosaicItemPosition(M)}let u=!1;if(!P){const M=p.getPaintProperty("line-dasharray");if(f=M!==void 0,u=f&&M.isDataDriven,f&&!u){const C=M.getValue(a),R=p.getDashKey(C,p.getLayoutValue("line-cap",a));b=l.getMosaicItemPosition(R)}}const S=1/s,m=this._programOptions;m.pattern=P,m.sdf=f;const x=w.getMaterialProgram(t,g,m);if(_&&c!=null&&!x.compiled)return void c();if(t.useProgram(x),x.setUniformMatrix3fv("u_displayViewMat3",o.displayViewMat3),x.setUniformMatrix3fv("u_displayMat3",v===1?o.displayMat3:o.displayViewMat3),x.setUniform2fv("u_lineTranslation",h),x.setUniform1f("u_depth",p.z),x.setUniform1f("u_antialiasing",S),b&&b!=null){const{page:M}=b,C=l.getPageSize(M);C!=null&&(l.bind(t,9729,M,E),x.setUniform2fv("u_mosaicSize",C),x.setUniform1i("u_texture",E))}let T=-1;for(const M of e){if(!M.layerData.has(n))continue;M.key.level!==T&&(T=M.key.level,g.setDataUniforms(x,a,p,T,l));const C=2**(a-T)/s;x.setUniform1f("u_zoomFactor",C);const R=M.layerData.get(n);if(!R.lineIndexCount)continue;R.prepareForRendering(t);const N=R.vao;if(N!=null){if(t.bindVAO(N),x.setUniformMatrix3fv("u_dvsMat3",M.transforms.displayViewScreenMat3),t.setStencilFunction(514,M.stencilRef,255),d||u){const Y=R.patternMap;if(!Y)continue;for(const[K,D]of Y){const B=l.getPageSize(K);B!=null&&(l.bind(t,9729,K,E),x.setUniform2fv("u_mosaicSize",B),x.setUniform1i("u_texture",E),t.drawElements(k.TRIANGLES,D[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*D[0]))}}else t.drawElements(k.TRIANGLES,R.lineIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*R.lineIndexStart);M.triangleCount+=R.lineIndexCount/3}}}};const _e=256/360;function fe(i,e){return(i%=e)>=0?i:i+e}function dt(i){return fe(i*_e,256)}const ge=1/65536;class ve extends q{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=Qt()}dispose(){}drawMany(e,t){const a=e.styleLayer;this._drawIcons(e,a,t),this._drawText(e,a,t)}_drawIcons(e,t,a){const{context:o,displayLevel:r,painter:s,spriteMosaic:l,state:n,styleLayerUID:c,requestRender:_,allowDelayedRender:p}=e,g=t.iconMaterial,w=s.vectorTilesMaterialManager;let h,v=!1;for(const T of a)if(T.layerData.has(c)&&(h=T.layerData.get(c),h.iconPerPageElementsMap.size>0)){v=!0;break}if(!v)return;const y=t.getPaintValue("icon-translate",r),P=t.getPaintValue("icon-translate-anchor",r);let d=t.getLayoutValue("icon-rotation-alignment",r);d===2&&(d=t.getLayoutValue("symbol-placement",r)===0?1:0);const b=d===0,f=t.getLayoutValue("icon-keep-upright",r)&&b,u=h.isIconSDF,S=this._iconProgramOptions;S.sdf=u;const m=w.getMaterialProgram(o,g,S);if(p&&_!=null&&!m.compiled)return void _();o.useProgram(m),m.setUniformMatrix3fv("u_displayViewMat3",d===0?n.displayViewMat3:n.displayMat3),m.setUniformMatrix3fv("u_displayMat3",P===1?n.displayMat3:n.displayViewMat3),m.setUniform2fv("u_iconTranslation",y),m.setUniform1f("u_depth",t.z),m.setUniform1f("u_mapRotation",dt(n.rotation)),m.setUniform1f("u_keepUpright",f?1:0),m.setUniform1f("u_level",10*r),m.setUniform1i("u_texture",E),m.setUniform1f("u_fadeDuration",st/1e3),m.setUniform1i("u_isStencilPass",e.stencilSymbols?1:0);let x=-1;for(const T of a){if(!T.layerData.has(c)||(T.key.level!==x&&(x=T.key.level,g.setDataUniforms(m,r,t,x,l)),h=T.layerData.get(c),h.iconPerPageElementsMap.size===0))continue;h.prepareForRendering(o),h.updateOpacityInfo();const M=h.iconVAO;if(M!=null){o.bindVAO(M),m.setUniformMatrix3fv("u_dvsMat3",T.transforms.displayViewScreenMat3),m.setUniform1f("u_time",(performance.now()-h.lastOpacityUpdate)/1e3);for(const[C,R]of h.iconPerPageElementsMap)this._renderIconRange(e,m,R,C,T)}}}_renderIconRange(e,t,a,o,r){const{context:s,spriteMosaic:l}=e;this._spritesTextureSize[0]=l.getWidth(o)/4,this._spritesTextureSize[1]=l.getHeight(o)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),l.bind(s,9729,o,E),this._setStencilState(e,r),s.drawElements(k.TRIANGLES,a[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a[0]),r.triangleCount+=a[1]/3}_drawText(e,t,a){const{context:o,displayLevel:r,glyphMosaic:s,painter:l,pixelRatio:n,spriteMosaic:c,state:_,styleLayerUID:p,requestRender:g,allowDelayedRender:w}=e,h=t.textMaterial,v=l.vectorTilesMaterialManager;let y,P=!1;for(const U of a)if(U.layerData.has(p)&&(y=U.layerData.get(p),y.glyphPerPageElementsMap.size>0)){P=!0;break}if(!P)return;const d=t.getPaintProperty("text-opacity");if(d&&!d.isDataDriven&&d.getValue(r)===0)return;const b=t.getPaintProperty("text-color"),f=!b||b.isDataDriven||b.getValue(r)[3]>0,u=t.getPaintProperty("text-halo-width"),S=t.getPaintProperty("text-halo-color"),m=(!u||u.isDataDriven||u.getValue(r)>0)&&(!S||S.isDataDriven||S.getValue(r)[3]>0);if(!f&&!m)return;const x=24/8;let T=t.getLayoutValue("text-rotation-alignment",r);T===2&&(T=t.getLayoutValue("symbol-placement",r)===0?1:0);const M=T===0,C=t.getLayoutValue("text-keep-upright",r)&&M,R=.8*x/n;this._glyphTextureSize||(this._glyphTextureSize=te(s.width/4,s.height/4));const N=t.getPaintValue("text-translate",r),Y=t.getPaintValue("text-translate-anchor",r),K=this._sdfProgramOptions,D=v.getMaterialProgram(o,h,K);if(w&&g!=null&&!D.compiled)return void g();o.useProgram(D),D.setUniformMatrix3fv("u_displayViewMat3",T===0?_.displayViewMat3:_.displayMat3),D.setUniformMatrix3fv("u_displayMat3",Y===1?_.displayMat3:_.displayViewMat3),D.setUniform2fv("u_textTranslation",N),D.setUniform1f("u_depth",t.z+ge),D.setUniform2fv("u_mosaicSize",this._glyphTextureSize),D.setUniform1f("u_mapRotation",dt(_.rotation)),D.setUniform1f("u_keepUpright",C?1:0),D.setUniform1f("u_level",10*r),D.setUniform1i("u_texture",ot),D.setUniform1f("u_antialiasingWidth",R),D.setUniform1f("u_fadeDuration",st/1e3);let B=-1;for(const U of a){if(!U.layerData.has(p)||(U.key.level!==B&&(B=U.key.level,h.setDataUniforms(D,r,t,B,c)),y=U.layerData.get(p),y.glyphPerPageElementsMap.size===0))continue;y.prepareForRendering(o),y.updateOpacityInfo();const Z=y.textVAO;if(Z==null)continue;o.bindVAO(Z),D.setUniformMatrix3fv("u_dvsMat3",U.transforms.displayViewScreenMat3),this._setStencilState(e,U);const Mt=(performance.now()-y.lastOpacityUpdate)/1e3;D.setUniform1f("u_time",Mt),y.glyphPerPageElementsMap.forEach((Pt,Tt)=>{this._renderGlyphRange(o,Pt,Tt,s,D,m,f,U)})}}_renderGlyphRange(e,t,a,o,r,s,l,n){o.bind(e,9729,a,ot),s&&(r.setUniform1f("u_halo",1),e.drawElements(k.TRIANGLES,t[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),n.triangleCount+=t[1]/3),l&&(r.setUniform1f("u_halo",0),e.drawElements(k.TRIANGLES,t[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),n.triangleCount+=t[1]/3)}_setStencilState(e,t){const{context:a,is3D:o,stencilSymbols:r}=e;if(a.setStencilTestEnabled(!0),r)return a.setStencilWriteMask(255),void a.setStencilFunction(519,t.stencilRef,255);a.setStencilWriteMask(0),o?a.setStencilFunction(514,t.stencilRef,255):a.setStencilFunction(516,255,255)}}const H={vtlBackground:he,vtlFill:de,vtlLine:me,vtlCircle:pe,vtlSymbol:ve},ye={background:{"background.frag":`#ifdef PATTERN
uniform lowp float u_opacity;
uniform lowp sampler2D u_texture;
varying mediump vec4 v_tlbr;
varying mediump vec2 v_tileTextureCoord;
#else
uniform lowp vec4 u_color;
#endif
void main() {
#ifdef PATTERN
mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);
mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);
lowp vec4 color = texture2D(u_texture, samplePos);
gl_FragColor = u_opacity * color;
#else
gl_FragColor = u_color;
#endif
}`,"background.vert":`precision mediump float;
attribute vec2 a_pos;
uniform highp mat3 u_dvsMat3;
uniform mediump float u_coord_range;
uniform mediump float u_depth;
#ifdef PATTERN
uniform mediump mat3 u_pattern_matrix;
varying mediump vec2 v_tileTextureCoord;
uniform mediump vec4 u_tlbr;
uniform mediump vec2 u_mosaicSize;
varying mediump vec4 v_tlbr;
#endif
void main() {
gl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);
#ifdef PATTERN
v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;
v_tlbr             = u_tlbr / u_mosaicSize.xyxy;
#endif
}`},circle:{"circle.frag":`precision lowp float;
varying lowp vec4 v_color;
varying lowp vec4 v_stroke_color;
varying mediump float v_blur;
varying mediump float v_stroke_width;
varying mediump float v_radius;
varying mediump vec2 v_offset;
void main()
{
mediump float dist = length(v_offset);
mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);
lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));
gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);
}`,"circle.vert":`precision mediump float;
attribute vec2 a_pos;
#pragma header
varying lowp vec4 v_color;
varying lowp vec4 v_stroke_color;
varying mediump float v_blur;
varying mediump float v_stroke_width;
varying mediump float v_radius;
varying mediump vec2 v_offset;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump vec2 u_circleTranslation;
uniform mediump float u_depth;
uniform mediump float u_antialiasingWidth;
void main()
{
#pragma main
v_color = color * opacity;
v_stroke_color = stroke_color * stroke_opacity;
v_stroke_width = stroke_width;
v_radius = radius;
v_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));
mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);
v_offset = offset;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},fill:{"fill.frag":`precision lowp float;
#ifdef PATTERN
uniform lowp sampler2D u_texture;
varying mediump vec2 v_tileTextureCoord;
varying mediump vec4 v_tlbr;
#endif
varying lowp vec4 v_color;
vec4 mixColors(vec4 color1, vec4 color2) {
float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);
vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);
return vec4(compositeColor, compositeAlpha);
}
void main()
{
#ifdef PATTERN
mediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);
mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);
lowp vec4 color = texture2D(u_texture, samplePos);
gl_FragColor = v_color[3] * color;
#else
gl_FragColor = v_color;
#endif
}`,"fill.vert":`precision mediump float;
attribute vec2 a_pos;
#pragma header
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump float u_depth;
uniform mediump vec2 u_fillTranslation;
#ifdef PATTERN
#include <util/util.glsl>
uniform mediump vec2 u_mosaicSize;
uniform mediump float u_patternFactor;
varying mediump vec2 v_tileTextureCoord;
varying mediump vec4 v_tlbr;
#endif
varying lowp vec4 v_color;
void main()
{
#pragma main
v_color = color * opacity;
#ifdef PATTERN
float patternWidth = nextPOT(tlbr.z - tlbr.x);
float patternHeight = nextPOT(tlbr.w - tlbr.y);
float scaleX = 1.0 / (patternWidth * u_patternFactor);
float scaleY = 1.0 / (patternHeight * u_patternFactor);
mat3 patterMat = mat3(scaleX, 0.0,    0.0,
0.0,    -scaleY, 0.0,
0.0,    0.0,    1.0);
v_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;
v_tlbr             = tlbr / u_mosaicSize.xyxy;
#endif
vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},icon:{"icon.frag":`precision mediump float;
uniform lowp sampler2D u_texture;
#ifdef SDF
uniform lowp vec4 u_color;
uniform lowp vec4 u_outlineColor;
#endif
uniform highp int u_isStencilPass;
varying mediump vec2 v_tex;
varying lowp float v_opacity;
varying mediump vec2 v_size;
varying lowp vec4 v_color;
#ifdef SDF
varying mediump flaot v_halo_width;
#endif
const float alphaCutoff = 1.0 / 255.5;
#include <util/encoding.glsl>
vec4 mixColors(vec4 color1, vec4 color2) {
float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);
vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);
return vec4(compositeColor, compositeAlpha);
}
void main()
{
#ifdef SDF
lowp vec4 fillPixelColor = v_color;
float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;
const float softEdgeRatio = 0.248062016;
float size = max(v_size.x, v_size.y);
float dist = d * softEdgeRatio * size;
fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);
if (v_halo_width > 0.25) {
lowp vec4 outlinePixelColor = u_outlineColor;
const float outlineLimitRatio = (16.0 / 86.0);
float clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));
outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);
gl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);
}
else {
gl_FragColor = v_opacity * fillPixelColor;
}
#else
lowp vec4 texColor = texture2D(u_texture, v_tex);
if (u_isStencilPass == 1 && texColor.a < alphaCutoff) {
discard;
}
gl_FragColor = v_opacity * texColor;
#endif
}`,"icon.vert":`attribute vec2 a_pos;
attribute vec2 a_vertexOffset;
attribute vec4 a_texAngleRange;
attribute vec4 a_levelInfo;
attribute float a_opacityInfo;
#pragma header
varying lowp vec4 v_color;
#ifdef SDF
varying mediump float v_halo_width;
#endif
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump vec2 u_iconTranslation;
uniform vec2 u_mosaicSize;
uniform mediump float u_depth;
uniform mediump float u_mapRotation;
uniform mediump float u_level;
uniform lowp float u_keepUpright;
uniform mediump float u_fadeDuration;
varying mediump vec2 v_tex;
varying lowp float v_opacity;
varying mediump vec2 v_size;
const float C_OFFSET_PRECISION = 1.0 / 8.0;
const float C_256_TO_RAD = 3.14159265359 / 128.0;
const float C_DEG_TO_RAD = 3.14159265359 / 180.0;
const float tileCoordRatio = 1.0 / 8.0;
uniform highp float u_time;
void main()
{
#pragma main
v_color = color;
v_opacity = opacity;
#ifdef SDF
v_halo_width = halo_width;
#endif
float modded = mod(a_opacityInfo, 128.0);
float targetOpacity = (a_opacityInfo - modded) / 128.0;
float startOpacity = modded / 127.0;
float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);
v_opacity *= interpolatedOpacity;
mediump float a_angle         = a_levelInfo[1];
mediump float a_minLevel      = a_levelInfo[2];
mediump float a_maxLevel      = a_levelInfo[3];
mediump vec2 a_tex            = a_texAngleRange.xy;
mediump float delta_z = 0.0;
mediump float rotated = mod(a_angle + u_mapRotation, 256.0);
delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));
delta_z += 1.0 - step(a_minLevel, u_level);
delta_z += step(a_maxLevel, u_level);
delta_z += step(v_opacity, 0.0);
vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;
v_size = abs(offset);
#ifdef SDF
offset = (120.0 / 86.0) * offset;
#endif
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);
v_tex = a_tex.xy / u_mosaicSize;
}`},line:{"line.frag":`precision lowp float;
varying mediump vec2 v_normal;
varying highp float v_accumulatedDistance;
varying mediump float v_lineHalfWidth;
varying lowp vec4 v_color;
varying mediump float v_blur;
#if defined (PATTERN) || defined(SDF)
varying mediump vec4 v_tlbr;
varying mediump vec2 v_patternSize;
varying mediump float v_widthRatio;
uniform sampler2D u_texture;
uniform mediump float u_antialiasing;
#endif
#ifdef SDF
#include <util/encoding.glsl>
#endif
void main()
{
mediump float fragDist = length(v_normal) * v_lineHalfWidth;
lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);
#ifdef PATTERN
mediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));
mediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);
mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));
lowp vec4 color = texture2D(u_texture, texCoord);
gl_FragColor = alpha * v_color[3] * color;
#elif defined(SDF)
mediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));
mediump float relativeTexY =  0.5 + 0.25 * v_normal.y;
mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));
mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;
float dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);
gl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;
#else
gl_FragColor = alpha * v_color;
#endif
}`,"line.vert":`precision mediump float;
attribute vec2 a_pos;
attribute vec4 a_extrude_offset;
attribute vec4 a_dir_normal;
attribute vec2 a_accumulatedDistance;
#pragma header
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump float u_zoomFactor;
uniform mediump vec2 u_lineTranslation;
uniform mediump float u_antialiasing;
uniform mediump float u_depth;
varying mediump vec2 v_normal;
varying highp float v_accumulatedDistance;
const float scale = 1.0 / 31.0;
const mediump float tileCoordRatio = 8.0;
#if defined (SDF)
const mediump float sdfPatternHalfWidth = 15.5;
#endif
#if defined (PATTERN) || defined(SDF)
uniform mediump vec2 u_mosaicSize;
varying mediump vec4 v_tlbr;
varying mediump vec2 v_patternSize;
varying mediump float v_widthRatio;
#endif
varying lowp vec4 v_color;
varying mediump float v_lineHalfWidth;
varying mediump float v_blur;
void main()
{
#pragma main
v_color = color * opacity;
v_blur = blur + u_antialiasing;
v_normal = a_dir_normal.zw * scale;
#if defined (PATTERN) || defined(SDF)
v_tlbr          = tlbr / u_mosaicSize.xyxy;
v_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);
#if defined (PATTERN)
v_widthRatio = width / v_patternSize.y;
#else
v_widthRatio = width / sdfPatternHalfWidth / 2.0;
#endif
#endif
v_lineHalfWidth = (width + u_antialiasing) * 0.5;
mediump vec2 dir = a_dir_normal.xy * scale;
mediump vec2 offset_ = a_extrude_offset.zw * scale * offset;
mediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
#if defined (PATTERN) || defined(SDF)
v_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);
#endif
}`},outline:{"outline.frag":`varying lowp vec4 v_color;
varying mediump vec2 v_normal;
void main()
{
lowp float dist = abs(v_normal.y);
lowp float alpha = smoothstep(1.0, 0.0, dist);
gl_FragColor = alpha * v_color;
}`,"outline.vert":`attribute vec2 a_pos;
attribute vec2 a_offset;
attribute vec2 a_xnormal;
#pragma header
varying lowp vec4 v_color;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump vec2 u_fillTranslation;
uniform mediump float u_depth;
uniform mediump float u_outline_width;
varying lowp vec2 v_normal;
const float scale = 1.0 / 15.0;
void main()
{
#pragma main
v_color = color * opacity;
v_normal = a_xnormal;
mediump vec2 dist = u_outline_width * scale * a_offset;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},text:{"text.frag":`uniform lowp sampler2D u_texture;
varying lowp vec2 v_tex;
varying lowp vec4 v_color;
varying mediump float v_edgeWidth;
varying mediump float v_edgeDistance;
void main()
{
lowp float dist = texture2D(u_texture, v_tex).a;
mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);
gl_FragColor = alpha * v_color;
}`,"text.vert":`attribute vec2 a_pos;
attribute vec2 a_vertexOffset;
attribute vec4 a_texAngleRange;
attribute vec4 a_levelInfo;
attribute float a_opacityInfo;
#pragma header
varying lowp vec4 v_color;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump vec2 u_textTranslation;
uniform vec2 u_mosaicSize;
uniform mediump float u_depth;
uniform mediump float u_mapRotation;
uniform mediump float u_level;
uniform lowp float u_keepUpright;
uniform mediump float u_fadeDuration;
varying lowp vec2 v_tex;
const float offsetPrecision = 1.0 / 8.0;
const mediump float edgePos = 0.75;
uniform mediump float u_antialiasingWidth;
varying mediump float v_edgeDistance;
varying mediump float v_edgeWidth;
uniform lowp float u_halo;
const float sdfFontScale = 1.0 / 24.0;
const float sdfPixel = 3.0;
uniform highp float u_time;
void main()
{
#pragma main
if (u_halo > 0.5)
{
v_color = halo_color * opacity;
halo_width *= sdfPixel;
halo_blur *= sdfPixel;
}
else
{
v_color = color * opacity;
halo_width = 0.0;
halo_blur = 0.0;
}
float modded = mod(a_opacityInfo, 128.0);
float targetOpacity = (a_opacityInfo - modded) / 128.0;
float startOpacity = modded / 127.0;
float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);
v_color *= interpolatedOpacity;
mediump float a_angle       = a_levelInfo[1];
mediump float a_minLevel    = a_levelInfo[2];
mediump float a_maxLevel    = a_levelInfo[3];
mediump vec2 a_tex          = a_texAngleRange.xy;
mediump float a_visMinAngle    = a_texAngleRange.z;
mediump float a_visMaxAngle    = a_texAngleRange.w;
mediump float delta_z = 0.0;
mediump float angle = mod(a_angle + u_mapRotation, 256.0);
if (a_visMinAngle < a_visMaxAngle)
{
delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));
}
else
{
delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));
}
delta_z += 1.0 - step(a_minLevel, u_level);
delta_z += step(a_maxLevel, u_level);
delta_z += step(v_color[3], 0.0);
v_tex = a_tex.xy / u_mosaicSize;
v_edgeDistance = edgePos - halo_width / size;
v_edgeWidth = (u_antialiasingWidth + halo_blur) / size;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);
}`},util:{"encoding.glsl":`const vec4 rgba2float_factors = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, rgba2float_factors);
}`,"util.glsl":`float nextPOT(in float x) {
return pow(2.0, ceil(log2(abs(x))));
}`}};let xe=class{constructor(i){this._readFile=i}resolveIncludes(i){return this._resolve(i)}_resolve(i,e=new Map){if(e.has(i))return e.get(i);const t=this._read(i);if(!t)throw new Error(`cannot find shader file ${i}`);const a=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let o=a.exec(t);const r=[];for(;o!=null;)r.push({path:o[1],start:o.index,length:o[0].length}),o=a.exec(t);let s=0,l="";return r.forEach(n=>{l+=t.slice(s,n.start),l+=e.has(n.path)?"":this._resolve(n.path,e),s=n.start+n.length}),l+=t.slice(s),e.set(i,l),l}_read(i){return this._readFile(i)}};function we(i){let e=ye;return i.split("/").forEach(t=>{e&&(e=e[t])}),e}const Se=new xe(we);function I(i){return Se.resolveIncludes(i)}function be(i){const{options:e,value:t}=i;return typeof e[t]=="number"}function j(i){let e="";for(const t in i){const a=i[t];if(typeof a=="boolean")a&&(e+=`#define ${t}
`);else if(typeof a=="number")e+=`#define ${t} ${a.toFixed()}
`;else if(typeof a=="object")if(be(a)){const{value:o,options:r,namespace:s}=a,l=s?`${s}_`:"";for(const n in r)e+=`#define ${l}${n} ${r[n].toFixed()}
`;e+=`#define ${t} ${l}${o}
`}else{const o=a.options;let r=0;for(const s in o)e+=`#define ${o[s]} ${(r++).toFixed()}
`;e+=`#define ${t} ${o[a.value]}
`}}return e}const mt=i=>j({PATTERN:i.pattern}),Me={shaders:i=>({vertexShader:mt(i)+I("background/background.vert"),fragmentShader:mt(i)+I("background/background.frag")})},Pe={shaders:i=>({vertexShader:I("circle/circle.vert"),fragmentShader:I("circle/circle.frag")})},_t=i=>j({PATTERN:i.pattern}),Te={shaders:i=>({vertexShader:_t(i)+I("fill/fill.vert"),fragmentShader:_t(i)+I("fill/fill.frag")})},De={shaders:i=>({vertexShader:I("outline/outline.vert"),fragmentShader:I("outline/outline.frag")})},ft=i=>j({SDF:i.sdf}),Re={shaders:i=>({vertexShader:ft(i)+I("icon/icon.vert"),fragmentShader:ft(i)+I("icon/icon.frag")})},gt=i=>j({PATTERN:i.pattern,SDF:i.sdf}),Ce={shaders:i=>({vertexShader:gt(i)+I("line/line.vert"),fragmentShader:gt(i)+I("line/line.frag")})},Ie={shaders:i=>({vertexShader:I("text/text.vert"),fragmentShader:I("text/text.frag")})};class Ee{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,t,a){const o=t.key<<3|this._getMaterialOptionsValue(t.type,a);if(this._programByKey.has(o))return this._programByKey.get(o);const r=this._getProgramTemplate(t.type),{shaders:s}=r,{vertexShader:l,fragmentShader:n}=s(a),c=t.getShaderHeader(),_=t.getShaderMain(),p=l.replace("#pragma header",c).replace("#pragma main",_),g=e.programCache.acquire(p,n,t.getAttributeLocations());return this._programByKey.set(o,g),g}_getMaterialOptionsValue(e,t){switch(e){case 0:return(t.pattern?1:0)<<1;case 1:return(t.pattern?1:0)<<1;case 2:case 5:case 6:default:return 0;case 3:{const a=t;return(a.sdf?1:0)<<2|(a.pattern?1:0)<<1}case 4:return(t.sdf?1:0)<<1}}_getProgramTemplate(e){switch(e){case 0:return Me;case 5:return Pe;case 1:return Te;case 4:return Re;case 3:return Ce;case 2:return De;case 6:return Ie;default:return null}}}const W=1e-6;class vt{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new Ee}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=J(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,t,a){const o=a.layers;e.renderPass="translucent";let r=this._brushCache.vtlSymbol;r==null&&(r=new H.vtlSymbol,this._brushCache.vtlSymbol=r),V[0]=t;for(let s=0;s<o.length;s++){const l=o[s];if(l.type!==3)continue;const n=l.getLayoutProperty("visibility");if(n&&n.getValue()===1)continue;const c=e.displayLevel;l.minzoom!==void 0&&l.minzoom>c+W||l.maxzoom!==void 0&&l.maxzoom<=c-W||(e.styleLayerUID=l.uid,e.styleLayer=l,r.drawMany(e,V))}V[0]=null}drawBackground(e,t,a){if(a.backgroundBucketIds.length===0)return;const{context:o,displayLevel:r,requiredLevel:s}=e;t.key.level=s,o.setBlendingEnabled(!0),o.setDepthTestEnabled(!1),o.setStencilTestEnabled(!1),e.renderPass="background";let l=this._brushCache.vtlBackground;l==null&&(l=new H.vtlBackground,this._brushCache.vtlBackground=l),V[0]=t,a.backgroundBucketIds.forEach(n=>{const c=a.getLayerById(n);if(c.type!==0)return;const _=c.getLayoutProperty("visibility");_&&_.getValue()===1||c.minzoom!==void 0&&c.minzoom>r+W||c.maxzoom!==void 0&&c.maxzoom<=r-W||(e.styleLayerUID=c.uid,e.styleLayer=c,l.drawMany(e,V))}),V[0]=null}drawTile(e,t,a,o){const{context:r}=e,s=a.layers;r.setBlendingEnabled(!1),r.setDepthTestEnabled(!0),r.setDepthWriteEnabled(!0),r.setDepthFunction(515);const l=s.filter(n=>o!=null&&o!==n.type||!t.layerData.has(n.uid)?!1:n.getLayoutProperty("visibility")?.getValue()!==1);e.renderPass="opaque";for(let n=l.length-1;n>=0;--n)this._renderStyleLayer(l[n],e,t);r.setDepthWriteEnabled(!1),r.setBlendingEnabled(!0),r.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent",l.forEach(n=>this._renderStyleLayer(n,e,t)),r.setDepthTestEnabled(!1),r.bindVAO(null)}_renderStyleLayer(e,t,a){const{renderPass:o}=t;let r;switch(e.type){case 0:if(o!=="background")return;r=this._brushCache.vtlBackground,r||(r=new H.vtlBackground,this._brushCache.vtlBackground=r);break;case 1:if(o!=="opaque"&&t.renderPass!=="translucent")return;r=this._brushCache.vtlFill,r==null&&(r=new H.vtlFill,this._brushCache.vtlFill=r);break;case 2:if(o!=="translucent")return;r=this._brushCache.vtlLine,r==null&&(r=new H.vtlLine,this._brushCache.vtlLine=r);break;case 4:if(o!=="translucent")return;r=this._brushCache.vtlCircle,r==null&&(r=new H.vtlCircle,this._brushCache.vtlCircle=r);break;case 3:if(o!=="translucent")return;r=this._brushCache.vtlSymbol,r==null&&(r=new H.vtlSymbol,this._brushCache.vtlSymbol=r)}const{displayLevel:s}=t,{minzoom:l,maxzoom:n}=e;if(l!==void 0&&l>s+W||n!==void 0&&n<=s-W)return;const{context:c}=t;c.setStencilTestEnabled(!1),c.setStencilWriteMask(0),t.styleLayerUID=e.uid,t.styleLayer=e,V[0]=a,r.drawMany(t,V),V[0]=null}}const V=[null];let L=class extends ie(ee(ae)){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=Q("disable-feature:vtl-level-shift")?0:1}initialize(){if(this.layer.fullExtent==null)return void this.addResolvingPromise(Promise.reject(new Dt("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:i,spatialReference:e,state:t,viewingMode:a}=this.view,o=a==="local"&&!Ft(e)||Ot.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),r=this._getTileInfoSupportError(o,this.layer.fullExtent);if(r!=null)return this.addResolvingPromise(Promise.reject(r));const s=zt(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const v=i.tilingScheme,y=v.pixelSize,P=y===256?1:2,d=i.spatialReference?.isGeographic&&y===256?1:0,b=i.spatialReference?.isGeographic||y!==256?0:1;let f;this.schemaHelper=new re(P,d,this.levelShift+b),f=y===256||y===512?this.layer.tileInfo.getCompatibleForVTL(y):this.layer.tileInfo;const u=this._getTileInfoCompatibilityError(f,v);if(u)throw u;this.tileInfo=f});this._tileHandlerController=new AbortController;const l=this.view.resourceController;this._memCache=l.memoryController.newCache(`vtl-${this.layer.uid}`,v=>v.release()),this.addHandles(kt(()=>this.view.qualitySettings.memoryLimit,v=>this._memCache.maxSize=Math.ceil(v/10*1048576),At));const n=new lt(this.layer.currentStyleInfo.style);this._tileHandler=new ht(this.layer,n,t.contentPixelRatio,this._memCache);const c=this._tileHandlerController.signal,_=Le(l),p=this._tileHandler.start({signal:c,schedule:_}),g=this._tileHandler.spriteMosaic;g.then(v=>{!Rt(c)&&this._tileHandler&&(this.painter=new vt(v,this._tileHandler.glyphMosaic))}),p.then(()=>this._tileHandlerController=null);const w=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const v=this.layer.currentStyleInfo.style,y=this.view.state?.contentPixelRatio??1,P=new lt(v),d=new ht(this.layer,P,y,this._memCache),b=d.start({signal:this._tileHandlerController.signal,schedule:_}),f=d.spriteMosaic;b.then(()=>this._tileHandlerController=null),this._updatingHandles.addPromise(Promise.all([b,f]).then(([,u])=>{const S=this._tileHandler,m=this.painter;this.painter=new vt(u,d.glyphMosaic),this._tileHandler=d,this.emit("data-changed"),S.destroy(),m&&m.dispose()}))};this._updatingHandles.add(()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio}),w),this.addHandles([this.layer.on("paint-change",()=>this.emit("data-changed")),this.layer.on("style-layer-change",w),this.layer.on("delete-style-layer",w),this.layer.on("spriteSource-change",()=>this.emit("data-changed")),this.layer.on("layout-change",()=>this.emit("data-changed")),this.layer.on("style-layer-visibility-change",()=>this.emit("data-changed"))]);const h=Promise.all([s,p,g]);this.addResolvingPromise(h)}destroy(){this.painter=J(this.painter),this._tileHandlerController=yt(this._tileHandlerController),this._tileHandler=tt(this._tileHandler),this._memCache=tt(this._memCache)}get contentZoom(){return Q("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const i=this.tileInfo.lods,e=this.layer.minScale||i[0].scale,t=this.layer.maxScale||i[i.length-1].scale,a=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale?a.maxLevel++:a.maxLevel+=this.levelShift,a}get dataScaleRange(){const i=this.tileInfo.lods;return{minScale:i[0].scale,maxScale:i[i.length-1].scale}}get dataLevelRange(){const{minScale:i,maxScale:e}=this.dataScaleRange,t=this.levelRangeFromScaleRange(i,e);return t.minLevel===1&&this.tileInfo.size[0]===256&&(t.minLevel=0),t.maxLevel+=this.levelShift,t}async fetchTile(i,e){const t=this.schemaHelper.getLevelRowColumn(i);return this._tileHandler.getVectorTile(t,e)}get hasVisibleFeatures(){return!0}};A([O()],L.prototype,"layer",void 0),A([O()],L.prototype,"levelShift",void 0),A([O()],L.prototype,"contentZoom",null),A([O()],L.prototype,"displayLevelRange",null),A([O()],L.prototype,"tileInfo",void 0),A([O()],L.prototype,"dataScaleRange",null),A([O()],L.prototype,"dataLevelRange",null),A([O()],L.prototype,"updatingProgressValue",void 0),L=A([Ut("esri.views.3d.layers.VectorTileLayerView3D")],L);const Tr=L;function Le(i){return e=>i.immediate.schedule(e)}export{Tr as default};
