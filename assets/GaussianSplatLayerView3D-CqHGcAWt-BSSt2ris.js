import{v as Ue,s as je,az as se,Y as q,G as Ae,H as Y}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{j as te,l as $e}from"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import{aS as We,a1 as Ne,R as Ze,af as Ye}from"./Point-BfTTZoMu-DeJwQYfh.js";import{c as Xe}from"./quatf64-CCm9z-pX-CQ7_sSji.js";import{ae as Ke,ag as Qe,af as Je,bM as et,d as tt,V as it,bJ as at,bL as he}from"./ShadowCastClear.glsl-CeOT_rAo-BEYyVrmo.js";import{B as st}from"./tiles3DUtils-CDSpqUp9-BNKy0CHl.js";import{w as rt}from"./elevationInfoUtils-B8MpdRMP-CDlK86wO.js";import{i as nt}from"./unitConversionUtils-4vB4Ezlp-DnY5MDxd.js";import{u as ot}from"./LayerView3D-JY0KVfxL-H13gXtj0.js";import{d as de}from"./orientedBoundingBox-BLEx7wLU-ByGP9QG1.js";import{h as ct}from"./memoryEstimations-Bd726a_p-0cVCY2Jz.js";import{F as lt}from"./Polygon-D6wEPb3W-D2MPjRU4.js";import{o as ut,m as ht,r as dt}from"./vec2f64-rIxtbMRN-Kai9mK1i.js";import{$ as pe,x as pt,k as X,B as mt,A as me,z as ft,H as vt,I as _t}from"./vec32-CewSdTn3-VRto2OOh.js";import{t as z,X as gt,e as fe}from"./collectionUtils-jDyktm0P-BDP2Oq99.js";import{z as xt}from"./vec42-B8VM4vXb-B6OGOEI9.js";import{K as yt}from"./plane-BNdSPG2o-DTV5z6SO.js";import{q as wt,d as bt,j as Pt}from"./sphere-DLQ6p7mp-DyEe1Vll.js";import{aW as St,aX as ve,V as re,y as Ct,N as U,B as j,E as $,F as W,al as ne,aV as ze,aU as Me,L as qe,t as Ge,ay as oe,bL as Tt,bl as Dt,cF as _e,n as ge,R as At,aN as zt,az as ke,ca as xe}from"./Texture-CFNZjV2R-CxGjQ8pI.js";import{M as Mt}from"./intersectorUtilsConversions-pLQPEbcN-Ck-nyNYa.js";import{n as qt}from"./signal-BX9ezF8a-cf1Pn6io.js";import{f as Gt}from"./WorkerHandle-B930SiRy-DglEKt53.js";import{P as K,E as ye,B as kt,N as Ie,_ as Oe}from"./enums-B4pqBiXb-BO-3hS_8.js";import{v as It}from"./HUDIntersectorResult-1xTExS7z-dL9SFL6u.js";import{H as N}from"./index-B0z_nLWi.js";import{t as Ot}from"./LayerView-BnpxrRF8-Ca-QSx3a.js";import{F as Ft,C as Rt}from"./layerViewUtils-BTa15X3o-BjQlX2q8.js";import{y as Q,A as we,n as y,m as Bt,C as ie}from"./Emissions.glsl-B8XKMjLy-DXfiRNVX.js";import"./Extent-CgDMOSRD-Bod5LY6s.js";import"./Polyline-CoiTLswR-DTxpB2Yg.js";import"./typeUtils-DqrRcjBx-DZ6_Gsbu.js";import"./modeUtils-BA-mAwuS-DSb1K26b.js";import"./intl-DRFqUect-DPhFaHB2.js";import"./date-IqUzANpt-bLKO9IDT.js";import"./sanitizerUtils-BT_8V5US-CWQWUwZQ.js";import"./lengthUtils-Dt1_RvOO-j3MEdmHu.js";import"./workers-BEkgoq8Q-BM_Hz460.js";import"./PooledRBush-Dco5QkUp-DX3CMhf3.js";import"./GraphicsCollection-Bk6M0b7D-Dk6KdmO7.js";import"./Graphic-DgGzDmqW-d1CNicxz.js";import"./getPopupProvider-CmskPttI-CzUWpGwk.js";import"./Color-CERqXxxY-BuYn26eI.js";import"./mathUtils-PIGhLnI9-B1tKUlUb.js";import"./Layer-DZvC7bne-D3VLDrab.js";import"./typeUtils-CXW_VpOn-BGgLp_TK.js";import"./lineMarkers-CDwLe3J6-CNUjJvs3.js";import"./PolygonSymbol3D-BXRHZiCQ-BjPAY2LA.js";import"./ExtrudeSymbol3DLayer-DSc1ou2x-CsVYZCeG.js";import"./aaBoundingBox-Cn49X7ge-BcYPaJ58.js";import"./mat4f64-q_b6UJoq-Dh6sWB_w.js";import"./Font-BwmnW7d2-Dwh3xjKw.js";import"./SimpleFillSymbol-CDawtd9z-CWD2KI2D.js";import"./SimpleMarkerSymbol-BGAFRS9_-CVQ5NLIA.js";import"./PictureMarkerSymbol-CaSh-vZk-xhjZ61bb.js";import"./TextSymbol-hRGhyDHs-CoS7dSjf.js";import"./HeightModelInfo-D5IdRvJ2-23y6MRiu.js";import"./projectionUtils-BGH_5_I3-DGwchVO8.js";import"./spatialReferenceEllipsoidUtils-D2JabnKt-Ce3ED0lc.js";import"./RealisticTree.glsl-WN9nrQUl-QZiY3aPA.js";import"./mat4-C96X-Nn0-BrMLOLCb.js";import"./vec4f64-DPb6J-GU-C7c2DqbZ.js";import"./BufferView-Cj2sQaht-avJ4OGB_.js";import"./InterleavedLayout-B7roQAzV-CdGz7mlm.js";import"./MeshLocalVertexSpace-BGd1IdEs-C0HJG4wR.js";import"./projectVectorToVector-Csv3NYZI-DpBtmQMN.js";import"./vec3f32-WCVSSNPR-9V6Uhrx-.js";import"./Indices-D0_UQPPr-t1Qev6md.js";import"./frustum-CMzahy3--B-DC1Co-.js";import"./vector-B8ZDYGQ6-DRILJdcx.js";import"./TilemapCache-CjhKW_vj-8gKqgQfa.js";import"./LRUCache-fy84PBMi-Y56WPIvD.js";import"./UpdatingHandles-D2RI_3Hb-dwLPjVun.js";import"./asyncUtils-w6KfWU41-HenJ0UOu.js";import"./Map-AEYszeHg-ZEOzAMWa.js";import"./Basemap-CL_uaRmk-O3l-dbYk.js";import"./PortalItem-DnxMlRVo-CI4Ns2_M.js";import"./writeUtils-DEFpwIW1-AHZYPaSV.js";import"./CollectionFlattener-D6h2Fkvj-WVl2BXw-.js";import"./resourceExtension-DOTCeiZj-C2WIbjQM.js";import"./PolygonCollection-HNNpnBH7-5UHgGprq.js";import"./mat4f32-Djp3mnm5-DzYG3LYB.js";import"./Query-BlS0WPDF-jdXS_Qhy.js";import"./Field-Cm_ZejYW-CwJZmSru.js";import"./fieldType-DVUzXtk_-tUuvnZJM.js";import"./normalizeUtils-85zLqeMi-C1bdAKNn.js";import"./normalizeUtilsCommon-CnhQye_A-UWhaH-kt.js";import"./ElevationQuery-DzlYa4L4-DkUTW9Ak.js";import"./TileInfo-Bz7QlefV-CdK7c8ef.js";import"./Scheduler-CNrsbccs-Bcg8fWoS.js";import"./constants-D67WmGms-H7IOwEdB.js";import"./quat-B7J5v7rV-CZ9akUv-.js";import"./floatRGBA-D-Q4FzNN-DQhowfyr.js";import"./UnknownTimeZone-B697BDFv-CBbtul7O.js";import"./TileKey-C44YQC4_-BW7BBbYp.js";import"./vec2f32-CaVKkSa6-BjkBmyoj.js";import"./Octree-DckBBpQ7-CkRPu4UJ.js";import"./axisAngleDegrees-CjbXmycq-DcVVDR1-.js";import"./edgePreprocessing-D_eX-fWy-DqE-06Ss.js";import"./vec3-B_phcnZY-DHC7I6xa.js";import"./vec33-CWJeyzxV-Me4sF5XB.js";import"./reader-DcGs6kKN-DHJfK-tm.js";import"./jsonUtils-CmpazY1u-6pDLj5sx.js";import"./SimpleObservable-CvFyr0NA-DXpoMYph.js";import"./screenUtils-BitdhK1O-L0FLPAMi.js";import"./aaBoundingRect-CjwcS2F3-ri8bmh30.js";import"./projectPointToVector-DL7Z4uvb-CPbOlZdQ.js";import"./scaleUtils-yfx9kKWT-D9SVsyM-.js";import"./layerUtils-DZGhvm-W-CfyHx1TZ.js";import"./tagSymbols-BPcGfZon-BPcGfZon.js";import"./Queue-CYlrXMwB-CYJTUII-.js";import"./timeZoneUtils-BSc7-7qA-BAv3h8mh.js";import"./ReactiveMap-B0by2bYu-DCsCfMj5.js";import"./TablesMixin-Q80MT3nU-CBB9B-b6.js";import"./VertexElementDescriptor-BlxU8vCE-BwuKQkTU.js";import"./Cyclical-BLSxUpe7-Bj8R2Yk-.js";import"./computeTranslationToOriginAndRotation-Bjd4esRf-vJ4LbdOU.js";import"./dehydratedFeatures-Ql-uVzLq-aoK2987s.js";import"./quantizationUtils-Ceq-Uxsu-DjgKK_0s.js";import"./featureConversionUtils-BDA_FXJx-CDxX1Wik.js";import"./OptimizedFeature-CwRGZPwv-Ddclhn0A.js";import"./OptimizedFeatureSet-BR8EEvDc-CgsRgxJh.js";import"./createFeatureId-CVwTD0fV-3fKpJDrk.js";import"./DefaultLoadingContext-DXgBe4GE-Unnb_XgV.js";import"./wosrLoader-CIPfz1Cl-DlmQQkMX.js";import"./Version-BtYZEj58-LyRHDnSJ.js";import"./DoubleArray-DExKNiTh-CvVpHySW.js";import"./config-Dg972SSE-D9DBKeq5.js";import"./GeometryUtils-C354xUs0-BLAznQrw.js";import"./definitions-Dvg4hMIw-CdK2DzFN.js";import"./colorUtils-CeIi7j7j-C2WVx6th.js";import"./capabilities-Bi6C4OG6-CpURufko.js";import"./imageUtils-142g71N8-Wj0XNClb.js";import"./videoUtils-Dwx3AEgj-CduhpDRk.js";import"./uuid-Oe6SV2kF-IYX19xBA.js";import"./quickselect-QQC62dOK-Br2Ahhru.js";import"./meshVertexSpaceUtils-CtG7DPVT-kybwngCt.js";import"./Intersector-DS9YtyQY-DMoYp6i0.js";import"./TileKey-CXWFOqOI-Lra6v-mg.js";import"./loadAll-BCyxerwc-B4Lp8wGC.js";import"./opacityUtils-DuFH0EC9-DWspTgn2.js";import"./persistable-CdoDQOTR-BklJqWTn.js";import"./MD5-MtSiOt06-jWr180Yc.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw-DH8sdIsE.js";import"./utils-CylVuxNi--x86XOjU.js";import"./utils-Dpg4yj1D-CeFz2JVC.js";import"./types-BKo2foNY-DE0QfIFp.js";import"./labelUtils-BtizwBfq-Zegx4520.js";import"./ArcadeExpression-BlIRq-oN-VZkrwLVE.js";import"./TimeOnly-BERR31kg-CQiLyUZi.js";import"./enum-BzLwmiID-CcyIdWlQ.js";import"./FieldsIndex-CimK-TqD--24JoCkp.js";let Ht=class extends tt{constructor(e,t,i,a){super(e,0,0,0,t),this.cachedNodes=i,this.memoryMBCached=a}};const C=4096,Fe=16,F=1023,R=F+1,Et=C*Fe/R,V=4,Re=R*V,be=F*V;let Vt=class{constructor(e=Et){this._pageCount=e;const t=Math.ceil(e/32);this._bitset=new Uint32Array(t)}get pageCount(){return this._pageCount}isAllocated(e){const t=e/32|0,i=e%32;return!!(this._bitset[t]&1<<i)}allocate(e){const t=e/32|0,i=e%32;this._bitset[t]|=1<<i}free(e){const t=e/32|0,i=e%32;this._bitset[t]&=~(1<<i)}findFirstFreePage(){for(let e=0;e<this._bitset.length;e++)if(this._bitset[e]!==4294967295)for(let t=0;t<32;t++){const i=32*e+t;if(i>=this._pageCount)break;if(!(this._bitset[e]&1<<t))return i}return null}resize(e){this._pageCount=e;const t=Math.ceil(e/32),i=this._bitset.length;if(t!==i){const a=new Uint32Array(t),s=Math.min(i,t);a.set(this._bitset.subarray(0,s)),this._bitset=a}this._clearExcessBits(this._bitset,e)}_clearExcessBits(e,t){const i=Math.floor((t-1)/32),a=(t-1)%32;if(t>0&&a<31){const s=(1<<a+1)-1;e[i]&=s}i+1<e.length&&e.fill(0,i+1)}};class Lt{constructor(t,i,a,s,r,d,u){this.handle=t,this.obb=i,this.gaussianAtlasIndices=a,this.pageIds=s,this.positions=r,this.squaredScales=d,this.maxScale=u,this.isVisible=!1,this.usedMemory=ct(this.gaussianAtlasIndices,this.positions,this.squaredScales)+this.pageIds.length*Re*4}}class Ut extends Gt{constructor(t){super("GaussianSplatSortWorker","sort",{sort:i=>[i.distances.buffer,i.sortOrderIndices.buffer]},t,{strategy:"dedicated"})}sort(t,i){return this.invokeMethod("sort",t,i)}async destroyWorkerAndSelf(){await this.broadcast({},"destroy"),this.destroy()}}let jt=class{constructor(e){this.texture=null,this._orderTextureCapacity=0,this._rctx=e}ensureCapacity(e){if(this._orderTextureCapacity<e){this.texture?.dispose();const t=Math.ceil(e*se),i=this._evalTextureSize(t),a=i[0]*i[1];this._orderBuffer=new Uint32Array(a);const s=new qe;s.height=i[0],s.width=i[1],s.pixelFormat=36244,s.dataType=Ie.UNSIGNED_INT,s.internalFormat=Oe.R32UI,s.wrapMode=33071,s.samplingMode=9728,this.texture=new Ge(this._rctx,s),this._orderTextureCapacity=a}}setData(e,t){this.ensureCapacity(t),this._orderBuffer?.set(e),this.texture?.setData(this._orderBuffer)}clear(){this._orderTextureCapacity=0,this.texture?.dispose(),this.texture=null}destroy(){this.texture?.dispose()}_evalTextureSize(e){const t=Math.ceil(Math.sqrt(e)),i=Math.ceil(e/t);return dt(t,i)}},$t=class{constructor(e,t,i){this._splatAtlasTextureHeight=Fe,this.texture=null,this._rctx=e,this._fboCache=i,this.pageAllocator=new Vt,this._cache=t.newCache("gaussian texture cache",a=>a.dispose())}ensureTextureAtlas(){if(this.texture)return;const e=this._cache.pop("splatTextureAtlas");if(e)return void(this.texture=e);const t=new qe;t.height=this._splatAtlasTextureHeight,t.width=C,t.pixelFormat=36249,t.dataType=Ie.UNSIGNED_INT,t.internalFormat=Oe.RGBA32UI,t.samplingMode=9728,t.wrapMode=33071,this.texture=new Ge(this._rctx,t),this._updatePageAllocator()}grow(){if(!this.texture)return this.ensureTextureAtlas(),!1;const e=Math.floor(this._splatAtlasTextureHeight*se);if(e*C>this._rctx.parameters.maxPreferredTexturePixels)return!1;const t=new at(this._rctx,this.texture),i=this._fboCache.acquire(C,e,"gaussian splat atlas resize",11);return this._rctx.blitFramebuffer(t,i.fbo,16384,9728,0,0,C,this._splatAtlasTextureHeight,0,0,C,this._splatAtlasTextureHeight),this.texture?.dispose(),this.texture=i.fbo?.detachColorTexture(),t.dispose(),i.dispose(),this._splatAtlasTextureHeight=e,this._updatePageAllocator(),!0}requestPage(){let e=this.pageAllocator.findFirstFreePage();return e===null&&this.grow()&&(e=this.pageAllocator.findFirstFreePage()),e!==null&&this.pageAllocator.allocate(e),e}freePage(e){this.pageAllocator.free(e)}update(e,t,i){this.ensureTextureAtlas(),this.texture.updateData(0,e,t,R,1,i)}_updatePageAllocator(){const e=C*this._splatAtlasTextureHeight/R;this.pageAllocator.pageCount!==e&&this.pageAllocator.resize(e)}clear(){this.texture&&(this._cache.put("splatTextureAtlas",this.texture),this.texture=null)}destroy(){this._cache.destroy(),this.texture?.dispose()}},Wt=class{constructor(e){this._updating=qt(!1),this.visibleGaussians=0,this._visibleGaussianTiles=new Array,this._workerHandle=null,this._isSorting=!1,this._pendingSortTask=!1,this._bufferCapacity=0,this._renderer=e,this._orderTexture=new jt(this._renderer.renderingContext),this._textureAtlas=new $t(this._renderer.renderingContext,this._renderer.view.resourceController.memoryController,this._renderer.fboCache);const{resourceController:t}=this._renderer.view;this._workerHandle=new Ut(it(t))}get textureAtlas(){return this._textureAtlas}get orderTexture(){return this._orderTexture}get visibleGaussianTiles(){return this._visibleGaussianTiles}updateGaussianVisibility(e){this._visibleGaussianTiles=e,this.requestSort()}isUpdating(){return this._updating.value}destroy(){this._pendingSortTask=!1,this._workerHandle?.destroyWorkerAndSelf(),this._textureAtlas.destroy(),this._orderTexture.destroy()}requestSort(){this._updating.value=!0,this._isSorting?this._pendingSortTask=!0:(this._isSorting=!0,this._pendingSortTask=!1,this._sortOnWorker().then(()=>this._handleSortComplete()).catch(()=>this._handleSortComplete()))}_handleSortComplete(){this._isSorting=!1,this._pendingSortTask?this.requestSort():this._updating.value=!1}_clearBuffersAndTextures(){this._bufferCapacity=0,this._orderTexture.clear(),this._textureAtlas.clear()}_ensureBufferCapacity(e){if(this._bufferCapacity<e){const t=Math.ceil(e*se);this._atlasIndicesBuffer=new Uint32Array(t),this._sortedAtlasIndicesBuffer=new Uint32Array(t),this._distancesBuffer=new Float64Array(t),this._sortOrderBuffer=new Uint32Array(t),this._bufferCapacity=t}}async _sortOnWorker(){let e=0;if(this._visibleGaussianTiles.forEach(n=>e+=n.gaussianAtlasIndices.length),e===0)return this.visibleGaussians=0,this._clearBuffersAndTextures(),void this._renderer.requestRender(1);this._ensureBufferCapacity(e),this._textureAtlas.ensureTextureAtlas();const t=this._renderer.camera.eye,i=t[0],a=t[1],s=t[2],r=this._atlasIndicesBuffer.subarray(0,e);let d=0;this._visibleGaussianTiles.forEach(n=>{const m=n.gaussianAtlasIndices,l=n.positions;for(let o=0;o<m.length;o++){r[d]=m[o];const p=3*o,w=l[p],g=l[p+1],c=l[p+2],h=w-i,v=g-a,_=c-s;this._distancesBuffer[d]=h*h+v*v+_*_,d++}});for(let n=0;n<e;n++)this._sortOrderBuffer[n]=n;const u={distances:this._distancesBuffer,sortOrderIndices:this._sortOrderBuffer,numGaussians:e,preciseSort:!1};await this._workerHandle?.sort(u).then(n=>{this._distancesBuffer=n.distances,this._sortOrderBuffer=n.sortedOrderIndices;const m=this._sortedAtlasIndicesBuffer.subarray(0,e);for(let o=0;o<e;o++)m[o]=r[n.sortedOrderIndices[o]];this._orderTexture.setData(m,e);const l=this._renderer.view.qualitySettings.gaussianSplat.maxAllowedVisibleGaussians;this.visibleGaussians=Math.min(e,l),this._renderer.requestRender(1)})}};function Nt(e){e.code.add(y`void computeCovariance3D(in mat3 rotation, in vec3 scale, out vec3 covarianceA, out vec3 covarianceB) {
mat3 scaleMatrix = mat3(
vec3(scale.x, 0.0, 0.0),
vec3(0.0, scale.y, 0.0),
vec3(0.0, 0.0, scale.z)
);
mat3 M = scaleMatrix * rotation;
mat3 covariance3D = transpose(M) * M;
covarianceA = vec3(covariance3D[0][0], covariance3D[0][1], covariance3D[0][2]);
covarianceB = vec3(covariance3D[1][1], covariance3D[1][2], covariance3D[2][2]);
}
vec3 computeCovariance2D(vec3 center, float focalLength, vec2 tanFov, float[6] cov3D, mat4 view) {
vec4 viewSpacePoint = vec4(center, 1);
vec2 max = 1.3 * tanFov;
vec2 normalized = viewSpacePoint.xy / viewSpacePoint.z;
viewSpacePoint.xy = clamp(normalized, -max, max) * viewSpacePoint.z;
float invZ = 1.0 / viewSpacePoint.z;
float invZSquared = invZ * invZ;
mat3 projectionJacobian = mat3(
focalLength * invZ,  0.0,                   -(focalLength * viewSpacePoint.x) * invZSquared,
0.0,                 focalLength * invZ,    -(focalLength * viewSpacePoint.y) * invZSquared,
0.0,                 0.0,                   0.0
);
mat3 worldToView = transpose(mat3(view));
mat3 T = worldToView * projectionJacobian;
mat3 covariance3D = mat3(
cov3D[0], cov3D[1], cov3D[2],
cov3D[1], cov3D[3], cov3D[4],
cov3D[2], cov3D[4], cov3D[5]
);
mat3 covariance2D = transpose(T) * transpose(covariance3D) * T;
const float regularization = 0.3;
covariance2D[0][0] += regularization;
covariance2D[1][1] += regularization;
return vec3(covariance2D[0][0], covariance2D[0][1], covariance2D[1][1]);
}`)}function Zt(e){e.code.add(y`vec4 unpackColor(uvec4 packedGaussian) {
vec4 color;
color.r = float((packedGaussian.w >> 1u) & 0xfeu);
color.g = float((packedGaussian.w >> 9u) & 0xffu);
color.b = float((packedGaussian.w >> 16u) & 0xfeu);
color.a = float((packedGaussian.w >> 24u) & 0xffu);
return color / 255.0;
}`),e.code.add(y`vec3 unpackScale(uvec4 packedGaussian) {
uint sx = (packedGaussian.z >> 10u) & 0xffu;
uint sy = (packedGaussian.z >> 18u) & 0xffu;
uint szLow = (packedGaussian.z >> 26u) & 0x3fu;
uint szHigh = packedGaussian.a & 0x3u;
uint sz = szLow | (szHigh << 6u);
return exp(vec3(sx, sy, sz) / 16.0 - 10.0);
}`),e.code.add(y`const uint MASK_9_BITS = 0x1FFu;
const float SQRT_HALF = 0.7071067811865476;
const ivec3 COMPONENT_ORDER[4] = ivec3[4](
ivec3(3, 2, 1),
ivec3(3, 2, 0),
ivec3(3, 1, 0),
ivec3(2, 1, 0)
);
vec4 unpackQuaternion(uvec4 packedGaussian) {
uint packedRotation = packedGaussian.x;
uint largestComponent = packedRotation >> 30u;
vec4 quaternion = vec4(0.0);
float sumSquares = 0.0;
uint bitfield = packedRotation;
for (int j = 0; j < 3; ++j) {
int index = COMPONENT_ORDER[int(largestComponent)][j];
uint magnitude = bitfield & MASK_9_BITS;
uint signBit = (bitfield >> 9u) & 1u;
bitfield = bitfield >> 10u;
float value = SQRT_HALF * float(magnitude) / float(MASK_9_BITS);
quaternion[index] = signBit == 1u ? -value : value;
sumSquares += value * value;
}
quaternion[int(largestComponent)] = sqrt(1.0 - sumSquares);
return quaternion;
}`),e.code.add(y`vec3 unpackTileOriginRelativePosition(uvec4 packedGaussian) {
uint packedPositionLow = packedGaussian.y;
uint packedPositionHigh = packedGaussian.z;
uint x = packedPositionLow & 0x3FFFu;
uint y = (packedPositionLow >> 14u) & 0x3FFFu;
uint zLow = (packedPositionLow >> 28u) & 0xFu;
uint zHigh = packedPositionHigh & 0x3FFu;
uint z = zLow | (zHigh << 4u);
return vec3(float(x), float(y), float(z));
}`),e.code.add(y`vec3 unpackCameraRelativeGaussianPosition(uvec4 packedHeader, highp vec3 position, vec3 cameraPosition, vec3 cameraPos8k, vec3 cameraDelta) {
vec3 tileOrigin = uintBitsToFloat(packedHeader.xyz);
float invPosScale = 1.0 / exp2(float(packedHeader.w & 0xffu));
vec3 delta = tileOrigin.xyz - cameraPos8k;
vec3 cameraRelativePosition = position.xyz * invPosScale + delta * 2.048 - cameraDelta;
return cameraRelativePosition;
}`)}function Yt(e){e.code.add(y`mat3 quaternionToRotationMatrix(vec4 q) {
float x2 = q.x + q.x;
float y2 = q.y + q.y;
float z2 = q.z + q.z;
float xx = x2 * q.x;
float yy = y2 * q.y;
float zz = z2 * q.z;
float xy = x2 * q.y;
float xz = x2 * q.z;
float yz = y2 * q.z;
float wx = x2 * q.w;
float wy = y2 * q.w;
float wz = z2 * q.w;
return mat3(
1.0 - (yy + zz), xy - wz, xz + wy,
xy + wz, 1.0 - (xx + zz), yz - wx,
xz - wy, yz + wx, 1.0 - (xx + yy)
);
}`)}class ce extends re{constructor(){super(...arguments),this.totalGaussians=-1,this.focalLength=-1,this.minSplatRadius=-1,this.minSplatOpacity=-1,this.tanFov=ht,this.cameraDelta=fe,this.cameraPos8k=fe}}function Be(e){const t=new oe;t.varyings.add("vColor","vec4"),t.varyings.add("conicOpacity","vec4"),t.varyings.add("depth","float"),t.varyings.add("gaussianCenterScreenPos","vec2"),t.varyings.add("fragScreenPos","vec2"),t.outputs.add("fragColor","vec4",0),t.vertex.uniforms.add(new he("splatOrderTexture",a=>a.splatOrder),new he("splatAtlasTexture",a=>a.splatAtlas),new Tt("numSplats",a=>a.totalGaussians),new Q("focalLength",a=>a.focalLength),new Q("minSplatRadius",a=>a.minSplatRadius),new Q("minSplatOpacity",a=>a.minSplatOpacity),new Dt("tanFov",a=>a.tanFov),new we("cameraDelta",a=>a.cameraDelta),new we("cameraPos8k",a=>a.cameraPos8k),new _e("fullWidth",({camera:a})=>a.viewport[2]),new _e("fullHeight",({camera:a})=>a.viewport[3]),new ge("proj",a=>a.camera.projectionMatrix),new ge("view",a=>a.camera.viewMatrix),new At("cameraPosition",a=>a.camera.eye)),t.vertex.include(Zt),t.vertex.include(Yt),t.vertex.include(Nt),t.include(zt,e),t.vertex.code.add(y`float ndcToPixel(float ndcCoord, float screenSize) {
return ((ndcCoord + 1.0) * screenSize - 1.0) * 0.5;
}`),t.vertex.main.add(`
    uint instanceID = uint(gl_InstanceID);

    // Transform the instanceID into 2D coordinates
    uint orderTextureWidth = uint(textureSize(splatOrderTexture, 0).x);
    uint x = instanceID % orderTextureWidth;
    uint y = instanceID / orderTextureWidth;

    // Fetch the index of the remaining frontmost Gaussian
    uint gaussianIndex = texelFetch(splatOrderTexture, ivec2(x, y), 0).r;

    uint splatAtlasSize = uint(textureSize(splatAtlasTexture, 0).x);

    // Fetch the packed Gaussian according to the index
    uint gaussianIndexX = gaussianIndex % uint(splatAtlasSize);
    uint gaussianIndexY = gaussianIndex / uint(splatAtlasSize);
    uvec4 packedGaussian = texelFetch(splatAtlasTexture, ivec2(gaussianIndexX, gaussianIndexY), 0);

    // Fetch the header associated with the packed Gaussian (contains tile origin and number of fractional bits)
    uint pageNum = gaussianIndex / 1024u;
    uint headerIndex = (pageNum + 1u) * 1024u - 1u;
    uint headerIndexX = headerIndex % uint(splatAtlasSize);
    uint headerIndexY = headerIndex / uint(splatAtlasSize);
    uvec4 packedHeader = texelFetch(splatAtlasTexture, ivec2(headerIndexX, headerIndexY), 0);

    // Unpack the Gaussian
    vColor = unpackColor(packedGaussian);
    // Ignore gaussians with very small contribution, with tolerance based on the quality profile
    if(vColor.a < minSplatOpacity) {
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec3 scale = unpackScale(packedGaussian); 
    vec4 quaternion = unpackQuaternion(packedGaussian);
    mat3 rotation = quaternionToRotationMatrix(quaternion);
    vec3 tileOriginRelativePosition = unpackTileOriginRelativePosition(packedGaussian);

    vec3 cameraRelativePosition = unpackCameraRelativeGaussianPosition(packedHeader, tileOriginRelativePosition, cameraPosition, cameraPos8k, cameraDelta);

    vec4 viewPos = vec4(mat3(view) * cameraRelativePosition, 1);

    if (viewPos.z > 1.0) {
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    forwardViewPosDepth(viewPos.xyz);

    vec3 covarianceA;
    vec3 covarianceB;
    computeCovariance3D(rotation, scale.xyz, covarianceA, covarianceB);

    float covariance3D[6] = float[6](covarianceA.x, covarianceA.y, covarianceA.z, covarianceB.x, covarianceB.y, covarianceB.z);

    vec3 covariance2D = computeCovariance2D(viewPos.xyz, focalLength, tanFov, covariance3D, view);
    
    // Invert covariance (EWA algorithm)
    float determinant = (covariance2D.x * covariance2D.z - covariance2D.y * covariance2D.y);
    if (determinant == 0.) {
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }
    float invDeterminant = 1. / determinant;
    

    vec4 projPos = proj * viewPos;
    float invW = 1. / (projPos.w + 1e-7);
    vec3 ndcPos = projPos.xyz * invW;

    // Compute extent in screen space (by finding the eigenvalues of the 2D covariance matrix). 
    // Use the extent to compute the bounding rectangle of the Gaussian in screen space.
    float mid = 0.5 * (covariance2D.x + covariance2D.z);
    float lambda1 = mid + sqrt(max(0.1, mid * mid - determinant));
    float lambda2 = mid - sqrt(max(0.1, mid * mid - determinant));
    float radius = ceil(3. * sqrt(max(lambda1, lambda2)));
    gaussianCenterScreenPos = vec2(ndcToPixel(ndcPos.x, float(fullWidth)), ndcToPixel(ndcPos.y, float(fullHeight)));

    // Ignore gaussians with very small contribution, with tolerance based on the quality profile
    if(minSplatRadius > 0.0) {
      float effectiveSize = radius * vColor.a;
      if(effectiveSize < minSplatRadius) {
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
    }

    // This maps vertex IDs 0, 1, 2, 3 to (-1,-1), (1,-1), (-1,1), (1,1)
    vec2 corner = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2) - 1.0;

    // Vertex (corner) position in screen space
    fragScreenPos = gaussianCenterScreenPos + radius * corner;

    // We use a conic function to derive the opacity
    vec3 conic = vec3(covariance2D.z, -covariance2D.y, covariance2D.x) * invDeterminant;
    conicOpacity = vec4(conic, vColor.a);

    depth = ndcPos.z;
    
    // Convert from screen-space to clip-space
    vec2 clipPos = fragScreenPos / vec2(fullWidth, fullHeight) * 2. - 1.;

    gl_Position = vec4(clipPos, depth, 1.0);

  `);const i=e.depthPass;return t.fragment.main.add(`
    discardByTerrainDepth();
    vec2 offsetFromCenter = gaussianCenterScreenPos - fragScreenPos;

    // Evaluate the 2D elliptical Gaussian exponent using the general conic form: Ax^2+2Bxy+Cy^2
    float x = offsetFromCenter.x;
    float y = offsetFromCenter.y;
    float A = conicOpacity.x;
    float B = conicOpacity.y;
    float C = conicOpacity.z;
    float opacityScale = conicOpacity.w;
    float gaussianExponent = -0.5 * (A * x * x + 2.0 * B * x * y + C * y * y);

    // A positive exponent indicates alpha > 1, this should not happen
    if (gaussianExponent > 0.0) {
      discard;
    }

    float gaussianFalloff = exp(gaussianExponent);
    
      // cap at 0.99 to avoid blending issues, such as seams between overlapping Gaussians
    float alpha = min(.99f, opacityScale * gaussianFalloff);

    // discard low alpha fragments since their contribution would not be visible
    if (alpha < 1./255.) {
        discard;
    }

    // We cannot write color and depth in the same pass, as they require different blend modes.
    // Regular depth writing based on first hit is not precise enough due to the inherently 
    // transparent nature of Gaussian Splats (especially at the borders of the Splat).
    // We thus use a blended depth that computes a non-linear average using 
    // the splat order and opacity with geometric decay.
    // This means the depth is averaged based on the order and opacity of the Gaussians,
    // with the frontmost Gaussians contributing the most.
    ${Bt(i,"fragColor = vec4(depth, 0, 0, alpha);","fragColor = vec4(vColor.rgb * alpha, alpha);")}
  `),t}const He=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatPassParameters:ce,build:Be},Symbol.toStringTag,{value:"Module"}));let le=class extends re{};function Ee(){const e=new oe;return e.include(ke),e.fragment.uniforms.add(new ie("colorTexture",t=>t.color),new ie("splatOutputColor",t=>t.splatColor)),e.fragment.main.add(y`vec4 color = texture(colorTexture, uv);
vec4 splatColor = texture(splatOutputColor, uv);
fragColor = splatColor + color * (1.0 - splatColor.a);`),e}const Xt=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatCompositionPassParameters:le,build:Ee},Symbol.toStringTag,{value:"Module"}));let Pe=class extends U{constructor(e,t){super(e,t,new j(Xt,()=>N(()=>Promise.resolve().then(()=>Qt),void 0)),$)}initializePipeline(){return W({colorWrite:ne,depthTest:null,depthWrite:Me})}},ue=class extends re{};function Ve(){const e=new oe;return e.include(ke),e.fragment.uniforms.add(new ie("splatOutputDepth",t=>t.splatDepth)),e.fragment.main.add(y`vec4 splatDepth = texture(splatOutputDepth, uv);
float ndcDepth = splatDepth.x;
float depthCutOff = 0.75;
if(splatDepth.a < depthCutOff) {
discard;
}
gl_FragDepth = (ndcDepth + 1.0) * 0.5;`),e}const Kt=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatDepthCompositionPassParameters:ue,build:Ve},Symbol.toStringTag,{value:"Module"}));let Se=class extends U{constructor(e,t){super(e,t,new j(Kt,()=>N(()=>Promise.resolve().then(()=>Jt),void 0)),$)}initializePipeline(){return W({colorWrite:null,depthTest:{func:515},depthWrite:Me,drawBuffers:{buffers:[kt]}})}},Ce=class extends U{constructor(e,t){super(e,t,new j(He,()=>N(()=>Promise.resolve().then(()=>Le),void 0)),$)}_createPipeline(){return W({blending:ze(773,773,772,1,32774,32774),depthTest:{func:513},colorWrite:ne})}initializePipeline(){return this._createPipeline()}};class Te extends U{constructor(t,i){super(t,i,new j(He,()=>N(()=>Promise.resolve().then(()=>Le),void 0)),$)}_createPipeline(){return W({blending:ze(773,773,1,1,32774,32774),depthTest:{func:515},colorWrite:ne})}initializePipeline(){return this._createPipeline()}}class L extends Ct{constructor(t=!1){super(),this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.depthPass=t}}q([xe()],L.prototype,"terrainDepthTest",void 0),q([xe()],L.prototype,"cullAboveTerrain",void 0);var E;let ae=class extends St{constructor(){super(...arguments),this.gaussianPosition=z(),this.intersectionRayDir=z(),this.intersectionPlane=yt(),this._slicePlaneEnabled=!1,this._data=null,this.produces=ve.OPAQUE,this.type=0,this.isGround=!1,this.layerViewUid="",this._gaussianSplatParameters=new ce,this._gaussianSplatCompositionParameters=new le,this._gaussianSplatDepthCompositionParameters=new ue,this._splatTechniqueConfiguration=new L,this._splatDepthTechniqueConfiguration=new L(!0),this._previousCameraPosition=z(),this._previousCameraDirection=z(),this._tanFov=ut(),this._tempVec=z(),this._cameraDelta=z(),this._coarseCameraPosition=z()}static{E=this}async initialize(){this._data=new Wt(this),this.view.sceneIntersectionHelper.addIntersectionHandler(this),this.addHandles([te(()=>this.view.state.camera,()=>this._onCameraChange())])}precompile(){this._splatTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(Te,this._splatTechniqueConfiguration),this._splatDepthTechniqueConfiguration.terrainDepthTest=this.bindParameters.terrainDepthTest,this.techniques.precompile(Ce,this._splatDepthTechniqueConfiguration),this.techniques.precompile(Pe),this.techniques.precompile(Se)}render(e){const t=e.find(({name:_})=>_===ve.OPAQUE);if(!this._data.visibleGaussians||!this._data.orderTexture.texture||!this._data.textureAtlas.texture)return t;const i=this.techniques.get(Te,this._splatTechniqueConfiguration),a=this.techniques.get(Ce,this._splatDepthTechniqueConfiguration),s=this.techniques.get(Pe),r=this.techniques.get(Se);if(!(i.compiled&&a.compiled&&r.compiled&&s.compiled))return this.requestRender(1),t;const{fullWidth:d,fullHeight:u}=this.bindParameters.camera,n=this.fboCache,m=n.acquire(d,u,"gaussian color output");m.attachDepth(t.getAttachment(K));const l=this.renderingContext;l.bindFramebuffer(m.fbo),l.setClearColor(0,0,0,0),l.clear(16384),this._gaussianSplatParameters.totalGaussians=this._data.visibleGaussians,this._gaussianSplatParameters.splatOrder=this._data.orderTexture.texture,this._gaussianSplatParameters.splatAtlas=this._data.textureAtlas.texture;const o=Math.tan(.5*this.camera.fovY),p=o/u*d;lt(this._tanFov,p,o);const w=u/(2*o);this._gaussianSplatParameters.focalLength=w,this._gaussianSplatParameters.tanFov=this._tanFov;const g=this.view.qualitySettings.gaussianSplat,c=g.minimumSplatPixelRadius*Math.sqrt(d*u)/Math.sqrt(2073600);this._gaussianSplatParameters.minSplatRadius=c,this._gaussianSplatParameters.minSplatOpacity=g.minimumOpacity,this._prepareHighPrecisionCameraPosition(),this.renderingContext.bindTechnique(i,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(ye.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const h=n.acquire(d,u,"splat depth",8);h.attachDepth(t.getAttachment(K)),l.bindFramebuffer(h.fbo),l.setClearColor(0,0,0,0),l.clear(16384),this.renderingContext.bindTechnique(a,this.bindParameters,this._gaussianSplatParameters),this.renderingContext.drawArraysInstanced(ye.TRIANGLE_STRIP,0,4,this._data.visibleGaussians);const v=n.acquire(d,u,this.produces);return this._gaussianSplatDepthCompositionParameters.splatDepth=h.getTexture(),v.attachDepth(t.getAttachment(K)),l.bindFramebuffer(v.fbo),l.bindTechnique(r,this.bindParameters,this._gaussianSplatDepthCompositionParameters),l.screen.draw(),this._gaussianSplatCompositionParameters.color=t.getTexture(),this._gaussianSplatCompositionParameters.splatColor=m.getTexture(),l.bindFramebuffer(v.fbo),l.bindTechnique(s,this.bindParameters,this._gaussianSplatCompositionParameters),l.screen.draw(),m.release(),h.release(),v}intersect(e,t,i,a){const{gaussianPosition:s,intersectionRayDir:r,intersectionPlane:d,layerViewUid:u}=this,n=wt(i,a);pe(r,a,i);const m=1/pt(r);X(r,r,m);const l=z();mt(l,r),xt(d,r[0],r[1],r[2],-me(r,i));const o=new J,p=new J,w=new Array;this._data.visibleGaussianTiles.forEach(c=>{const{maxScale:h}=c,v=c.obb.minimumDistancePlane(d),_=c.obb.maximumDistancePlane(d),G=_<0,B=o.dist!=null&&p.dist!=null&&o.dist<v*m&&p.dist>_*m;if(G||B)return;const k=bt(c.obb.center,c.obb.radius+h);if(!Pt(k,n,null)||!c.obb.intersectRay(i,r,h))return;const{positions:b,squaredScales:f,gaussianAtlasIndices:x}=c,H=x.length;for(let P=0;P<H;P++){const M=3*P;s[0]=b[M]-i[0],s[1]=b[M+1]-i[1],s[2]=b[M+2]-i[2];const T=f[P],I=me(s,r),Z=I*I;if(ft(s)-Z>T)continue;const D=I*m,A=S=>(S.point=S.point?S.point.fill(s[0],s[1],s[2]):gt(s),S.dist=D,S.normal=l,S.layerViewUid=u,S);if((o.dist==null||D<o.dist)&&(t==null||t(i,a,D))&&A(o),e.options.store!==0&&(p.dist==null||D>p.dist)&&(t==null||t(i,a,D))&&A(p),e.options.store===2&&(t==null||t(i,a,D))){const S=new J;w.push(A(S))}}});const g=(c,h)=>{const{layerViewUid:v}=h,_=new Mt(h.point,v);c.set(0,_,h.dist,h.normal)};if(De(o)){const c=e.results.min;(c.distance==null||o.dist<c.distance)&&g(c,o)}if(De(p)&&e.options.store!==0){const c=e.results.max;(c.distance==null||p.dist>c.distance)&&g(c,p)}if(e.options.store===2)for(const c of w){const h=new It(n);g(h,c),e.results.all.push(h)}}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this.requestRender(1))}get data(){return this._data}destroy(){this._data.destroy(),super.destroy()}_onCameraChange(){const e=this.view.state.camera.eye,t=this.view.state.camera.ray.direction,i=.001;(Math.abs(e[0]-this._previousCameraPosition[0])>i||Math.abs(e[1]-this._previousCameraPosition[1])>i||Math.abs(e[2]-this._previousCameraPosition[2])>i||Math.abs(t[0]-this._previousCameraDirection[0])>i||Math.abs(t[1]-this._previousCameraDirection[1])>i||Math.abs(t[2]-this._previousCameraDirection[2])>i)&&this._data.requestSort()}_prepareHighPrecisionCameraPosition(){X(this._tempVec,this.camera.eye,1/E.tileSize),vt(this._tempVec,this._tempVec),_t(this._coarseCameraPosition,this._tempVec),this._gaussianSplatParameters.cameraPos8k=this._coarseCameraPosition,X(this._tempVec,this._tempVec,E.tileSize),pe(this._cameraDelta,this.camera.eye,this._tempVec),this._gaussianSplatParameters.cameraDelta=this._cameraDelta}static{this.tileSize=2.048}};function De(e){return e.dist!=null&&e.point!=null}ae=E=q([Ae("esri.views.3d.webgl-engine.lib.GaussianSplatRenderNode")],ae);class J{constructor(){this.point=null,this.dist=null,this.normal=null,this.layerViewUid=""}}const ee=()=>Ue.getLogger("esri.views.3d.layers.GaussianSPlatLayerView3D");let O=class extends ot(Ot){constructor(e){super(e),this.type="gaussian-splat-3d",this._gaussianTileHandles=new Map,this._pageBuffer=new Uint32Array(Re),this._wasmLayerId=-1,this._metersPerVCSUnit=1,this.ignoresMemoryFactor=!1,this._usedMemory=0,this._cacheMemory=0,this._useEsriCrs=!1,this.fullExtentInLocalViewSpatialReference=null,this._suspendedHandle=null,this._conversionBuffer=new ArrayBuffer(4),this._u32View=new Uint32Array(this._conversionBuffer),this._f32View=new Float32Array(this._conversionBuffer);const{view:t}=e;this._memCache=t.resourceController.memoryController.newCache(`GaussianSplat-${this.uid}`,i=>this._deleteTile(i)),this._renderNode=new ae({view:t})}initialize(){if(!this._canProjectWithoutEngine())throw Ft("layer",this.layer.spatialReference.wkid,this.view.renderSpatialReference?.wkid);const e=Ke(this).then(t=>{this._wasmLayerId=t,this.addHandles([te(()=>this.layer.elevationInfo,i=>this._elevationInfoChanged(i))]),this._suspendedHandle=te(()=>this.suspended,i=>this._wasm?.setEnabled(this,!i),$e)});this.addResolvingPromise(e)}get wasmLayerId(){return this._wasmLayerId}get metersPerVCSUnit(){return this._metersPerVCSUnit}isUpdating(){const e=this._wasm;return!(this._wasmLayerId<0||e==null)&&(e.isUpdating(this._wasmLayerId)||this._renderNode.data.isUpdating())}updatingFlagChanged(){this.notifyChange("updating")}get _wasm(){return Qe(this.view)}get usedMemory(){return this._usedMemory}get unloadedMemory(){return 0}get cachedMemory(){return this._cacheMemory}get useEsriCrs(){return this._useEsriCrs}async createRenderable(e){const t=e.meshData;if(t.data==null)throw new Error("meshData.data undefined");if(t.desc=JSON.parse(t.desc),t.desc==null)throw new Error("meshData.desc undefined");const i=t.desc.prims[0],a=i.vertexCount,s=i.atrbs[0].view,r=i.atrbs[0].view.byteCount,d=i.atrbs[0].view.byteOffset;let u=null;if(s.type!=="U32")return ee().warnOnce("unexpected meshData.data format"),{memUsageBytes:0};u=new Uint32Array(t.data.buffer,d,r/4);const n=this.extractHeader(u),m=Math.ceil(a/F),l=new Uint32Array(a),o=[];for(let f=0;f<m;f++){let x=this._data.textureAtlas.requestPage();if(x===null&&(this._freeInvisibleTiles(),x=this._data.textureAtlas.requestPage()),x===null)return ee().warnOnce("ran out of gaussian splat memory"),{memUsageBytes:0};{o.push(x);const H=a-f*F,P=Math.min(H,F),M=f*F;for(let A=0;A<P;A++)l[A+M]=A+R*x;const T=f*be;this._pageBuffer.set(u.subarray(T,T+P*V)),this._pageBuffer.set(n.packedHeader,be);const I=x*R,Z=I%C,D=Math.floor(I/C);this._data.textureAtlas.update(Z,D,this._pageBuffer)}}const p=new Float64Array(3*a),w=new Float64Array(a),g=2.048,c=n.tileOrigin.x*g,h=n.tileOrigin.y*g,v=n.tileOrigin.z*g,_=n.invPosScale;let G=0,B=0;for(let f=0;f<a;f++){const x=f*V,{rawX:H,rawY:P,rawZ:M}=this._extractGaussianPosition(u,x),T=this._extractGaussianSphericalScale(u,x);p[G]=H*_+c,p[G+1]=P*_+h,p[G+2]=M*_+v,w[f]=T*T,B=Math.max(B,T),G+=3}let k=null;if(t.desc.obb){const f=t.desc.obb.quaternion;k=new de(t.desc.obb.center,t.desc.obb.halfSize,Xe(...f))}k||(ee().warnOnce("encountered tile without a bounding box"),k=new de);const b=new Lt(e.handle,k,l,o,p,w,B);return this._memCache.put(`${b.handle}`,b),this._gaussianTileHandles.set(e.handle,b),this._cacheMemory+=b.usedMemory,{memUsageBytes:b.usedMemory}}_extractGaussianPosition(e,t){const i=e[t+1];return{rawX:16383&i,rawY:i>>>14&16383,rawZ:i>>>28&15|(1023&e[t+2])<<4}}_extractGaussianSphericalScale(e,t){const i=e[t+2],a=i>>>10&255,s=i>>>18&255,r=i>>>26&63|(3&e[t+3])<<6,d=Math.exp(a/16-10),u=Math.exp(s/16-10),n=Math.exp(r/16-10);return Math.max(d,u,n)}freeRenderable(e){const t=this._gaussianTileHandles.get(e);t&&(t.isVisible?this._usedMemory-=t.usedMemory:this._cacheMemory-=t.usedMemory,t.pageIds.forEach(i=>this._data.textureAtlas.freePage(i)),this.freeObject(t),this._gaussianTileHandles.delete(e)),this._updateGaussians()}freeObject(e){this._memCache.pop(`${e.handle}`)}get visibleAtCurrentScale(){return Rt(this.layer.effectiveScaleRange,this.view.scale)}setRenderableVisibility(e,t,i){for(let a=0;a<i;a++){if(!t[a])continue;const s=e[a],r=this._gaussianTileHandles.get(s);if(r){if(r.isVisible)continue;r.isVisible=!0,this._usedMemory+=r.usedMemory,this._cacheMemory-=r.usedMemory,this._memCache.pop(`${s}`)}}for(let a=0;a<i;a++){if(t[a])continue;const s=e[a],r=this._gaussianTileHandles.get(s);if(r){if(!r.isVisible)continue;r.isVisible=!1,this._usedMemory-=r.usedMemory,this._cacheMemory+=r.usedMemory,this._memCache.put(`${s}`,r)}}this._updateGaussians()}destroy(){Je(this),this._suspendedHandle&&(this._suspendedHandle=je(this._suspendedHandle)),this._renderNode.destroy(),this._memCache.destroy()}_canProjectWithoutEngine(){if(this.view.state.viewingMode===1||We(this.view.renderSpatialReference)||Ne(this.view.renderSpatialReference))return!0;if(this.layer.esriCrsSpatialReference&&Ze(this.layer.esriCrsSpatialReference,this.view.renderSpatialReference)){const e=st(this.layer.esriCrsSpatialReference),t=this.view.heightModelInfo;return this._useEsriCrs=et(e,t,!1)===0,this._useEsriCrs&&e&&(this._metersPerVCSUnit=Ye(1,"meters",e.heightUnit),this.fullExtentInLocalViewSpatialReference=this.layer.esriCrsFullExtent),this._useEsriCrs}return!1}_elevationInfoChanged(e){if(e?.offset)if(this._useEsriCrs){const t=nt(e?.unit)/this._metersPerVCSUnit,i=e?.offset??0;this._wasm?.setLayerOffset(this,i*t)}else this._wasm?.setLayerOffset(this,rt(e));else this._wasm?.setLayerOffset(this,0)}_updateGaussians(){const e=new Array;for(const t of this._gaussianTileHandles.values())t.isVisible&&e.push(t);this._data.updateGaussianVisibility(e),this.notifyChange("updating")}_freeInvisibleTiles(){for(const e of this._gaussianTileHandles.values())e.isVisible||this._deleteTile(e)}get _data(){return this._renderNode.data}extractHeader(e){const t=e.length-4,i=this.reinterpretU32AsFloat(e[t]),a=this.reinterpretU32AsFloat(e[t+1]),s=this.reinterpretU32AsFloat(e[t+2]),r=1/(1<<(255&e[t+3]));return{packedHeader:e.subarray(t,t+4),tileOrigin:{x:i,y:a,z:s},invPosScale:r}}_deleteTile(e){this._wasm?.onRenderableEvicted(this,e.handle,e.usedMemory),this.freeRenderable(e.handle)}reinterpretU32AsFloat(e){return this._u32View[0]=e,this._f32View[0]}get performanceInfo(){let e=0,t=0;return this._gaussianTileHandles.forEach(i=>{i.isVisible?e++:t++}),new Ht(this.usedMemory,e,t,this.cachedMemory)}};q([Y()],O.prototype,"layer",void 0),q([Y()],O.prototype,"fullExtentInLocalViewSpatialReference",void 0),q([Y({readOnly:!0})],O.prototype,"visibleAtCurrentScale",null),O=q([Ae("esri.views.3d.layers.GaussianSplatLayerView3D")],O);const Us=O,Qt=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatCompositionPassParameters:le,build:Ee},Symbol.toStringTag,{value:"Module"})),Jt=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatDepthCompositionPassParameters:ue,build:Ve},Symbol.toStringTag,{value:"Module"})),Le=Object.freeze(Object.defineProperty({__proto__:null,GaussianSplatPassParameters:ce,build:Be},Symbol.toStringTag,{value:"Module"}));export{Us as default};
