import{n as ye,ba as De,f as Re,g as Ce,k as Q,d as Ie,bb as Z,G as ee,s as Ee,ad as Ue,u as te,_ as V,m as O,a as Le}from"./jsonMap-Bs3hmeCU.js";import{j as ze,l as ke,w as Ae}from"./reactiveUtils-SO2Ko3sy.js";import{t as Ve}from"./LRUCache-fy84PBMi.js";import{b7 as $e,b8 as Fe,a_ as Oe,b9 as Ne,ba as He,bb as Be,bc as We}from"./ShadowCastClear.glsl-Dm_ZNusR.js";import{i as qe}from"./aaBoundingRect-WcI4brw6.js";import{o as ie}from"./constants-D67WmGms.js";import{H as Ge,ai as ae}from"./Point-CMHR1y9V.js";import{p as Ke}from"./workers-eNnOSbW_.js";import{t as k}from"./Rect-BAnET0xx.js";import{r as xe,A as we,x as Ye}from"./Texture-BuZokc5o.js";import{n as je}from"./pbf-2SIhMekG.js";import{u as Xe}from"./rasterizingUtils-CO7vTkyg.js";import{e as q}from"./TileKey-C44YQC4_.js";import{z as Ze}from"./TileInfo-BbMV8v9T.js";import{h as Je}from"./floatRGBA-1BW7WSIR.js";import{i as ne}from"./mathUtils-PIGhLnI9.js";import{Y as L,$ as Se,Z as re}from"./definitions-Dvg4hMIw.js";import{_ as A,R as F}from"./enums-B4pqBiXb.js";import{n as Qe,r as et}from"./vec2f32-CaVKkSa6.js";import{e as oe}from"./config-Dg972SSE.js";import{l as se}from"./StyleRepository-i7Gd7XVP.js";import{l as tt}from"./LayerView3D-BWauqewo.js";import{p as it}from"./TiledLayerView3D-DeURnOHY.js";import{d as at}from"./LayerView-BF3KIQc0.js";import"./index-BiLqt4Ue.js";import"./jsonUtils-BIx2Bg38.js";import"./Extent-BVvEPGp_.js";import"./Polyline-CYNn9agI.js";import"./Polygon-WlfMxvm8.js";import"./typeUtils-Dr-CEt7y.js";import"./collectionUtils-Cc1OWTqq.js";import"./reader-DcGs6kKN.js";import"./SimpleObservable-CvFyr0NA.js";import"./modeUtils-RVJH-Hyp.js";import"./intl-C3uMq9s5.js";import"./date-IqUzANpt.js";import"./uuid-Oe6SV2kF.js";import"./sanitizerUtils-BT_8V5US.js";import"./screenUtils-BitdhK1O.js";import"./lengthUtils-1lu2BknD.js";import"./PooledRBush-Dco5QkUp.js";import"./quickselect-QQC62dOK.js";import"./GraphicsCollection-FgG4i9u5.js";import"./Graphic-CfT07maQ.js";import"./getPopupProvider-zqy7P9ZA.js";import"./Color-CERqXxxY.js";import"./Layer--kjMcEYS.js";import"./createFeatureId-CVwTD0fV.js";import"./typeUtils-BUTeHmXX.js";import"./lineMarkers-CDwLe3J6.js";import"./PolygonSymbol3D-DOhH5ySO.js";import"./ExtrudeSymbol3DLayer-DSc1ou2x.js";import"./opacityUtils-DuFH0EC9.js";import"./aaBoundingBox-CNqmdQRu.js";import"./DoubleArray-DExKNiTh.js";import"./mat4f64-q_b6UJoq.js";import"./Font-SQ7b_Y8G.js";import"./SimpleFillSymbol-CDawtd9z.js";import"./SimpleMarkerSymbol-BGAFRS9_.js";import"./PictureMarkerSymbol-6cJpxdoq.js";import"./TextSymbol-DhXD0YaH.js";import"./HeightModelInfo-BOZ2bCXl.js";import"./projectionUtils-BYIvMX5W.js";import"./spatialReferenceEllipsoidUtils-DnehMctI.js";import"./projectPointToVector-lgC5SvvR.js";import"./RealisticTree.glsl-CD2qk3Wa.js";import"./mat4-Df_3WIwI.js";import"./vec2f64-rIxtbMRN.js";import"./vec32-DIQfN9dj.js";import"./vec4f64-DPb6J-GU.js";import"./BufferView-BVrbsaWH.js";import"./vec42-ClQ6ADuy.js";import"./Emissions.glsl-B8XKMjLy.js";import"./InterleavedLayout-DVezg4xk.js";import"./types-BKo2foNY.js";import"./VertexElementDescriptor-BlxU8vCE.js";import"./meshVertexSpaceUtils-CDaunXaJ.js";import"./MeshLocalVertexSpace-y1kE5w4c.js";import"./projectVectorToVector-CDqEkUpu.js";import"./vec3f32-WCVSSNPR.js";import"./Indices-D0_UQPPr.js";import"./plane-C25sE_vU.js";import"./vector-HTSzpX5X.js";import"./quatf64-CCm9z-pX.js";import"./sphere-COwiWjRO.js";import"./orientedBoundingBox-CpdLjzxi.js";import"./quat-D3JcL9GI.js";import"./computeTranslationToOriginAndRotation-D0D690pa.js";import"./memoryEstimations-Bd726a_p.js";import"./HUDIntersectorResult-DJ-mrASs.js";import"./Intersector-BEbN3ApI.js";import"./frustum-DWgQCJBb.js";import"./scaleUtils-cWMHpBu0.js";import"./layerUtils-CCPFPk-j.js";import"./TilemapCache-ChidWVjQ.js";import"./TileKey-CTZ53yPm.js";import"./tagSymbols-BPcGfZon.js";import"./UpdatingHandles-D2RI_3Hb.js";import"./asyncUtils-w6KfWU41.js";import"./Queue-CYlrXMwB.js";import"./signal-BX9ezF8a.js";import"./Map-BZpIOwPY.js";import"./Basemap-fKW7Cz4U.js";import"./loadAll-H0orMzpA.js";import"./PortalItem-e2bKDJZ8.js";import"./writeUtils-BvBZRLXT.js";import"./CollectionFlattener-CyTdUoKH.js";import"./persistable-Ot1881Fk.js";import"./MD5-MtSiOt06.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./resourceExtension-Dlt4ayx_.js";import"./PolygonCollection-j-hecAeB.js";import"./mat4f32-Djp3mnm5.js";import"./TablesMixin-Nye32Ffd.js";import"./timeZoneUtils-BSc7-7qA.js";import"./ReactiveMap-B0by2bYu.js";import"./Query-dGEUg7py.js";import"./Field-Cm_ZejYW.js";import"./fieldType-DVUzXtk_.js";import"./normalizeUtils-BEJV7G0l.js";import"./Cyclical-BLSxUpe7.js";import"./normalizeUtilsCommon-DnSvD7ht.js";import"./utils-BrkeFJbU.js";import"./utils-DGvxRWBb.js";import"./ElevationQuery-uPUdv3lW.js";import"./Scheduler-CNrsbccs.js";import"./layerViewUtils-BTa15X3o.js";import"./unitConversionUtils-C_S2QiAQ.js";import"./dehydratedFeatures-D_FpkmpM.js";import"./quantizationUtils-BYmjRh4u.js";import"./featureConversionUtils-hXFGbgzJ.js";import"./OptimizedFeature-CwRGZPwv.js";import"./OptimizedFeatureSet-BR8EEvDc.js";import"./Octree-BScVi4hI.js";import"./elevationInfoUtils-Dxkv6YB1.js";import"./intersectorUtilsConversions-DcxEtHOg.js";import"./DefaultLoadingContext-BBb1tRC-.js";import"./wosrLoader-BTzfF2iQ.js";import"./Version-BtYZEj58.js";import"./axisAngleDegrees-D1OOYQT7.js";import"./edgePreprocessing-BFYAECPd.js";import"./GeometryUtils-BdjkAnCr.js";import"./WorkerHandle-CWMP3YEU.js";import"./colorUtils-BzDQ74Nc.js";import"./vec3-B_phcnZY.js";import"./vec33-CWJeyzxV.js";import"./capabilities-Bi6C4OG6.js";import"./imageUtils-CE3cSuc6.js";import"./videoUtils-Dwx3AEgj.js";import"./labelUtils-BtizwBfq.js";import"./ArcadeExpression-BHPcSlWy.js";import"./TimeOnly-DH57Trnh.js";import"./enum-BzLwmiID.js";import"./UnknownTimeZone-B697BDFv.js";import"./FieldsIndex-CyoOfYU1.js";let nt=class{constructor(e,i,t){this._scale=e,this._shift=i,this._levelShift=t}getLevelRowColumn(e){const i=this.getLevelShift(e[0]),t=this._shift+i;return t?[e[0]-i,e[1]>>t,e[2]>>t]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,i){let t=0,n=0;const a=this._shift+this.getLevelShift(e[0]);if(a){const o=(1<<a)-1,r=i/(this._scale*(1<<a-1));t=(e[2]&o)*r,n=(e[1]&o)*r}return[t,n]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}},G=class{constructor(e,i){this._width=0,this._height=0,this._free=[],this._width=e,this._height=i,this._free.push(new k(0,0,e,i))}get width(){return this._width}get height(){return this._height}allocate(e,i){if(e>this._width||i>this._height)return new k;let t=null,n=-1;for(let a=0;a<this._free.length;++a){const o=this._free[a];e<=o.width&&i<=o.height&&(t===null||o.y<=t.y&&o.x<=t.x)&&(t=o,n=a)}return t===null?new k:(this._free.splice(n,1),t.width<t.height?(t.width>e&&this._free.push(new k(t.x+e,t.y,t.width-e,i)),t.height>i&&this._free.push(new k(t.x,t.y+i,t.width,t.height-i))):(t.width>e&&this._free.push(new k(t.x+e,t.y,t.width-e,t.height)),t.height>i&&this._free.push(new k(t.x,t.y+i,e,t.height-i))),new k(t.x,t.y,e,i))}release(e){for(let i=0;i<this._free.length;++i){const t=this._free[i];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(i,1),this.release(e)}this._free.push(e)}},le=class{constructor(e,i,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=i,this._glyphSource=t,this._binPack=new G(e-4,i-4),this._glyphData.push(new Uint8Array(e*i)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,i){const t=[],n=this._glyphSource,a=new Set,o=1/256;for(const s of i){const l=Math.floor(s*o);a.add(l)}const r=[];return a.forEach(s=>{const l=e+s;if(this._rangePromises.has(l))r.push(this._rangePromises.get(l));else{const u=n.getRange(e,s).then(()=>{this._rangePromises.delete(l)},()=>{this._rangePromises.delete(l)});this._rangePromises.set(l,u),r.push(u)}}),Promise.all(r).then(()=>{let s=this._glyphIndex[e];s||(s={},this._glyphIndex[e]=s);for(const l of i){const u=s[l];if(u){t[l]={sdf:!0,rect:u.rect,metrics:u.metrics,page:u.page,code:l};continue}const w=n.getGlyph(e,l);if(!w?.metrics)continue;const m=w.metrics;let x;if(m.width===0)x=new k(0,0,0,0);else{const p=m.width+6,y=m.height+6;let P=p%4?4-p%4:4,S=y%4?4-y%4:4;P===1&&(P=5),S===1&&(S=5),x=this._binPack.allocate(p+P,y+S),x.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new G(this.width-4,this.height-4),x=this._binPack.allocate(p+P,y+S));const g=this._glyphData[this._currentPage],b=w.bitmap;let d,h;if(b)for(let _=0;_<y;_++){d=p*_,h=this.width*(x.y+_+1)+x.x;for(let M=0;M<p;M++)g[h+M+1]=b.at(d+M)}}s[l]={rect:x,metrics:m,tileIDs:null,page:this._currentPage},t[l]={sdf:!0,rect:x,metrics:m,page:this._currentPage,code:l},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const i in this._glyphIndex){const t=this._glyphIndex[i];if(!t)continue;let n;for(const a in t)if(n=t[a],n.tileIDs.delete(e),n.tileIDs.size===0){const o=this._glyphData[n.page],r=n.rect;let s,l;for(let u=0;u<r.height;u++)for(s=this.width*(r.y+u)+r.x,l=0;l<r.width;l++)o[s+l]=0;delete t[a],this._dirties[n.page]=!0}}}bind(e,i,t,n=0){if(!this._textures[t]){const o=new xe(this.width,this.height);o.pixelFormat=6406,o.wrapMode=33071,this._textures[t]=new we(e,o,new Uint8Array(this.width*this.height))}const a=this._textures[t];a.setSamplingMode(i),this._dirties[t]&&a.setData(this._glyphData[t]),e.bindTexture(a,n),this._dirties[t]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}},X=class{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const i=new Map;let t=0;for(;e.next();)switch(e.tag()){case 1:{const o=e.getMessage();for(;o.next();)switch(o.tag()){case 3:{const r=o.getMessage();let s,l,u,w,m,x,v;for(;r.next();)switch(r.tag()){case 1:s=r.getUInt32();break;case 2:l=r.getBytes();break;case 3:u=r.getUInt32();break;case 4:w=r.getUInt32();break;case 5:m=r.getSInt32();break;case 6:x=r.getSInt32();break;case 7:v=r.getUInt32();break;default:r.skip()}if(r.release(),s){const p=l?.length??0;this._metrics[s]={width:u,height:w,left:m,top:x,advance:v,startOffset:t,length:p},i.set(s,l),t+=p}break}default:o.skip()}o.release();break}default:e.skip()}const n=new Uint8Array(t),a=this._metrics;for(const[o,r]of i){const{startOffset:s,length:l}=a[o];if(r)for(let u=0;u<l;++u)n[s+u]=r[u]}this._allBitmaps=n}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const i=this._metrics[e];if(i===void 0)return;const{startOffset:t,length:n}=i;return n!==0?new ot(this._allBitmaps,t,n):void 0}},rt=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(e){return this._ranges[e]}addRange(e,i){this._ranges[e]=i}},ce=class{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,i){const t=this._getFontStack(e);if(t.getRange(i))return Promise.resolve();const n=256*i,a=n+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+a);return Ge(o,{responseType:"array-buffer"}).then(r=>{t.addRange(i,new X(new je(new Uint8Array(r.data),new DataView(r.data))))}).catch(()=>{t.addRange(i,new X)})}return t.addRange(i,new X),Promise.resolve()}getGlyph(e,i){const t=this._getFontStack(e);if(!t)return;const n=Math.floor(i/256),a=t.getRange(n);return a?{metrics:a.getMetrics(i),bitmap:a.getBitmap(i)}:void 0}_getFontStack(e){let i=this._glyphInfo[e];return i||(i=this._glyphInfo[e]=new rt),i}},ot=class{constructor(e,i,t){this._array=e,this._start=i,this.length=t}at(e){return 0<=e&&e<this.length?this._array[this._start+e]:void 0}};const st="dasharray-";let ue=class be{constructor(e,i,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,i<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=i,t>0&&(this._maxItemSize=t),this._binPack=new G(e-4,i-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new G(this._pageWidth-4,this._pageHeight-4);const i=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),n=new Uint32Array(i*t);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,i=!1){let t,n,a=this._mosaicRects[e];if(a)return a;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(st)?([t,n]=this._rasterizeDash(e),i=!0):t=this._sprites.getSpriteInfo(e),!t?.width||!t.height||t.width<0||t.height<0))return null;const o=t.width,r=t.height,[s,l,u]=this._allocateImage(o,r);return s.width<=0?null:(this._copy(s,t,l,u,i,n),a={type:"sprite",rect:s,width:o,height:r,sdf:t.sdf,simplePattern:!1,rasterizationScale:t.pixelRatio??1,samplingMode:"Linear",page:l},this._mosaicRects[e]=a,a)}getSpriteItems(e){const i={};for(const t of e)i[t.name]=this.getSpriteItem(t.name,t.repeat);return i}getMosaicItemPosition(e,i){const t=this.getSpriteItem(e,i),n=t?.rect;if(!n)return null;n.width=t.width,n.height=t.height;const a=t.width,o=t.height,r=2;return{tl:[n.x+r,n.y+r],br:[n.x+r+a,n.y+r+o],page:t.page}}bind(e,i,t=0,n=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;if(!this._textures[t]){const o=new xe(this._size[t][0],this._size[t][1]);o.wrapMode=33071,this._textures[t]=new we(e,o,new Uint8Array(this._mosaicsData[t].buffer))}const a=this._textures[t];a.setSamplingMode(i),this._dirties[t]&&a.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(a,n),this._dirties[t]=!1}static _copyBits(e,i,t,n,a,o,r,s,l,u,w){let m=n*i+t,x=s*o+r;if(w){x-=o;for(let v=-1;v<=u;v++,m=((v+u)%u+n)*i+t,x+=o)for(let p=-1;p<=l;p++)a[x+p]=e[m+(p+l)%l]}else for(let v=0;v<u;v++){for(let p=0;p<l;p++)a[x+p]=e[m+p];m+=i,x+=o}}_copy(e,i,t,n,a,o){if(!this._sprites||this._sprites.loadStatus!=="loaded"||t>=this._mosaicsData.length)return;const r=new Uint32Array(o?o.buffer:this._sprites.image.buffer),s=this._mosaicsData[t],l=2,u=o?i.width:this._sprites.width;be._copyBits(r,u,i.x,i.y,s,n[0],e.x+l,e.y+l,i.width,i.height,a),this._dirties[t]=!0}_allocateImage(e,i){e+=2,i+=2;const t=Math.max(e,i);if(this._maxItemSize&&this._maxItemSize<t){const r=new k(0,0,e,i);return this._mosaicsData.push(new Uint32Array(e*i)),this._dirties.push(!0),this._size.push([e,i]),this._textures.push(void 0),[r,this._mosaicsData.length-1,[e,i]]}let n=e%4?4-e%4:4,a=i%4?4-i%4:4;n===1&&(n=5),a===1&&(a=5);const o=this._binPack.allocate(e+n,i+a);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new G(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,i)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const i=/\[(.*?)\]/,t=e.match(i);if(!t)return null;const n=t[1].split(",").map(Number),a=e.slice(e.lastIndexOf("-")+1),[o,r,s]=Xe(n,a);return[{x:0,y:0,width:r,height:s,sdf:!0,pixelRatio:1},new Uint8Array(o.buffer)]}},lt=class{constructor(e,i,t,n){this._layer=e,this._styleRepository=i,this.devicePixelRatio=t,this._sourceDataMaxLOD=n,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=ye(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(e){this._requestSprite(e);const i=this._layer.currentStyleInfo.glyphsUrl,t=new ce(i?ae(i,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new le(1024,1024,t),this._broadcastPromise=Ke("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then(n=>{if(this._layer&&(this._connection?.close(),this._connection=n,this._layer&&!this._connection.closed)){const a=n.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},e);Promise.all(a).catch(o=>De(o))}})}_requestSprite(e){this._spriteSourceAbortController?.abort();const i=new AbortController;this._spriteSourceAbortController=i;const t=e?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,t&&(this._inputSignalEventListener=ct(i),t.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:n}=i,a={...e,signal:n};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,a),this._spriteSourcePromise.then(o=>{Re(n),this._spriteMosaic=new ue(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(e){const i=[];for(const t of e)t.type===4?i.push({type:4,data:{spriteSource:null}}):i.push(t);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",i)),this._broadcastPromise}setSpriteSource(e){const i=new ue(1024,1024,250);return i.setSpriteSource(e),this._spriteMosaic=i,this._spriteSourcePromise=Promise.resolve(e),this._spriteSourceAbortController=null,i}async setStyle(e,i,t){await this._broadcastPromise,this._styleRepository=e,this._sourceDataMaxLOD=t,this._requestSprite();const n=new ce(this._layer.currentStyleInfo.glyphsUrl?ae(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new le(1024,1024,n),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:i,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(e,i){const t=await this._getRefKeys(e,i);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),t,i)}async fetchTilePBFs(e){const i=Object.keys(this._layer.sourceNameToSource),t={},n=await this._getRefKeys(e,t),a=[],o=[];for(let r=0;r<n.length;r++)if(n[r].value==null||i[r]==null)o.push(null);else{const s=n[r].value,l=this._getTilePayload(s,i[r],t);l.then(u=>{a.push({...u,key:s})}),o.push(l)}return Promise.all(o).then(()=>a)}async parseTileData(e,i){const t=e&&e.data;if(!t)return null;const{sourceName2DataAndRefKey:n,transferList:a}=t;return Object.keys(n).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},{...i,transferList:a}))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}async _getTilePayload(e,i,t){const n=q.pool.acquire(e.id),a=this._layer.sourceNameToSource[i],{level:o,row:r,col:s}=n;q.pool.release(n);try{return{protobuff:await a.requestTile(o,r,s,t),sourceName:i}}catch(l){if(Ce(l))throw l;return{protobuff:null,sourceName:i}}}async _getRefKeys(e,i){const t=this._layer.sourceNameToSource,n=new Array;for(const a in t){const o=t[a].getRefKey(e,i);n.push(o)}return Q(n)}_getSourcesData(e,i,t){const n=[];for(let a=0;a<i.length;a++)if(i[a].value==null||e[a]==null)n.push(null);else{const o=i[a].value,r=this._getTilePayload(o,e[a],t);n.push(r)}return Q(n).then(a=>{const o={},r=[];for(let s=0;s<a.length;s++){const l=a[s].value;if(l&&l.protobuff&&l.protobuff.byteLength>0){const u=i[s].value.id;o[l.sourceName]={refKey:u,protobuff:l.protobuff},r.push(l.protobuff)}}return{sourceName2DataAndRefKey:o,transferList:r}})}};function ct(c){return()=>c.abort()}let ut=class extends Je{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const i=q.pool.acquire(e),t=i.level===0?null:q.getId(i.level-1,i.row>>1,i.col>>1,i.world);return q.pool.release(i),t}getTileCoverage(e,i,t=!0,n){const a=super.getTileCoverage(e,i,t,n);if(!a)return a;const o=1<<a.lodInfo.level;return a.spans=a.spans.filter(r=>r.row>=0&&r.row<o),a}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const i=this._fullCacheLodInfos;if(e>i[0].scale)return i[0].level;let t,n;for(let a=0;a<i.length-1;a++)if(n=i[a+1],e>n.scale)return t=i[a],t.level+(t.scale-e)/(t.scale-n.scale);return i[i.length-1].level}}_initializeFullCacheLODs(e){let i;if(e[0].level===0)i=e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale}));else{const t=this.tileInfo.size[0],n=this.tileInfo.spatialReference;i=Ze.create({size:t,spatialReference:n}).lods.map(a=>({level:a.level,resolution:a.resolution,scale:a.scale}))}for(let t=0;t<i.length;t++)this._levelByScale[i[t].scale]=i[t].level;this._fullCacheLodInfos=i}},he=class extends lt{constructor(e,i,t,n){super(e,i,t,e.tileInfo.lods.length-1),this._memCache=n,this._vectorTiles=new Map,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new ut(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear(),this._vectorTiles.clear()}async getVectorTile(e,i){const t=new q(e[0],e[1],e[2],0);let n=this._vectorTiles.get(t.id)??this._memCache.get(t.id);if(n)return n.retain(),n;const a=await this._getVectorTileData(t);if(Ie(i),!this._layer)return null;if(n=this._vectorTiles.get(t.id)??this._memCache.get(t.id),n)return n.retain(),n;const o=this._layer.tileInfo.getTileBounds(qe(),t),r=this._tileInfoView.getTileResolution(e[0]);return n=new $e(t,r,o[0],o[3],ie,ie,this._styleRepository,this),n.setData(a),a&&(n.retain(),this._memCache.put(t.id,n,Ve),this._vectorTiles.set(t.id,n)),n.neededForCoverage=!0,n.transforms.tileUnitsToPixels=Fe(1/8,0,0,0,1/8,0,0,0,1),n}updateTileSize(e){this._memCache.updateSize(e.id)}onDisposeTile(e){this._vectorTiles.delete(e.id)}_getVectorTileData(e){const i=e.id;if(this._ongoingTileRequests.has(i))return this._ongoingTileRequests.get(i);const t=new AbortController,n={signal:t.signal},a=this._getParsedVectorTileData(e,n).then(o=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),o)).catch(()=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),null));return this._ongoingTileRequests.set(i,a),this._ongoingRequestToController.set(i,t),a}_getParsedVectorTileData(e,i){return this.fetchTileData(e,i).then(t=>this.parseTileData({key:e,data:t},i))}},K=class{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,i){}draw(e,i,t){}drawMany(e,i,t){for(const n of i)n.visible&&this.draw(e,n,t)}};class ht extends K{constructor(){super(...arguments),this._color=Oe(1,0,0,1),this._patternMatrix=Ne(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao=Z(this._vao)}drawMany(e,i){const{context:t,painter:n,requestRender:a,allowDelayedRender:o}=e;this._loadWGLResources(e);const r=e.displayLevel,s=e.styleLayer,l=s.backgroundMaterial,u=n.vectorTilesMaterialManager,w=s.getPaintValue("background-color",r),m=s.getPaintValue("background-opacity",r),x=s.getPaintValue("background-pattern",r),v=x!==void 0,p=1|window.devicePixelRatio,y=e.spriteMosaic;let P,S;const g=p>Se?2:1,b=this._programOptions;b.pattern=v;const d=u.getMaterialProgram(t,l,b);if(!o||a==null||d.compiled){if(t.bindVAO(this._vao),t.useProgram(d),v){const h=y.getMosaicItemPosition(x,!0);if(h!=null){const{tl:_,br:M,page:f}=h;P=M[0]-_[0],S=M[1]-_[1];const R=y.getPageSize(f);R!=null&&(y.bind(t,9729,f,L),d.setUniform4f("u_tlbr",_[0],_[1],M[0],M[1]),d.setUniform2fv("u_mosaicSize",R),d.setUniform1i("u_texture",L))}d.setUniform1f("u_opacity",m)}else{const h=w[3]*m;this._color[0]=h*w[0],this._color[1]=h*w[1],this._color[2]=h*w[2],this._color[3]=h,d.setUniform4fv("u_color",this._color)}d.setUniform1f("u_depth",s.z||0);for(const h of i){if(d.setUniform1f("u_coord_range",h.rangeX),d.setUniformMatrix3fv("u_dvsMat3",h.transforms.displayViewScreenMat3),v){const _=Math.max(2**(Math.round(r)-h.key.level),1),M=g*h.width*_,f=M/ne(P),R=M/ne(S);this._patternMatrix[0]=f,this._patternMatrix[4]=R,d.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}t.setStencilFunction(514,0,255),t.drawArrays(A.TRIANGLE_STRIP,0,4)}}else a()}_loadWGLResources(e){if(this._vao)return;const{context:i,styleLayer:t}=e,n=t.backgroundMaterial,a=new Int8Array([0,0,1,0,0,1,1,1]),o=new Ye(i,n.geometryLayout,a);this._vao=new He(i,o)}}let pt=class extends K{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,requiredLevel:a,state:o,painter:r,spriteMosaic:s,styleLayerUID:l,requestRender:u,allowDelayedRender:w}=e;if(!i.some(d=>d.layerData.get(l)?.circleIndexCount??!1))return;const m=e.styleLayer,x=m.circleMaterial,v=r.vectorTilesMaterialManager,p=1.2,y=m.getPaintValue("circle-translate",n),P=m.getPaintValue("circle-translate-anchor",n),S=this._programOptions,g=v.getMaterialProgram(t,x,S);if(w&&u!=null&&!g.compiled)return void u();t.useProgram(g),g.setUniformMatrix3fv("u_displayMat3",P===1?o.displayMat3:o.displayViewMat3),g.setUniform2fv("u_circleTranslation",y),g.setUniform1f("u_depth",m.z),g.setUniform1f("u_antialiasingWidth",p);let b=-1;for(const d of i){if(!d.layerData.has(l))continue;d.key.level!==b&&(b=d.key.level,x.setDataUniforms(g,n,m,b,s));const h=d.layerData.get(l);if(!h.circleIndexCount)continue;h.prepareForRendering(t);const _=h.vao;_!=null&&(t.bindVAO(_),g.setUniformMatrix3fv("u_dvsMat3",d.transforms.displayViewScreenMat3),a!==d.key.level?t.setStencilFunction(514,d.stencilRef,255):t.setStencilFunction(516,255,255),t.drawElements(A.TRIANGLES,h.circleIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*h.circleIndexStart),d.triangleCount+=h.circleIndexCount/3)}}};const pe=1/65536;let dt=class extends K{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,i){const{displayLevel:t,renderPass:n,spriteMosaic:a,styleLayerUID:o}=e;let r=!1;for(const g of i)if(g.layerData.has(o)){const b=g.layerData.get(o);if(b.fillIndexCount>0||b.outlineIndexCount>0){r=!0;break}}if(!r)return;const s=e.styleLayer,l=s.getPaintProperty("fill-pattern"),u=l!==void 0,w=u&&l.isDataDriven;let m;if(u&&!w){const g=l.getValue(t);m=a.getMosaicItemPosition(g,!0)}const x=!u&&s.getPaintValue("fill-antialias",t);let v=!0,p=1;if(!u){const g=s.getPaintProperty("fill-color"),b=s.getPaintProperty("fill-opacity");if(!g?.isDataDriven&&!b?.isDataDriven){const d=s.getPaintValue("fill-color",t);p=s.getPaintValue("fill-opacity",t)*d[3],p>=1&&(v=!1)}}if(v&&n==="opaque")return;const y=s.getPaintValue("fill-translate",t),P=s.getPaintValue("fill-translate-anchor",t);(v||n!=="translucent")&&this._drawFill(e,o,s,i,y,P,u,m,w);const S=!s.hasDataDrivenOutlineColor&&s.outlineUsesFillColor&&p<1;x&&n!=="opaque"&&!S&&this._drawOutline(e,o,s,i,y,P)}_drawFill(e,i,t,n,a,o,r,s,l){if(r&&!l&&s==null)return;const{context:u,displayLevel:w,state:m,painter:x,pixelRatio:v,spriteMosaic:p,requestRender:y,allowDelayedRender:P}=e,S=t.fillMaterial,g=x.vectorTilesMaterialManager,b=v>Se?2:1,d=this._fillProgramOptions;d.pattern=r;const h=g.getMaterialProgram(u,S,d);if(P&&y!=null&&!h.compiled)return void y();if(u.useProgram(h),s!=null){const{page:M}=s,f=p.getPageSize(M);f!=null&&(p.bind(u,9729,M,L),h.setUniform2fv("u_mosaicSize",f),h.setUniform1i("u_texture",L))}h.setUniformMatrix3fv("u_displayMat3",o===1?m.displayMat3:m.displayViewMat3),h.setUniform2fv("u_fillTranslation",a),h.setUniform1f("u_depth",t.z+pe);let _=-1;for(const M of n){if(!M.layerData.has(i))continue;M.key.level!==_&&(_=M.key.level,S.setDataUniforms(h,w,t,_,p));const f=M.layerData.get(i);if(!f.fillIndexCount)continue;f.prepareForRendering(u);const R=f.fillVAO;if(R!=null){if(u.bindVAO(R),h.setUniformMatrix3fv("u_dvsMat3",M.transforms.displayViewScreenMat3),u.setStencilFunction(514,M.stencilRef,255),r){const T=Math.max(2**(Math.round(w)-M.key.level),1),C=M.rangeX/(b*M.width*T);h.setUniform1f("u_patternFactor",C)}if(l){const T=f.patternMap;if(!T)continue;for(const[C,I]of T){const N=p.getPageSize(C);N!=null&&(p.bind(u,9729,C,L),h.setUniform2fv("u_mosaicSize",N),h.setUniform1i("u_texture",L),u.drawElements(A.TRIANGLES,I[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*I[0]))}}else u.drawElements(A.TRIANGLES,f.fillIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*f.fillIndexStart);M.triangleCount+=f.fillIndexCount/3}}}_drawOutline(e,i,t,n,a,o){const{context:r,displayLevel:s,state:l,painter:u,pixelRatio:w,spriteMosaic:m,requestRender:x,allowDelayedRender:v}=e,p=t.outlineMaterial,y=u.vectorTilesMaterialManager,P=.75/w,S=this._outlineProgramOptions,g=y.getMaterialProgram(r,p,S);if(v&&x!=null&&!g.compiled)return void x();r.useProgram(g),g.setUniformMatrix3fv("u_displayMat3",o===1?l.displayMat3:l.displayViewMat3),g.setUniform2fv("u_fillTranslation",a),g.setUniform1f("u_depth",t.z+pe),g.setUniform1f("u_outline_width",P);let b=-1;for(const d of n){if(!d.layerData.has(i))continue;d.key.level!==b&&(b=d.key.level,p.setDataUniforms(g,s,t,b,m));const h=d.layerData.get(i);if(h.prepareForRendering(r),!h.outlineIndexCount)continue;const _=h.outlineVAO;_!=null&&(r.bindVAO(_),g.setUniformMatrix3fv("u_dvsMat3",d.transforms.displayViewScreenMat3),r.setStencilFunction(514,d.stencilRef,255),r.drawElements(A.TRIANGLES,h.outlineIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*h.outlineIndexStart),d.triangleCount+=h.outlineIndexCount/3)}}},mt=class extends K{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,state:a,painter:o,pixelRatio:r,spriteMosaic:s,styleLayerUID:l,requestRender:u,allowDelayedRender:w}=e;if(!i.some(T=>T.layerData.get(l)?.lineIndexCount??!1))return;const m=e.styleLayer,x=m.lineMaterial,v=o.vectorTilesMaterialManager,p=m.getPaintValue("line-translate",n),y=m.getPaintValue("line-translate-anchor",n),P=m.getPaintProperty("line-pattern"),S=P!==void 0,g=S&&P.isDataDriven;let b,d;if(S&&!g){const T=P.getValue(n);b=s.getMosaicItemPosition(T)}let h=!1;if(!S){const T=m.getPaintProperty("line-dasharray");if(d=T!==void 0,h=d&&T.isDataDriven,d&&!h){const C=T.getValue(n),I=m.getDashKey(C,m.getLayoutValue("line-cap",n));b=s.getMosaicItemPosition(I)}}const _=1/r,M=this._programOptions;M.pattern=S,M.sdf=d;const f=v.getMaterialProgram(t,x,M);if(w&&u!=null&&!f.compiled)return void u();if(t.useProgram(f),f.setUniformMatrix3fv("u_displayViewMat3",a.displayViewMat3),f.setUniformMatrix3fv("u_displayMat3",y===1?a.displayMat3:a.displayViewMat3),f.setUniform2fv("u_lineTranslation",p),f.setUniform1f("u_depth",m.z),f.setUniform1f("u_antialiasing",_),b&&b!=null){const{page:T}=b,C=s.getPageSize(T);C!=null&&(s.bind(t,9729,T,L),f.setUniform2fv("u_mosaicSize",C),f.setUniform1i("u_texture",L))}let R=-1;for(const T of i){if(!T.layerData.has(l))continue;T.key.level!==R&&(R=T.key.level,x.setDataUniforms(f,n,m,R,s));const C=2**(n-R)/r;f.setUniform1f("u_zoomFactor",C);const I=T.layerData.get(l);if(!I.lineIndexCount)continue;I.prepareForRendering(t);const N=I.vao;if(N!=null){if(t.bindVAO(N),f.setUniformMatrix3fv("u_dvsMat3",T.transforms.displayViewScreenMat3),t.setStencilFunction(514,T.stencilRef,255),g||h){const Y=I.patternMap;if(!Y)continue;for(const[D,B]of Y){const U=s.getPageSize(D);U!=null&&(s.bind(t,9729,D,L),f.setUniform2fv("u_mosaicSize",U),f.setUniform1i("u_texture",L),t.drawElements(A.TRIANGLES,B[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*B[0]))}}else t.drawElements(A.TRIANGLES,I.lineIndexCount,F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*I.lineIndexStart);T.triangleCount+=I.lineIndexCount/3}}}};const _t=256/360;function ft(c,e){return(c%=e)>=0?c:c+e}function de(c){return ft(c*_t,256)}const gt=1/65536;class vt extends K{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=Qe()}dispose(){}drawMany(e,i){const t=e.styleLayer;this._drawIcons(e,t,i),this._drawText(e,t,i)}_drawIcons(e,i,t){const{context:n,displayLevel:a,painter:o,spriteMosaic:r,state:s,styleLayerUID:l,requestRender:u,allowDelayedRender:w}=e,m=i.iconMaterial,x=o.vectorTilesMaterialManager;let v,p=!1;for(const f of t)if(f.layerData.has(l)&&(v=f.layerData.get(l),v.iconPerPageElementsMap.size>0)){p=!0;break}if(!p)return;const y=i.getPaintValue("icon-translate",a),P=i.getPaintValue("icon-translate-anchor",a);let S=i.getLayoutValue("icon-rotation-alignment",a);S===2&&(S=i.getLayoutValue("symbol-placement",a)===0?1:0);const g=S===0,b=i.getLayoutValue("icon-keep-upright",a)&&g,d=v.isIconSDF,h=this._iconProgramOptions;h.sdf=d;const _=x.getMaterialProgram(n,m,h);if(w&&u!=null&&!_.compiled)return void u();n.useProgram(_),_.setUniformMatrix3fv("u_displayViewMat3",S===0?s.displayViewMat3:s.displayMat3),_.setUniformMatrix3fv("u_displayMat3",P===1?s.displayMat3:s.displayViewMat3),_.setUniform2fv("u_iconTranslation",y),_.setUniform1f("u_depth",i.z),_.setUniform1f("u_mapRotation",de(s.rotation)),_.setUniform1f("u_keepUpright",b?1:0),_.setUniform1f("u_level",10*a),_.setUniform1i("u_texture",L),_.setUniform1f("u_fadeDuration",oe/1e3),_.setUniform1i("u_isStencilPass",e.stencilSymbols?1:0);let M=-1;for(const f of t){if(!f.layerData.has(l)||(f.key.level!==M&&(M=f.key.level,m.setDataUniforms(_,a,i,M,r)),v=f.layerData.get(l),v.iconPerPageElementsMap.size===0))continue;v.prepareForRendering(n),v.updateOpacityInfo();const R=v.iconVAO;if(R!=null){n.bindVAO(R),_.setUniformMatrix3fv("u_dvsMat3",f.transforms.displayViewScreenMat3),_.setUniform1f("u_time",(performance.now()-v.lastOpacityUpdate)/1e3);for(const[T,C]of v.iconPerPageElementsMap)this._renderIconRange(e,_,C,T,f)}}}_renderIconRange(e,i,t,n,a){const{context:o,spriteMosaic:r}=e;this._spritesTextureSize[0]=r.getWidth(n)/4,this._spritesTextureSize[1]=r.getHeight(n)/4,i.setUniform2fv("u_mosaicSize",this._spritesTextureSize),r.bind(o,9729,n,L),this._setStencilState(e,a),o.drawElements(A.TRIANGLES,t[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),a.triangleCount+=t[1]/3}_drawText(e,i,t){const{context:n,displayLevel:a,glyphMosaic:o,painter:r,pixelRatio:s,spriteMosaic:l,state:u,styleLayerUID:w,requestRender:m,allowDelayedRender:x}=e,v=i.textMaterial,p=r.vectorTilesMaterialManager;let y,P=!1;for(const U of t)if(U.layerData.has(w)&&(y=U.layerData.get(w),y.glyphPerPageElementsMap.size>0)){P=!0;break}if(!P)return;const S=i.getPaintProperty("text-opacity");if(S&&!S.isDataDriven&&S.getValue(a)===0)return;const g=i.getPaintProperty("text-color"),b=!g||g.isDataDriven||g.getValue(a)[3]>0,d=i.getPaintProperty("text-halo-width"),h=i.getPaintProperty("text-halo-color"),_=(!d||d.isDataDriven||d.getValue(a)>0)&&(!h||h.isDataDriven||h.getValue(a)[3]>0);if(!b&&!_)return;const M=24/8;let f=i.getLayoutValue("text-rotation-alignment",a);f===2&&(f=i.getLayoutValue("symbol-placement",a)===0?1:0);const R=f===0,T=i.getLayoutValue("text-keep-upright",a)&&R,C=.8*M/s;this._glyphTextureSize||(this._glyphTextureSize=et(o.width/4,o.height/4));const I=i.getPaintValue("text-translate",a),N=i.getPaintValue("text-translate-anchor",a),Y=this._sdfProgramOptions,D=p.getMaterialProgram(n,v,Y);if(x&&m!=null&&!D.compiled)return void m();n.useProgram(D),D.setUniformMatrix3fv("u_displayViewMat3",f===0?u.displayViewMat3:u.displayMat3),D.setUniformMatrix3fv("u_displayMat3",N===1?u.displayMat3:u.displayViewMat3),D.setUniform2fv("u_textTranslation",I),D.setUniform1f("u_depth",i.z+gt),D.setUniform2fv("u_mosaicSize",this._glyphTextureSize),D.setUniform1f("u_mapRotation",de(u.rotation)),D.setUniform1f("u_keepUpright",T?1:0),D.setUniform1f("u_level",10*a),D.setUniform1i("u_texture",re),D.setUniform1f("u_antialiasingWidth",C),D.setUniform1f("u_fadeDuration",oe/1e3);let B=-1;for(const U of t){if(!U.layerData.has(w)||(U.key.level!==B&&(B=U.key.level,v.setDataUniforms(D,a,i,B,l)),y=U.layerData.get(w),y.glyphPerPageElementsMap.size===0))continue;y.prepareForRendering(n),y.updateOpacityInfo();const J=y.textVAO;if(J==null)continue;n.bindVAO(J),D.setUniformMatrix3fv("u_dvsMat3",U.transforms.displayViewScreenMat3),this._setStencilState(e,U);const Me=(performance.now()-y.lastOpacityUpdate)/1e3;D.setUniform1f("u_time",Me),y.glyphPerPageElementsMap.forEach((Pe,Te)=>{this._renderGlyphRange(n,Pe,Te,o,D,_,b,U)})}}_renderGlyphRange(e,i,t,n,a,o,r,s){n.bind(e,9729,t,re),o&&(a.setUniform1f("u_halo",1),e.drawElements(A.TRIANGLES,i[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),s.triangleCount+=i[1]/3),r&&(a.setUniform1f("u_halo",0),e.drawElements(A.TRIANGLES,i[1],F.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),s.triangleCount+=i[1]/3)}_setStencilState(e,i){const{context:t,is3D:n,stencilSymbols:a}=e;if(t.setStencilTestEnabled(!0),a)return t.setStencilWriteMask(255),void t.setStencilFunction(519,i.stencilRef,255);t.setStencilWriteMask(0),n?t.setStencilFunction(514,i.stencilRef,255):t.setStencilFunction(516,255,255)}}const H={vtlBackground:ht,vtlFill:dt,vtlLine:mt,vtlCircle:pt,vtlSymbol:vt},yt={background:{"background.frag":`#ifdef PATTERN
uniform lowp float u_opacity;
uniform lowp sampler2D u_texture;
varying mediump vec4 v_tlbr;
varying mediump vec2 v_tileTextureCoord;
#else
uniform lowp vec4 u_color;
#endif
void main() {
#ifdef PATTERN
mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);
mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);
lowp vec4 color = texture2D(u_texture, samplePos);
gl_FragColor = u_opacity * color;
#else
gl_FragColor = u_color;
#endif
}`,"background.vert":`precision mediump float;
attribute vec2 a_pos;
uniform highp mat3 u_dvsMat3;
uniform mediump float u_coord_range;
uniform mediump float u_depth;
#ifdef PATTERN
uniform mediump mat3 u_pattern_matrix;
varying mediump vec2 v_tileTextureCoord;
uniform mediump vec4 u_tlbr;
uniform mediump vec2 u_mosaicSize;
varying mediump vec4 v_tlbr;
#endif
void main() {
gl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);
#ifdef PATTERN
v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;
v_tlbr             = u_tlbr / u_mosaicSize.xyxy;
#endif
}`},circle:{"circle.frag":`precision lowp float;
varying lowp vec4 v_color;
varying lowp vec4 v_stroke_color;
varying mediump float v_blur;
varying mediump float v_stroke_width;
varying mediump float v_radius;
varying mediump vec2 v_offset;
void main()
{
mediump float dist = length(v_offset);
mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);
lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));
gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);
}`,"circle.vert":`precision mediump float;
attribute vec2 a_pos;
#pragma header
varying lowp vec4 v_color;
varying lowp vec4 v_stroke_color;
varying mediump float v_blur;
varying mediump float v_stroke_width;
varying mediump float v_radius;
varying mediump vec2 v_offset;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump vec2 u_circleTranslation;
uniform mediump float u_depth;
uniform mediump float u_antialiasingWidth;
void main()
{
#pragma main
v_color = color * opacity;
v_stroke_color = stroke_color * stroke_opacity;
v_stroke_width = stroke_width;
v_radius = radius;
v_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));
mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);
v_offset = offset;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},fill:{"fill.frag":`precision lowp float;
#ifdef PATTERN
uniform lowp sampler2D u_texture;
varying mediump vec2 v_tileTextureCoord;
varying mediump vec4 v_tlbr;
#endif
varying lowp vec4 v_color;
vec4 mixColors(vec4 color1, vec4 color2) {
float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);
vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);
return vec4(compositeColor, compositeAlpha);
}
void main()
{
#ifdef PATTERN
mediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);
mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);
lowp vec4 color = texture2D(u_texture, samplePos);
gl_FragColor = v_color[3] * color;
#else
gl_FragColor = v_color;
#endif
}`,"fill.vert":`precision mediump float;
attribute vec2 a_pos;
#pragma header
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump float u_depth;
uniform mediump vec2 u_fillTranslation;
#ifdef PATTERN
#include <util/util.glsl>
uniform mediump vec2 u_mosaicSize;
uniform mediump float u_patternFactor;
varying mediump vec2 v_tileTextureCoord;
varying mediump vec4 v_tlbr;
#endif
varying lowp vec4 v_color;
void main()
{
#pragma main
v_color = color * opacity;
#ifdef PATTERN
float patternWidth = nextPOT(tlbr.z - tlbr.x);
float patternHeight = nextPOT(tlbr.w - tlbr.y);
float scaleX = 1.0 / (patternWidth * u_patternFactor);
float scaleY = 1.0 / (patternHeight * u_patternFactor);
mat3 patterMat = mat3(scaleX, 0.0,    0.0,
0.0,    -scaleY, 0.0,
0.0,    0.0,    1.0);
v_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;
v_tlbr             = tlbr / u_mosaicSize.xyxy;
#endif
vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},icon:{"icon.frag":`precision mediump float;
uniform lowp sampler2D u_texture;
#ifdef SDF
uniform lowp vec4 u_color;
uniform lowp vec4 u_outlineColor;
#endif
uniform highp int u_isStencilPass;
varying mediump vec2 v_tex;
varying lowp float v_opacity;
varying mediump vec2 v_size;
varying lowp vec4 v_color;
#ifdef SDF
varying mediump flaot v_halo_width;
#endif
const float alphaCutoff = 1.0 / 255.5;
#include <util/encoding.glsl>
vec4 mixColors(vec4 color1, vec4 color2) {
float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);
vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);
return vec4(compositeColor, compositeAlpha);
}
void main()
{
#ifdef SDF
lowp vec4 fillPixelColor = v_color;
float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;
const float softEdgeRatio = 0.248062016;
float size = max(v_size.x, v_size.y);
float dist = d * softEdgeRatio * size;
fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);
if (v_halo_width > 0.25) {
lowp vec4 outlinePixelColor = u_outlineColor;
const float outlineLimitRatio = (16.0 / 86.0);
float clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));
outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);
gl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);
}
else {
gl_FragColor = v_opacity * fillPixelColor;
}
#else
lowp vec4 texColor = texture2D(u_texture, v_tex);
if (u_isStencilPass == 1 && texColor.a < alphaCutoff) {
discard;
}
gl_FragColor = v_opacity * texColor;
#endif
}`,"icon.vert":`attribute vec2 a_pos;
attribute vec2 a_vertexOffset;
attribute vec4 a_texAngleRange;
attribute vec4 a_levelInfo;
attribute float a_opacityInfo;
#pragma header
varying lowp vec4 v_color;
#ifdef SDF
varying mediump float v_halo_width;
#endif
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump vec2 u_iconTranslation;
uniform vec2 u_mosaicSize;
uniform mediump float u_depth;
uniform mediump float u_mapRotation;
uniform mediump float u_level;
uniform lowp float u_keepUpright;
uniform mediump float u_fadeDuration;
varying mediump vec2 v_tex;
varying lowp float v_opacity;
varying mediump vec2 v_size;
const float C_OFFSET_PRECISION = 1.0 / 8.0;
const float C_256_TO_RAD = 3.14159265359 / 128.0;
const float C_DEG_TO_RAD = 3.14159265359 / 180.0;
const float tileCoordRatio = 1.0 / 8.0;
uniform highp float u_time;
void main()
{
#pragma main
v_color = color;
v_opacity = opacity;
#ifdef SDF
v_halo_width = halo_width;
#endif
float modded = mod(a_opacityInfo, 128.0);
float targetOpacity = (a_opacityInfo - modded) / 128.0;
float startOpacity = modded / 127.0;
float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);
v_opacity *= interpolatedOpacity;
mediump float a_angle         = a_levelInfo[1];
mediump float a_minLevel      = a_levelInfo[2];
mediump float a_maxLevel      = a_levelInfo[3];
mediump vec2 a_tex            = a_texAngleRange.xy;
mediump float delta_z = 0.0;
mediump float rotated = mod(a_angle + u_mapRotation, 256.0);
delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));
delta_z += 1.0 - step(a_minLevel, u_level);
delta_z += step(a_maxLevel, u_level);
delta_z += step(v_opacity, 0.0);
vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;
v_size = abs(offset);
#ifdef SDF
offset = (120.0 / 86.0) * offset;
#endif
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);
v_tex = a_tex.xy / u_mosaicSize;
}`},line:{"line.frag":`precision lowp float;
varying mediump vec2 v_normal;
varying highp float v_accumulatedDistance;
varying mediump float v_lineHalfWidth;
varying lowp vec4 v_color;
varying mediump float v_blur;
#if defined (PATTERN) || defined(SDF)
varying mediump vec4 v_tlbr;
varying mediump vec2 v_patternSize;
varying mediump float v_widthRatio;
uniform sampler2D u_texture;
uniform mediump float u_antialiasing;
#endif
#ifdef SDF
#include <util/encoding.glsl>
#endif
void main()
{
mediump float fragDist = length(v_normal) * v_lineHalfWidth;
lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);
#ifdef PATTERN
mediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));
mediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);
mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));
lowp vec4 color = texture2D(u_texture, texCoord);
gl_FragColor = alpha * v_color[3] * color;
#elif defined(SDF)
mediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));
mediump float relativeTexY =  0.5 + 0.25 * v_normal.y;
mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));
mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;
float dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);
gl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;
#else
gl_FragColor = alpha * v_color;
#endif
}`,"line.vert":`precision mediump float;
attribute vec2 a_pos;
attribute vec4 a_extrude_offset;
attribute vec4 a_dir_normal;
attribute vec2 a_accumulatedDistance;
#pragma header
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump float u_zoomFactor;
uniform mediump vec2 u_lineTranslation;
uniform mediump float u_antialiasing;
uniform mediump float u_depth;
varying mediump vec2 v_normal;
varying highp float v_accumulatedDistance;
const float scale = 1.0 / 31.0;
const mediump float tileCoordRatio = 8.0;
#if defined (SDF)
const mediump float sdfPatternHalfWidth = 15.5;
#endif
#if defined (PATTERN) || defined(SDF)
uniform mediump vec2 u_mosaicSize;
varying mediump vec4 v_tlbr;
varying mediump vec2 v_patternSize;
varying mediump float v_widthRatio;
#endif
varying lowp vec4 v_color;
varying mediump float v_lineHalfWidth;
varying mediump float v_blur;
void main()
{
#pragma main
v_color = color * opacity;
v_blur = blur + u_antialiasing;
v_normal = a_dir_normal.zw * scale;
#if defined (PATTERN) || defined(SDF)
v_tlbr          = tlbr / u_mosaicSize.xyxy;
v_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);
#if defined (PATTERN)
v_widthRatio = width / v_patternSize.y;
#else
v_widthRatio = width / sdfPatternHalfWidth / 2.0;
#endif
#endif
v_lineHalfWidth = (width + u_antialiasing) * 0.5;
mediump vec2 dir = a_dir_normal.xy * scale;
mediump vec2 offset_ = a_extrude_offset.zw * scale * offset;
mediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
#if defined (PATTERN) || defined(SDF)
v_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);
#endif
}`},outline:{"outline.frag":`varying lowp vec4 v_color;
varying mediump vec2 v_normal;
void main()
{
lowp float dist = abs(v_normal.y);
lowp float alpha = smoothstep(1.0, 0.0, dist);
gl_FragColor = alpha * v_color;
}`,"outline.vert":`attribute vec2 a_pos;
attribute vec2 a_offset;
attribute vec2 a_xnormal;
#pragma header
varying lowp vec4 v_color;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform mediump vec2 u_fillTranslation;
uniform mediump float u_depth;
uniform mediump float u_outline_width;
varying lowp vec2 v_normal;
const float scale = 1.0 / 15.0;
void main()
{
#pragma main
v_color = color * opacity;
v_normal = a_xnormal;
mediump vec2 dist = u_outline_width * scale * a_offset;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth, 1.0);
}`},text:{"text.frag":`uniform lowp sampler2D u_texture;
varying lowp vec2 v_tex;
varying lowp vec4 v_color;
varying mediump float v_edgeWidth;
varying mediump float v_edgeDistance;
void main()
{
lowp float dist = texture2D(u_texture, v_tex).a;
mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);
gl_FragColor = alpha * v_color;
}`,"text.vert":`attribute vec2 a_pos;
attribute vec2 a_vertexOffset;
attribute vec4 a_texAngleRange;
attribute vec4 a_levelInfo;
attribute float a_opacityInfo;
#pragma header
varying lowp vec4 v_color;
uniform highp mat3 u_dvsMat3;
uniform highp mat3 u_displayMat3;
uniform highp mat3 u_displayViewMat3;
uniform mediump vec2 u_textTranslation;
uniform vec2 u_mosaicSize;
uniform mediump float u_depth;
uniform mediump float u_mapRotation;
uniform mediump float u_level;
uniform lowp float u_keepUpright;
uniform mediump float u_fadeDuration;
varying lowp vec2 v_tex;
const float offsetPrecision = 1.0 / 8.0;
const mediump float edgePos = 0.75;
uniform mediump float u_antialiasingWidth;
varying mediump float v_edgeDistance;
varying mediump float v_edgeWidth;
uniform lowp float u_halo;
const float sdfFontScale = 1.0 / 24.0;
const float sdfPixel = 3.0;
uniform highp float u_time;
void main()
{
#pragma main
if (u_halo > 0.5)
{
v_color = halo_color * opacity;
halo_width *= sdfPixel;
halo_blur *= sdfPixel;
}
else
{
v_color = color * opacity;
halo_width = 0.0;
halo_blur = 0.0;
}
float modded = mod(a_opacityInfo, 128.0);
float targetOpacity = (a_opacityInfo - modded) / 128.0;
float startOpacity = modded / 127.0;
float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);
v_color *= interpolatedOpacity;
mediump float a_angle       = a_levelInfo[1];
mediump float a_minLevel    = a_levelInfo[2];
mediump float a_maxLevel    = a_levelInfo[3];
mediump vec2 a_tex          = a_texAngleRange.xy;
mediump float a_visMinAngle    = a_texAngleRange.z;
mediump float a_visMaxAngle    = a_texAngleRange.w;
mediump float delta_z = 0.0;
mediump float angle = mod(a_angle + u_mapRotation, 256.0);
if (a_visMinAngle < a_visMaxAngle)
{
delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));
}
else
{
delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));
}
delta_z += 1.0 - step(a_minLevel, u_level);
delta_z += step(a_maxLevel, u_level);
delta_z += step(v_color[3], 0.0);
v_tex = a_tex.xy / u_mosaicSize;
v_edgeDistance = edgePos - halo_width / size;
v_edgeWidth = (u_antialiasingWidth + halo_blur) / size;
mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);
gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);
}`},util:{"encoding.glsl":`const vec4 rgba2float_factors = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, rgba2float_factors);
}`,"util.glsl":`float nextPOT(in float x) {
return pow(2.0, ceil(log2(abs(x))));
}`}};let xt=class{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,i=new Map){if(i.has(e))return i.get(e);const t=this._read(e);if(!t)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let a=n.exec(t);const o=[];for(;a!=null;)o.push({path:a[1],start:a.index,length:a[0].length}),a=n.exec(t);let r=0,s="";return o.forEach(l=>{s+=t.slice(r,l.start),s+=i.has(l.path)?"":this._resolve(l.path,i),r=l.start+l.length}),s+=t.slice(r),i.set(e,s),s}_read(e){return this._readFile(e)}};function wt(c){let e=yt;return c.split("/").forEach(i=>{e&&(e=e[i])}),e}const St=new xt(wt);function E(c){return St.resolveIncludes(c)}function bt(c){const{options:e,value:i}=c;return typeof e[i]=="number"}function j(c){let e="";for(const i in c){const t=c[i];if(typeof t=="boolean")t&&(e+=`#define ${i}
`);else if(typeof t=="number")e+=`#define ${i} ${t.toFixed()}
`;else if(typeof t=="object")if(bt(t)){const{value:n,options:a,namespace:o}=t,r=o?`${o}_`:"";for(const s in a)e+=`#define ${r}${s} ${a[s].toFixed()}
`;e+=`#define ${i} ${r}${n}
`}else{const n=t.options;let a=0;for(const o in n)e+=`#define ${n[o]} ${(a++).toFixed()}
`;e+=`#define ${i} ${n[t.value]}
`}}return e}const me=c=>j({PATTERN:c.pattern}),Mt={shaders:c=>({vertexShader:me(c)+E("background/background.vert"),fragmentShader:me(c)+E("background/background.frag")})},Pt={shaders:c=>({vertexShader:E("circle/circle.vert"),fragmentShader:E("circle/circle.frag")})},_e=c=>j({PATTERN:c.pattern}),Tt={shaders:c=>({vertexShader:_e(c)+E("fill/fill.vert"),fragmentShader:_e(c)+E("fill/fill.frag")})},Dt={shaders:c=>({vertexShader:E("outline/outline.vert"),fragmentShader:E("outline/outline.frag")})},fe=c=>j({SDF:c.sdf}),Rt={shaders:c=>({vertexShader:fe(c)+E("icon/icon.vert"),fragmentShader:fe(c)+E("icon/icon.frag")})},ge=c=>j({PATTERN:c.pattern,SDF:c.sdf}),Ct={shaders:c=>({vertexShader:ge(c)+E("line/line.vert"),fragmentShader:ge(c)+E("line/line.frag")})},It={shaders:c=>({vertexShader:E("text/text.vert"),fragmentShader:E("text/text.frag")})};class Et{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,i,t){const n=i.key<<3|this._getMaterialOptionsValue(i.type,t);if(this._programByKey.has(n))return this._programByKey.get(n);const a=this._getProgramTemplate(i.type),{shaders:o}=a,{vertexShader:r,fragmentShader:s}=o(t),l=i.getShaderHeader(),u=i.getShaderMain(),w=r.replace("#pragma header",l).replace("#pragma main",u),m=e.programCache.acquire(w,s,i.getAttributeLocations());return this._programByKey.set(n,m),m}_getMaterialOptionsValue(e,i){switch(e){case 0:return(i.pattern?1:0)<<1;case 1:return(i.pattern?1:0)<<1;case 2:case 5:case 6:default:return 0;case 3:{const t=i;return(t.sdf?1:0)<<2|(t.pattern?1:0)<<1}case 4:return(i.sdf?1:0)<<1}}_getProgramTemplate(e){switch(e){case 0:return Mt;case 5:return Pt;case 1:return Tt;case 4:return Rt;case 3:return Ct;case 2:return Dt;case 6:return It;default:return null}}}const W=1e-6;class ve{constructor(e,i){this.spriteMosaic=e,this.glyphMosaic=i,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new Et}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=Z(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,i,t){const n=t.layers;e.renderPass="translucent";let a=this._brushCache.vtlSymbol;a==null&&(a=new H.vtlSymbol,this._brushCache.vtlSymbol=a),$[0]=i;for(let o=0;o<n.length;o++){const r=n[o];if(r.type!==3)continue;const s=r.getLayoutProperty("visibility");if(s&&s.getValue()===1)continue;const l=e.displayLevel;r.minzoom!==void 0&&r.minzoom>l+W||r.maxzoom!==void 0&&r.maxzoom<=l-W||(e.styleLayerUID=r.uid,e.styleLayer=r,a.drawMany(e,$))}$[0]=null}drawBackground(e,i,t){if(t.backgroundBucketIds.length===0)return;const{context:n,displayLevel:a,requiredLevel:o}=e;i.key.level=o,n.setBlendingEnabled(!0),n.setDepthTestEnabled(!1),n.setStencilTestEnabled(!1),e.renderPass="background";let r=this._brushCache.vtlBackground;r==null&&(r=new H.vtlBackground,this._brushCache.vtlBackground=r),$[0]=i,t.backgroundBucketIds.forEach(s=>{const l=t.getLayerById(s);if(l.type!==0)return;const u=l.getLayoutProperty("visibility");u&&u.getValue()===1||l.minzoom!==void 0&&l.minzoom>a+W||l.maxzoom!==void 0&&l.maxzoom<=a-W||(e.styleLayerUID=l.uid,e.styleLayer=l,r.drawMany(e,$))}),$[0]=null}drawTile(e,i,t,n){const{context:a}=e,o=t.layers;a.setBlendingEnabled(!1),a.setDepthTestEnabled(!0),a.setDepthWriteEnabled(!0),a.setDepthFunction(515);const r=o.filter(s=>n!=null&&n!==s.type||!i.layerData.has(s.uid)?!1:s.getLayoutProperty("visibility")?.getValue()!==1);e.renderPass="opaque";for(let s=r.length-1;s>=0;--s)this._renderStyleLayer(r[s],e,i);a.setDepthWriteEnabled(!1),a.setBlendingEnabled(!0),a.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent",r.forEach(s=>this._renderStyleLayer(s,e,i)),a.setDepthTestEnabled(!1),a.bindVAO(null)}_renderStyleLayer(e,i,t){const{renderPass:n}=i;let a;switch(e.type){case 0:if(n!=="background")return;a=this._brushCache.vtlBackground,a||(a=new H.vtlBackground,this._brushCache.vtlBackground=a);break;case 1:if(n!=="opaque"&&i.renderPass!=="translucent")return;a=this._brushCache.vtlFill,a==null&&(a=new H.vtlFill,this._brushCache.vtlFill=a);break;case 2:if(n!=="translucent")return;a=this._brushCache.vtlLine,a==null&&(a=new H.vtlLine,this._brushCache.vtlLine=a);break;case 4:if(n!=="translucent")return;a=this._brushCache.vtlCircle,a==null&&(a=new H.vtlCircle,this._brushCache.vtlCircle=a);break;case 3:if(n!=="translucent")return;a=this._brushCache.vtlSymbol,a==null&&(a=new H.vtlSymbol,this._brushCache.vtlSymbol=a)}const{displayLevel:o}=i,{minzoom:r,maxzoom:s}=e;if(r!==void 0&&r>o+W||s!==void 0&&s<=o-W)return;const{context:l}=i;l.setStencilTestEnabled(!1),l.setStencilWriteMask(0),i.styleLayerUID=e.uid,i.styleLayer=e,$[0]=t,a.drawMany(i,$),$[0]=null}}const $=[null];let z=class extends it(tt(at)){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=ee("disable-feature:vtl-level-shift")?0:1}initialize(){if(this.layer.fullExtent==null)return void this.addResolvingPromise(Promise.reject(new Ee("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:c,spatialReference:e,state:i,viewingMode:t}=this.view,n=t==="local"&&!Be(e)||We.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),a=this._getTileInfoSupportError(n,this.layer.fullExtent);if(a!=null)return this.addResolvingPromise(Promise.reject(a));const o=ze(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const p=c.tilingScheme,y=p.pixelSize,P=y===256?1:2,S=c.spatialReference?.isGeographic&&y===256?1:0,g=c.spatialReference?.isGeographic||y!==256?0:1;let b;this.schemaHelper=new nt(P,S,this.levelShift+g),b=y===256||y===512?this.layer.tileInfo.getCompatibleForVTL(y):this.layer.tileInfo;const d=this._getTileInfoCompatibilityError(b,p);if(d)throw d;this.tileInfo=b});this._tileHandlerController=new AbortController;const r=this.view.resourceController;this._memCache=r.memoryController.newCache(`vtl-${this.layer.uid}`,p=>p.release()),this.addHandles(ke(()=>this.view.qualitySettings.memoryLimit,p=>this._memCache.maxSize=Math.ceil(p/10*1048576),Ae));const s=new se(this.layer.currentStyleInfo.style);this._tileHandler=new he(this.layer,s,i.contentPixelRatio,this._memCache);const l=this._tileHandlerController.signal,u=Ut(r),w=this._tileHandler.start({signal:l,schedule:u}),m=this._tileHandler.spriteMosaic;m.then(p=>{!Ue(l)&&this._tileHandler&&(this.painter=new ve(p,this._tileHandler.glyphMosaic))}),w.then(()=>this._tileHandlerController=null);const x=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const p=this.layer.currentStyleInfo.style,y=this.view.state?.contentPixelRatio??1,P=new se(p),S=new he(this.layer,P,y,this._memCache),g=S.start({signal:this._tileHandlerController.signal,schedule:u}),b=S.spriteMosaic;g.then(()=>this._tileHandlerController=null),this._updatingHandles.addPromise(Promise.all([g,b]).then(([,d])=>{const h=this._tileHandler,_=this.painter;this.painter=new ve(d,S.glyphMosaic),this._tileHandler=S,this.emit("data-changed"),h.destroy(),_&&_.dispose()}))};this._updatingHandles.add(()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio}),x),this.addHandles([this.layer.on("paint-change",()=>this.emit("data-changed")),this.layer.on("style-layer-change",x),this.layer.on("delete-style-layer",x),this.layer.on("spriteSource-change",()=>this.emit("data-changed")),this.layer.on("layout-change",()=>this.emit("data-changed")),this.layer.on("style-layer-visibility-change",()=>this.emit("data-changed"))]);const v=Promise.all([o,w,m]);this.addResolvingPromise(v)}destroy(){this.painter=Z(this.painter),this._tileHandlerController=ye(this._tileHandlerController),this._tileHandler=te(this._tileHandler),this._memCache=te(this._memCache)}get contentZoom(){return ee("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const c=this.tileInfo.lods,e=this.layer.minScale||c[0].scale,i=this.layer.maxScale||c[c.length-1].scale,t=this.levelRangeFromScaleRange(e,i);return this.layer.maxScale?t.maxLevel++:t.maxLevel+=this.levelShift,t}get dataScaleRange(){const c=this.tileInfo.lods;return{minScale:c[0].scale,maxScale:c[c.length-1].scale}}get dataLevelRange(){const{minScale:c,maxScale:e}=this.dataScaleRange,i=this.levelRangeFromScaleRange(c,e);return i.minLevel===1&&this.tileInfo.size[0]===256&&(i.minLevel=0),i.maxLevel+=this.levelShift,i}async fetchTile(c,e){const i=this.schemaHelper.getLevelRowColumn(c);return this._tileHandler.getVectorTile(i,e)}get hasVisibleFeatures(){return!0}};V([O()],z.prototype,"layer",void 0),V([O()],z.prototype,"levelShift",void 0),V([O()],z.prototype,"contentZoom",null),V([O()],z.prototype,"displayLevelRange",null),V([O()],z.prototype,"tileInfo",void 0),V([O()],z.prototype,"dataScaleRange",null),V([O()],z.prototype,"dataLevelRange",null),V([O()],z.prototype,"updatingProgressValue",void 0),z=V([Le("esri.views.3d.layers.VectorTileLayerView3D")],z);const Hn=z;function Ut(c){return e=>c.immediate.schedule(e)}export{Hn as default};
