import{r as c}from"./CollectionFlattener-D6h2Fkvj-WVl2BXw-.js";import{Y as d,H as u,v as l,N as b,G as p}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{R as f,C as m}from"./collectionUtils-jDyktm0P-BDP2Oq99.js";import{o as v}from"./Layer-DZvC7bne-D3VLDrab.js";function w(n){return new c({getCollections:()=>[n.tables,n.layers],getChildrenFunction:o=>{const a=[];return"tables"in o&&a.push(o.tables),"layers"in o&&a.push(o.layers),a},itemFilterFunction:o=>{const a=o.parent;return!!a&&"tables"in a&&a.tables.includes(o)}})}function A(n){for(const o of n.values())o?.destroy();n.clear()}function y(n,o,a){let e,t;if(n)for(let r=0,i=n.length;r<i;r++){if(e=n.at(r),e?.[o]===a)return e;if(e?.type==="group"&&(t=y(e.layers,o,a),t))return t}}const F=n=>{const o=n;let a=class extends o{constructor(...e){super(...e),this.layers=new f;const t=s=>{s.parent&&s.removeFromParent()},r=s=>{s.parent=this,this.layerAdded(s),s.type!=="elevation"&&s.type!=="base-elevation"||l.getLogger(this).error(`Layer 'title:${s.title}, id:${s.id}' of type '${s.type}' is not supported as an operational layer and will therefore be ignored.`)},i=s=>{s.parent=null,this.layerRemoved(s)};this.addHandles([this.layers.on("before-add",s=>{if(s.item===this)return s.preventDefault(),void l.getLogger(this).error("#add()","Cannot add layer to itself.");t(s.item)}),this.layers.on("after-add",s=>r(s.item)),this.layers.on("after-remove",s=>i(s.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}removeChildLayer(e){this.layers.remove(e),super.removeChildLayer?.(e)}set layers(e){this._set("layers",m(e,this._get("layers")))}add(e,t){const r=this.layers;if(t=r.getNextIndex(t),e instanceof v){const i=e;i.parent===this?this.reorder(i,t):r.add(i,t)}else b(e)?e.then(i=>{this.destroyed||this.add(i,t)}):l.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const r=this.layers;let i=r.getNextIndex(t);e.slice().forEach(s=>{s.parent!==this?(r.add(s,i),i+=1):this.reorder(s,i)})}findLayerById(e){return y(this.layers,"id",e)}findLayerByUid(e){return y(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return d([u()],a.prototype,"layers",null),a=d([p("esri.support.LayersMixin")],a),a},g=new Set(["feature","subtype-group"]);function h(n,o,a){if(n)for(let e=0,t=n.length;e<t;e++){const r=n.at(e);if(r[o]===a)return r;if(r?.type==="group"){const i=h(r.tables,o,a);if(i)return i}}}const M=n=>{const o=n;let a=class extends o{constructor(...e){super(...e),this.tables=new f,this.addHandles([this.tables.on("after-add",t=>{const r=t.item;r.parent&&r.parent!==this&&r.removeFromParent(),r.parent=this,g.has(r.type)||l.getLogger(this).error(`Layer 'title:${r.title}, id:${r.id}' of type '${r.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",t=>{t.item.parent=null})])}destroy(){const e=this.tables.toArray();for(const t of e)t.destroy();this.tables.destroy()}removeChildLayer(e){this.tables.remove(e),super.removeChildLayer?.(e)}set tables(e){this._set("tables",m(e,this._get("tables")))}findTableById(e){return h(this.tables,"id",e)}findTableByUid(e){return h(this.tables,"uid",e)}};return d([u()],a.prototype,"tables",null),a=d([p("esri.support.TablesMixin")],a),a};export{F as A,M as F,w as _,A as w};
