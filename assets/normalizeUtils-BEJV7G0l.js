import{h as _,s as k,i as B}from"./jsonMap-Bs3hmeCU.js";import{n as E}from"./Cyclical-BLSxUpe7.js";import{P as z}from"./Polygon-WlfMxvm8.js";import{y as F}from"./Polyline-CYNn9agI.js";import{X as J,H as O,I as K,a8 as U,ar as I,f as T,S as Q}from"./Point-CMHR1y9V.js";import{r as v,i as b,o as L,s as X}from"./normalizeUtilsCommon-DnSvD7ht.js";import{v as G,f as V}from"./jsonUtils-BIx2Bg38.js";import{f as Y}from"./utils-BrkeFJbU.js";import{r as Z,o as ee}from"./utils-DGvxRWBb.js";async function te(e,s,l,n){const t=Y(e),i=s[0].spatialReference,r={...n,responseType:"json",query:{...t.query,f:"json",sr:J(i),target:JSON.stringify({geometryType:G(s[0]),geometries:s}),cutter:JSON.stringify(l)}},o=await O(t.path+"/cut",r),{cutIndexes:c,geometries:u=[]}=o.data;return{cutIndexes:c,geometries:u.map(p=>{const x=V(p);return x.spatialReference=i,x})}}async function se(e,s,l){const n=typeof e=="string"?K(e):e,t=s[0].spatialReference,i=G(s[0]),r={...l,query:{...n.query,f:"json",sr:J(t),geometries:JSON.stringify(Z(s))}},{data:o}=await O(n.path+"/simplify",r);return ee(o.geometries,i,t)}const H=()=>B.getLogger("esri.geometry.support.normalizeUtils");function ne(e){return e.type==="polygon"}function oe(e){return e[0].type==="polygon"}function re(e){return e[0].type==="polyline"}function ie(e,s){if(!(e instanceof F||e instanceof z)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw H().error(t),new k("internal:geometry",t)}const l=L(e),n=[];for(const t of l){const i=[];n.push(i),i.push([t[0][0],t[0][1]]);for(let r=0;r<t.length-1;r++){const o=t[r][0],c=t[r][1],u=t[r+1][0],p=t[r+1][1],x=Math.sqrt((u-o)*(u-o)+(p-c)*(p-c)),h=(p-c)/x,d=(u-o)/x,g=x/s;if(g>1){for(let R=1;R<=g-1;R++){const A=R*s,f=d*A+o,a=h*A+c;i.push([f,a])}const M=(x+Math.floor(g-1)*s)/2,N=d*M+o,q=h*M+c;i.push([N,q])}i.push([u,p])}}return ne(e)?new z({rings:n,spatialReference:e.spatialReference}):new F({paths:n,spatialReference:e.spatialReference})}function W(e,s,l){if(s){const n=ie(e,1e6);e=Q(n,!0)}return l&&(e=X(e,l)),e}function C(e,s,l){if(Array.isArray(e)){const n=e[0];if(n>s){const t=b(n,s);e[0]=n+t*(-2*s)}else if(n<l){const t=b(n,l);e[0]=n+t*(-2*l)}}else{const n=e.x;if(n>s){const t=b(n,s);e=e.clone().offset(t*(-2*s),0)}else if(n<l){const t=b(n,l);e=e.clone().offset(t*(-2*l),0)}}return e}function fe(e,s){let l=-1;for(let n=0;n<s.cutIndexes.length;n++){const t=s.cutIndexes[n],i=s.geometries[n],r=L(i);for(let o=0;o<r.length;o++){const c=r[o];c.some(u=>{if(u[0]<180)return!0;{let p=0;for(let h=0;h<c.length;h++){const d=c[h][0];p=d>p?d:p}p=Number(p.toFixed(9));const x=-360*b(p,180);for(let h=0;h<c.length;h++){const d=i.getPoint(o,h);i.setPoint(o,h,d.clone().offset(x,0))}return!0}})}if(t===l){if(oe(e))for(const o of L(i))e[t]=e[t].addRing(o);else if(re(e))for(const o of L(i))e[t]=e[t].addPath(o)}else l=t,e[t]=i}return e}async function le(e,s,l){if(!Array.isArray(e))return le([e],s);s&&typeof s!="string"&&H().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:s?.url??_.geometryServiceUrl;let t,i,r,o,c,u,p,x,h=0;const d=[],g=[];for(const f of e)if(f!=null)if(t||(t=f.spatialReference,i=U(t),r=t.isWebMercator,u=r?102100:4326,o=v[u].maxX,c=v[u].minX,p=v[u].plus180Line,x=v[u].minus180Line),i)if(f.type==="mesh")g.push(f);else if(f.type==="point")g.push(C(f.clone(),o,c));else if(f.type==="multipoint"){const a=f.clone();a.points=a.points.map(y=>C(y,o,c)),g.push(a)}else if(f.type==="extent"){const a=f.clone()._normalize(!1,!1,i);g.push(a.rings?new z(a):a)}else if(f.extent){const a=f.extent,y=b(a.xmin,c)*(2*o);let $=y===0?f.clone():X(f.clone(),y);a.offset(y,0);let{xmin:w,xmax:m}=a;w=Number(w.toFixed(9)),m=Number(m.toFixed(9)),a.intersects(p)&&m!==o?(h=m>h?m:h,$=W($,r),d.push($),g.push("cut")):a.intersects(x)&&w!==c?(h=m*(2*o)>h?m*(2*o):h,$=W($,r,360),d.push($),g.push("cut")):g.push($)}else g.push(f.clone());else g.push(f);else g.push(f);let M=b(h,o),N=-90;const q=M,R=new F;for(;M>0;){const f=360*M-180;R.addPath([[f,N],[f,-1*N]]),N*=-1,M--}if(d.length>0&&q>0){const f=fe(d,await te(n,d,R,l)),a=[],y=[];for(let m=0;m<g.length;m++){const P=g[m];if(P!=="cut")y.push(P);else{const j=f.shift(),S=e[m];S!=null&&S.type==="polygon"&&S.rings&&S.rings.length>1&&j.rings.length>=S.rings.length?(a.push(j),y.push("simplify")):y.push(r?I(j):j)}}if(!a.length)return y;const $=await se(n,a,l),w=[];for(let m=0;m<y.length;m++){const P=y[m];P!=="simplify"?w.push(P):w.push(r?I($.shift()):$.shift())}return w}const A=[];for(let f=0;f<g.length;f++){const a=g[f];if(a!=="cut")A.push(a);else{const y=d.shift();A.push(r===!0?I(y):y)}}return A}function xe(e,s,l){const n=U(l);if(n==null)return e;const[t,i]=n.valid,r=2*i;let o=0,c=0;s>i?o=Math.ceil(Math.abs(s-i)/r):s<t&&(o=-Math.ceil(Math.abs(s-t)/r)),e>i?c=Math.ceil(Math.abs(e-i)/r):e<t&&(c=-Math.ceil(Math.abs(e-t)/r));let u=e+(o-c)*r;const p=u-s;return p>i?u-=r:p<t&&(u+=r),u}function D(e){const s=U(e);if(s==null)return null;const[l,n]=s.valid;return new E(l,n)}const $e=D(T.WGS84),Me=D(T.WebMercator);export{$e as A,Me as C,xe as L,le as P,D as U,ie as b};
