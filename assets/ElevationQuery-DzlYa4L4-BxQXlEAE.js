import{C as ce}from"./asyncUtils-w6KfWU41-HenJ0UOu.js";import{v as Y,I as x,F as B,ao as ue,al as S,J as K,Y as y,G as b,H as R}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{aj as fe,b as C,F as E,f as he}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{N as F,W as O}from"./projectionUtils-BGH_5_I3-BySNUA-B.js";import{N as pe,j as X,O as ee,y as me,w as de}from"./aaBoundingRect-CjwcS2F3-D7aII9DY.js";import{e as k}from"./TileKey-CXWFOqOI-CcilLir8.js";import{o as $,n as ye}from"./Polyline-CoiTLswR-BLagWJLS.js";import{J as we}from"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import"./index-CTl7hdrJ.js";import"./reader-DcGs6kKN-DHJfK-tm.js";import"./SimpleObservable-CvFyr0NA-DXpoMYph.js";import"./collectionUtils-jDyktm0P-ArdXNs6F.js";import"./Extent-CgDMOSRD-CU1qE5Kr.js";import"./Polygon-D6wEPb3W-CpL9Efjx.js";import"./mathUtils-PIGhLnI9-B1tKUlUb.js";let D=class extends we{queryElevation(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;switch(t.type){case"point":return xe(t,e,this);case"polyline":return ve(t,e,this);case"multipoint":return ge(t,e,this);default:return null}}projectIfRequired(t,e){if(t==null)return null;const n=t.spatialReference;if(n.equals(e))return t;const a=fe(t,e);return a||Y.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${e.wkid})`),a}};function xe(t,e,n){return t.hasZ=!0,t.z=n.elevationAt(e.x,e.y),t}function ve(t,e,n){d.spatialReference=e.spatialReference;const a=t.hasM&&!t.hasZ;for(let o=0;o<t.paths.length;o++){const l=t.paths[o],s=e.paths[o];for(let i=0;i<l.length;i++){const r=l[i],u=s[i];d.x=u[0],d.y=u[1],a&&(r[3]=r[2]),r[2]=n.elevationAt(d.x,d.y)}}return t.hasZ=!0,t}function ge(t,e,n){d.spatialReference=e.spatialReference;const a=t.hasM&&!t.hasZ;for(let o=0;o<t.points.length;o++){const l=t.points[o],s=e.points[o];d.x=s[0],d.y=s[1],a&&(l[3]=l[2]),l[2]=n.elevationAt(d.x,d.y)}return t.hasZ=!0,t}D=y([b("esri.layers.support.ElevationSampler")],D);const d=new C;class te{constructor(e,n){this.layer=e,this.parameters=n}}class Te extends te{constructor(e,n,a){super(e,a),this.outSpatialReference=n,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(n=>n.tile=null);else{const{tileInfo:n,tilemapCache:a}=this.layer,o=I(n,a)[e].level;this.geometry.coordinates.forEach(l=>l.tile=n.tileAt(o,l.x,l.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const n of this.geometry.coordinates)!n.elevationTile&&n.tile?.id&&(n.elevationTile=e[n.tile.id])}remapTiles(e){for(const n of this.geometry.coordinates){const a=n.tile?.id;n.tile=a?e[a]:null}}getTilesToFetch(){return ue(this.geometry.coordinates.filter(({tile:e,elevationTile:n})=>e?.id&&!n),(e,n)=>e.tile?.id===n.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(const n of this.geometry.coordinates)n.tile&&!n.elevationTile&&e(n.tile,()=>n.tile=null)}}class Re extends te{constructor(e,n,a,o){super(e,a),this.maskExtents=o,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=n.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,n){const a=this._maximumLodForRequests(n),o=Math.min(a,e);o<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(o)}_maximumLodForRequests(e){const{tileInfo:n,tilemapCache:a}=this.layer,o=I(n,a);if(!e)return o.length-1;const l=this.extent;if(l==null)return-1;for(let s=o.length-1;s>=0;s--){const i=o[s],r=i.resolution*n.size[0],u=i.resolution*n.size[1];if(Math.ceil(l.width/r)*Math.ceil(l.height/u)<=e)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const n of this._candidateTiles){const a=n.id&&e[n.id];a&&(this._fetchedCandidates.add(n),this.elevationTiles.push(a))}}remapTiles(e){this._candidateTiles=Q(this._candidateTiles.map(n=>e[n.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,n){const a=this._candidateTiles;this._candidateTiles=[],a.forEach(o=>{if(this._fetchedCandidates.has(o))return void n?.(o);let l=!1;e(o,()=>l=!0),l?n?.(o):this._candidateTiles.push(o)}),this._candidateTiles=Q(this._candidateTiles,n)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const n=this.extent;if(n==null)return;const{tileInfo:a,tilemapCache:o}=this.layer,l=I(a,o)[e],s=a.tileAt(l.level,n.xmin,n.ymin),i=s.extent,r=l.resolution*a.size[0],u=l.resolution*a.size[1],c=Math.ceil((n.xmax-i[0])/r),f=Math.ceil((n.ymax-i[1])/u);for(let m=0;m<f;m++)for(let h=0;h<c;h++){const v=new k(s.level,s.row-m,s.col+h);a.updateTileInfo(v),this._tileIsMasked(v)||this._candidateTiles.push(v)}}_tileIsMasked(e){return this.maskExtents?.some(n=>X(n,e.extent))??!1}}function L(t){return t?.tileInfo!=null}function I(t,e){const n=t.lods;if(L(e)){const{effectiveMinLOD:a,effectiveMaxLOD:o}=e;return n.filter(l=>l.level>=a&&l.level<=o)}return n}function Q(t,e){const n={},a=[];for(const l of t){const s=l.id;s&&!n[s]?(n[s]=l,a.push(l)):e?.(l)}const o=a.sort((l,s)=>l.level-s.level);return o.filter((l,s)=>{for(let i=0;i<s;i++){const r=o[i].extent;if(r&&X(r,l.extent))return e?.(l),!1}return!0})}let Ie=class{constructor(t,e){this.data=t,this.safeWidth=.99999999*(t.width-1),this.dx=(t.width-1)/(e[2]-e[0]),this.dy=(t.width-1)/(e[3]-e[1]),this.x0=e[0],this.y1=e[3]}};class ne{constructor(e,n=null){if(this.key=e,n!=null){const a=e.extent;this._samplerData=new Ie(n,a)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,n){if(this._samplerData==null)return;const{safeWidth:a,data:o,dx:l,dy:s,y1:i,x0:r}=this._samplerData,{width:u,values:c,noDataValue:f}=o,m=U(s*(i-n),0,a),h=U(l*(e-r),0,a),v=Math.floor(m),G=Math.floor(h),M=v*u+G,W=M+u,V=c[M],z=c[W],N=c[M+1],P=c[W+1];if(V!==f&&z!==f&&N!==f&&P!==f){const H=h-G,J=V+(N-V)*H;return J+(z+(P-z)*H-J)*(m-v)}}}function U(t,e,n){return t<e?e:t>n?n:t}class w{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const n=new w(this.geometry);return n.spatialReference=this.spatialReference,n.coordinates=e??this.coordinates.map(a=>a.clone()),n._exporter=this._exporter,n}async project(e,n){if(this.spatialReference.equals(e))return this.clone();await F([{source:this.spatialReference,dest:e}],{signal:n});const a=new $({spatialReference:this.spatialReference,points:this.coordinates.map(i=>[i.x,i.y])}),o=O(a,e);if(!o)return null;const l=this.coordinates.map((i,r)=>{const u=i.clone(),c=o.points[r];return u.x=c[0],u.y=c[1],u}),s=this.clone(l);return s.spatialReference=e,s}static fromGeometry(e){const n=new w(e);if(e instanceof w)return n.coordinates=e.coordinates.map(a=>a.clone()),n._exporter=(a,o)=>{const l=e.clone(a);return l.spatialReference=o,l},n;switch(e.type){case"point":{const a=e,{hasZ:o,hasM:l}=a;return n.coordinates=o&&l?[new p(a.x,a.y,a.z,a.m)]:o?[new p(a.x,a.y,a.z)]:l?[new p(a.x,a.y,null,a.m)]:[new p(a.x,a.y)],n._exporter=(s,i)=>e.hasM?new C(s[0].x,s[0].y,s[0].z,s[0].m,i):new C(s[0].x,s[0].y,s[0].z,i),n}case"multipoint":{const a=e,{hasZ:o,hasM:l}=a;return n.coordinates=o&&l?a.points.map(s=>new p(s[0],s[1],s[2],s[3])):o?a.points.map(s=>new p(s[0],s[1],s[2])):l?a.points.map(s=>new p(s[0],s[1],null,s[2])):a.points.map(s=>new p(s[0],s[1])),n._exporter=(s,i)=>e.hasM?new $({points:s.map(r=>[r.x,r.y,r.z??0,r.m??0]),hasZ:!0,hasM:!0,spatialReference:i}):new $({points:s.map(r=>[r.x,r.y,r.z??0]),spatialReference:i}),n}case"polyline":{const a=e,o=[],l=[],{hasZ:s,hasM:i}=e;let r=0;for(const u of a.paths)if(l.push([r,r+u.length]),r+=u.length,s&&i)for(const c of u)o.push(new p(c[0],c[1],c[2],c[3]));else if(s)for(const c of u)o.push(new p(c[0],c[1],c[2]));else if(i)for(const c of u)o.push(new p(c[0],c[1],null,c[2]));else for(const c of u)o.push(new p(c[0],c[1]));return n.coordinates=o,n._exporter=(u,c)=>{const f=e.hasM?u.map(h=>[h.x,h.y,h.z??0,h.m??0]):u.map(h=>[h.x,h.y,h.z??0]),m=l.map(h=>f.slice(h[0],h[1]));return new ye({paths:m,hasM:e.hasM,hasZ:!0,spatialReference:c})},n}}}}class p{constructor(e,n,a=null,o=null,l=null,s=null){this.x=e,this.y=n,this.z=a,this.m=o,this.tile=l,this.elevationTile=s}clone(){return new p(this.x,this.y,this.z,this.m)}}let T=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(t){const e=t.noDataValue,n="tiles"in t?t.tiles.map(o=>new g({tile:o,tileInfo:t.tileInfo,noDataValue:e})):t.samplers;super({noDataValue:e,samplers:n});const a=n[0];if(a){this.extent=a.extent.clone();const{min:o,max:l}=a.demResolution;this.demResolution={min:o,max:l};for(let s=1;s<n.length;s++){const i=n[s];this.extent.union(i.extent),this.demResolution.min=Math.min(this.demResolution.min,i.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,i.demResolution.max)}}else{const o="tileInfo"in t?t.tileInfo:null;this.extent=ee(me(),o?.spatialReference??he.WGS84),this.demResolution={min:0,max:0}}}elevationAt(t,e){let n;for(const a of this.samplers)if(a.containsAt(t,e)&&(n=a.elevationAt(t,e),n!==a.noDataValue))return n;return n??(Y.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${t}, ${e}) is outside of the sampler`),this.noDataValue)}};y([R({constructOnly:!0})],T.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],T.prototype,"samplers",void 0),T=y([b("esri.layers.support.TileElevationSampler")],T);let g=class extends D{get spatialReference(){return this.extent.spatialReference}constructor(t){super(t);const e=t.tile.key.extent;this.extent=ee(e,t.tileInfo.spatialReference),this.extent.zmin=t.tile.zmin,this.extent.zmax=t.tile.zmax;const n=E(t.tileInfo.spatialReference),a=t.tileInfo.lodAt(t.tile.key.level).resolution*n;this.demResolution={min:a,max:a}}contains(t){const e=this.projectIfRequired(t,this.spatialReference);return e!=null&&this.containsAt(e.x,e.y)}containsAt(t,e){return de(this.tile.key.extent,t,e)}elevationAt(t,e){return this.containsAt(t,e)?this.tile.sample(t,e)??this.noDataValue:this.noDataValue}};y([R({constructOnly:!0})],g.prototype,"tile",void 0),y([R({constructOnly:!0})],g.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],g.prototype,"tileInfo",void 0),g=y([b("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],g);async function De(t,e,n){if(t=n?.ignoreInvisibleLayers?t.filter(r=>r.visible):t.slice(),!t.length)throw new x(q,"Elevation queries require at least one elevation layer to fetch tiles from");const a=w.fromGeometry(e),o={..._,...n,returnSampleInfo:!0},l=t.pop(),s=await j(l,a,o),i=await se(t,s,o);return i.geometry=i.geometry.export(),n?.returnSampleInfo||delete i.sampleInfo,i}async function j(t,e,n){if(!t)throw new x(q,"Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof w)&&e.type!=="point"&&e.type!=="multipoint"&&e.type!=="polyline")throw new x("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const a={..._,...n},o=new Te(t,e.spatialReference,a),l=a.signal;return await t.load({signal:l}),await qe(o,e,l),await le(o,l),await A(o,l),Se(o),be(o,l)}async function Ee(t,e,n){if(t=Array.isArray(t)?t:[t],(t=n?.ignoreInvisibleLayers?t.filter(l=>l.visible):t.slice()).length===0)throw new x(q,"Elevation queries require at least one elevation layer to fetch tiles from");if(!e||e.type!=="extent")throw new x("elevation-query:invalid-extent","Invalid or undefined extent");const a={..._,...n,returnSampleInfo:!0},o=ae(t[t.length-1],e,a);return t.length===1?o:oe(t,e,await o,a)}async function ae(t,e,n,a){const o=n.signal;await t.load({signal:o});const l=e.spatialReference,s=t.tileInfo.spatialReference;l.equals(s)||(await F([{source:l,dest:s}],{signal:o}),e=O(e,s));const i=new Re(t,e,n,a);await le(i,o),await A(i,o);const r=i.elevationTiles,u=i.layer.tileInfo,c=i.parameters.noDataValue;return new T({noDataValue:c,tiles:r,tileInfo:u})}async function oe(t,e,n,a){if(t.pop(),!t.length)return n;const o=n.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>pe(r.extent)),l=await ae(t[t.length-1],e,a,o);if(l.samplers.length===0)return n;const s=n.samplers.concat(l.samplers),i=a.noDataValue;return oe(t,e,new T({samplers:s,noDataValue:i}),a)}async function se(t,e,n){const a=e.geometry.coordinates,o=e.sampleInfo;B(o);const l=new Array,s=new Array;for(let f=0;f<a.length;f++)o[f].demResolution<0&&t.length&&(l.push(a[f]),s.push(f));const i=t.pop();if(i==null||l.length===0)return e;const r=e.geometry.clone(l),u=await j(i,r,n),c=u.sampleInfo;if(!c)throw new Error("no sampleInfo");return s.forEach((f,m)=>{a[f].z=u.geometry.coordinates[m].z,o[f].demResolution=c[m].demResolution,o[f].source=c[m].source}),se(t,e,n)}async function le(t,e){t.type==="geometry"&&Me(t);const n=t.parameters.demResolution;if(typeof n=="number")ze(t,n);else if(n==="finest-contiguous")await _e(t,e);else{if(n!=="auto")throw new x("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${n}', expected a number, "finest-contiguous" or "auto"`);await Ae(t,e)}}async function _e(t,e){const{tileInfo:n,tilemapCache:a}=t.layer,o=Z(n,a,t.parameters.minDemResolution);await ie(t,o,e)}async function ie(t,e,n){const a=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const o=a.tilemapCache,l=t.getTilesToFetch();try{if(o&&!L(o))await S(Promise.all(l.map(s=>o.fetchAvailability(s.level,s.row,s.col,{signal:n}))),n);else if(await A(t,n),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new x("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){K(s),await ie(t,e-1,n)}}async function Ae(t,e){$e(t),Ce(t);const n=t.layer.tilemapCache;if(!n||L(n))return re(t,e);const a=t.getTilesToFetch(),o={},l=a.map(async s=>{const i=new k(0,0,0),r=await ce(n.fetchAvailabilityUpsample(s.level,s.row,s.col,i,{signal:e}));r.ok!==!1?s.id!=null&&(o[s.id]=i):K(r.error)});await S(Promise.all(l),e),t.remapTiles(o)}async function re(t,e){const n=t.layer.tileInfo;await A(t,e);let a=!1;t.forEachTileToFetch((o,l)=>{n.upsampleTile(o)?a=!0:l()}),a&&await re(t,e)}function Z(t,e,n=0){const a=I(t,e);let o=a.length-1;if(n>0){const l=n/E(t.spatialReference),s=a.findIndex(i=>i.resolution<l);s===0?o=0:s>0&&(o=s-1)}return o}const _={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function qe(t,e,n){let a;const o=t.layer.tileInfo.spatialReference;if(e instanceof w?a=await e.project(o,n):(await F([{source:e.spatialReference,dest:o}],{signal:n}),a=O(e,o)),!a)throw new x("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${o.wkid}'`);t.geometry=w.fromGeometry(a)}function Me(t){if(t.layer.fullExtent==null)return;const e=new ne(new k(-1,-1,-1));e.sample=()=>t.parameters.noDataValue,t.outsideExtentTile=e;const n=t.layer.fullExtent;t.geometry.coordinates.forEach(a=>{const o=a.x,l=a.y;(o<n.xmin||o>n.xmax||l<n.ymin||l>n.ymax)&&(a.elevationTile=e)})}function Ve(t,e){const{tileInfo:n,tilemapCache:a}=t.layer,o=e/E(n.spatialReference),l=I(n,a);let s=l[0],i=0;for(let r=1;r<l.length;r++){const u=l[r];Math.abs(u.resolution-o)<Math.abs(s.resolution-o)&&(s=u,i=r)}return i}function ze(t,e){const n=Ve(t,e);t.selectTilesAtLOD(n)}function $e(t){const{tileInfo:e,tilemapCache:n}=t.layer,a=Z(e,n,t.parameters.minDemResolution);t.selectTilesAtLOD(a,t.parameters.maximumAutoTileRequests)}async function A(t,e){const n=t.getTilesToFetch(),a={},o=t.parameters.cache,l=t.parameters.noDataValue,s={noDataValue:l,signal:e},i=n.map(async r=>{if(r.id==null)return;const u=`${t.layer.uid}:${r.id}:${l}`,c=o?.get(u),f=c??await t.layer.fetchTile(r.level,r.row,r.col,s);o?.put(u,f),a[r.id]=new ne(r,f)});await S(Promise.allSettled(i),e),t.populateElevationTiles(a)}function Ce(t){const e=t.layer.tileInfo;let n=0;const a={},o=i=>{i.id!=null&&(i.id in a?a[i.id]++:(a[i.id]=1,n++))},l=i=>{if(i.id==null)return;const r=a[i.id];r===1?(delete a[i.id],n--):a[i.id]=r-1};t.forEachTileToFetch(o,l);let s=!0;for(;s&&(s=!1,t.forEachTileToFetch(i=>{n<=t.parameters.maximumAutoTileRequests||(l(i),e.upsampleTile(i)&&(s=!0),o(i))},l),s););}function Se(t){t.geometry.coordinates.forEach(e=>{const n=e.elevationTile;let a=t.parameters.noDataValue;if(n){const o=n.sample(e.x,e.y);o==null?e.elevationTile=null:a=o}e.z=a})}async function be(t,e){const n=await t.geometry.project(t.outSpatialReference,e);B(n);const a={geometry:n.export(),noDataValue:t.parameters.noDataValue};return t.parameters.returnSampleInfo&&(a.sampleInfo=Fe(t)),t.geometry.coordinates.forEach(o=>{o.tile=null,o.elevationTile=null}),a}function Fe(t){const e=t.layer.tileInfo,n=E(e.spatialReference);return t.geometry.coordinates.map(a=>{let o=-1;return a.elevationTile&&a.elevationTile!==t.outsideExtentTile&&(o=e.lodAt(a.elevationTile.key.level).resolution*n),{demResolution:o,source:o===-1?void 0:t.layer}})}const q="elevation-query:invalid-layer",Ke=Object.freeze(Object.defineProperty({__proto__:null,InvalidLayerError:q,createSampler:Ee,defaultOptions:_,getFinestLodIndex:Z,query:j,queryAll:De},Symbol.toStringTag,{value:"Module"}));export{Ke as E,q as G,D as i,w as r,Ie as t};
