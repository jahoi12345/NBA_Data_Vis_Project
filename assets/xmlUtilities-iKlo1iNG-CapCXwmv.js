const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-Bz1TMN0X-C8v09yyy.js","assets/jsonMap-Bs3hmeCU-Cusd0Fmz.js","assets/mathUtils-PIGhLnI9-B1tKUlUb.js","assets/Point-BfTTZoMu-DeJwQYfh.js","assets/index-B0z_nLWi.js","assets/index-Cv2ko1Ob.css","assets/reader-DcGs6kKN-DHJfK-tm.js","assets/Point2D-CMz7woHH-BVbGGL7p.js","assets/ProjectionTransformation-PJc9H7Gq-Rbz84pUM.js","assets/Envelope2D-mFnl8dXR-MYac-bfa.js","assets/Transformation2D-CrydmBdC-D4jE8w-_.js","assets/SimpleGeometryCursor-B92kdZ15-B1Z6elF7.js","assets/OperatorDefinitions-DP7_WWTp-DP7_WWTp.js","assets/Extent-CgDMOSRD-Bod5LY6s.js","assets/Polyline-CoiTLswR-DTxpB2Yg.js","assets/Polygon-D6wEPb3W-D2MPjRU4.js","assets/aaBoundingRect-CjwcS2F3-ri8bmh30.js","assets/jsonConverter-DmBmaSz7-DJD4mCIi.js","assets/operatorDensify-BAougbyn-C4sw96yF.js","assets/apiConverter-BAgvri9D-BZfUOnhv.js","assets/differenceOperator-FK-6kJ32-DV6O3Rfr.js","assets/lengthOperator-qjwwYihz-BVTflvrs.js"])))=>i.map(i=>d[i]);
import{H as ee,_ as te}from"./index-B0z_nLWi.js";import{Y as R,H as I,aG as De,G as he,I as M,v as ae,aD as X,a7 as ze,a5 as Me}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{f as be,y as _e,b as F,a8 as He,H as ve}from"./Point-BfTTZoMu-DeJwQYfh.js";import{B as Je}from"./Color-CERqXxxY-BuYn26eI.js";import{u as Ee}from"./reader-DcGs6kKN-DHJfK-tm.js";import{f as Se}from"./OperationalLayer-B6zbJ5nR-DyK_ztCk.js";import{k as ke,_ as Oe,S as de,h as Ne,b as je,c as Le,U as We,d as Ge,t as fe,o as pe,L as Ae,f as qe,i as Te,j as $e,s as Ve,E as Ue,y as Ke,p as Ze,e as Qe,l as Xe,m as ye,M as Ye,R as ge,u as et,q as tt,r as it}from"./RasterJobHandlerMixin-CxrZ5p3m-C6N821eB.js";import{J as Be,f as nt,A as st,j as re,G as rt,M as ot,K as at,g as lt,L as ct,w as ut}from"./RasterSymbolizer-Dqn5Dve--BTFzDA6h.js";import{p as ie,a as ht}from"./TileInfo-Bz7QlefV-CdK7c8ef.js";import{R as J,j as mt}from"./datasetUtils-DdDUWBI2-CH5OCkUx.js";import{P as dt}from"./Polygon-D6wEPb3W-D2MPjRU4.js";import{QueueProcessor as ft}from"./QueueProcessor-D8z0mMzA-GcdBlDoB.js";import{z as U}from"./Extent-CgDMOSRD-Bod5LY6s.js";import"./collectionUtils-jDyktm0P-BDP2Oq99.js";import"./Polyline-CoiTLswR-DTxpB2Yg.js";import"./projectionUtils-BGH_5_I3-DGwchVO8.js";import{J as pt}from"./PixelBlock-DA_u_GpM-BxdXIWpv.js";import{Z as le,V as ce,p as Y,v as Q,a as xe,o as Re,e as yt,g as oe,n as gt,t as xt,U as Rt}from"./rasterProjectionHelper-CKWxY3oy-BcPnCcni.js";import{k as ue,M as It,K as wt}from"./rasterFunctionHelper-Dh1b3BL7-QrC-MxqZ.js";import{c as bt}from"./FeatureSet-BF7daP96-B_JvMbY7.js";const K=(e,i=K,s=i.f||(i.f=["assets/densifyOperator-Bz1TMN0X.js","assets/jsonMap-Bs3hmeCU.js","assets/mathUtils-PIGhLnI9.js","assets/Point-BfTTZoMu.js","assets/reader-DcGs6kKN.js","assets/index-BzxsWNRw.js","assets/index-Cv2ko1Ob.css","assets/Point2D-CMz7woHH.js","assets/ProjectionTransformation-PJc9H7Gq.js","assets/Envelope2D-mFnl8dXR.js","assets/Transformation2D-CrydmBdC.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/Extent-CgDMOSRD.js","assets/Polyline-CoiTLswR.js","assets/Polygon-D6wEPb3W.js","assets/aaBoundingRect-CjwcS2F3.js","assets/jsonConverter-DmBmaSz7.js","assets/operatorDensify-BAougbyn.js","assets/apiConverter-BAgvri9D.js","assets/differenceOperator-FK-6kJ32.js","assets/lengthOperator-qjwwYihz.js"]))=>e.map(n=>s[n]);let _t=class{constructor(e=15e3,i=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,i)}decreaseRefCount(e,i){const s=e+"/"+i,n=this._cachedBlocks;if(n.has(s)){const t=n.get(s);return t.refCount--,t.refCount<=0&&(n.delete(s),t.controller&&t.controller.abort()),t.refCount}return 0}getBlock(e,i){const s=e+"/"+i,n=this._cachedBlocks;if(n.has(s)){const t=n.get(s);return t.ts=Date.now(),t.refCount++,n.delete(s),n.set(s,t),t.block}return null}putBlock(e,i,s,n){const t=this._cachedBlocks,r=e+"/"+i;if(t.has(r)){const o=t.get(r);o.ts=Date.now(),o.refCount++}else t.set(r,{block:s,ts:Date.now(),refCount:1,controller:n});this._trim(),this._updateTimer()}deleteBlock(e,i){const s=this._cachedBlocks,n=e+"/"+i;s.has(n)&&s.delete(n)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const e=this._cachedBlocks;this._timer=setInterval(()=>{const i=Array.from(e),s=Date.now();for(let n=0;n<i.length&&i[n][1].ts<=s-this._duration;n++)e.delete(i[n][0]);e.size===0&&this._clearTimer()},this._interval)}_trim(){const e=this._cachedBlocks;if(this._size===-1||this._size>=e.size)return;const i=Array.from(e);for(let s=0;s<i.length-this._size;s++)e.delete(i[s][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const se=new Map,j=new _t;function vt(e,i,s){const n=[];return i!=null&&n.push(`sliceId=${i}`),s!=null&&n.push(`bandIds=${s.join(",")}`),n.length?`${e}?${n.join("&")}`:e}function St(e,i,s){const n=se.get(e);if(!n)return i==null?j.decreaseRefCount(e,s):0;if(i==null||n[i]==null)return j.decreaseRefCount(e,s);const t=n[i]?.cache,r=t?.get(s);if(t&&r){if(r.refCount--,r.refCount===0){t.delete(s);for(let o=0;o<n.length;o++)n[o]?.cache.delete(s);r.controller&&r.controller.abort()}return r.refCount}return 0}function kt(e,i,s){const n=se.get(e);if(!n)return i==null?j.getBlock(e,s):null;if(i==null||n[i]==null){for(let r=0;r<n.length;r++){const o=n[r]?.cache.get(s);if(o)return o.refCount++,o.block}return j.getBlock(e,s)}const t=n[i]?.cache.get(s);if(t)return t.refCount++,t.block;for(let r=0;r<n.length;r++){if(r===i||!n[r])continue;const o=n[r]?.cache,a=o?.get(s);if(o&&a)return a.refCount++,o.set(s,a),a.block}return null}function Tt(e,i,s,n,t=null){const r=se.get(e);if(!r)return void(i==null&&j.putBlock(e,s,n,t));if(i==null||r[i]==null)return void j.putBlock(e,s,n,t);const o={refCount:1,block:n,isResolved:!1,isRejected:!1,controller:t};n.then(()=>o.isResolved=!0).catch(()=>o.isRejected=!0),r[i]?.cache.set(s,o)}function Bt(e,i,s){const n=se.get(e);n?i!=null&&n[i]!=null?n[i]?.cache.delete(s):j.deleteBlock(e,s):i==null&&j.deleteBlock(e,s)}const Ie=8,Pt=256;let Ft=0,b=class extends ze{constructor(){super(...arguments),this._tileFetchQueue=new ft({concurrency:32,process:(e,i)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:ie.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,i=Q(e.spatialReference);return i!=null&&e.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return e==null||e.type==="gcs-shift"}set rasterJobHandler(e){this._set("rasterJobHandler",e),J(this)&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=e)}get rasterId(){return this.url||"rasterId-"+Ft++}set url(e){this._set("url",_e(e,ae.getLogger(this)))}async open(e){return this._openPromise??=ce().then(()=>this._open(e)),this._openPromise}async fetchTile(e,i,s,n={}){const t=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(e,i,s,t);if(!r)throw new M("imagery-tile:out-of-bounds","Level for fetch tile out of range");return n={noClip:!0,...n},this.fetchPixels(r,t.size[0],t.size[1],n)}async identify(e,i={}){e=X(F,e).clone().normalize();const{multidimensionalDefinition:s,timeExtent:n}=i,{rasterInfo:t}=this,{hasMultidimensionalTranspose:r,multidimensionalInfo:o}=t;let{transposedVariableName:a}=i;const l=o!=null&&r&&(n!=null||Te(s));l&&!a&&(a=s!=null&&s.length>0?s[0].variableName??void 0:o.variables[0].name,i={...i,transposedVariableName:a}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=t,{datumTransformation:h}=i;let d=xe(e,c,h);if(!u.intersects(d))return{location:d,value:null};if(t.transform!=null){const _=t.transform.inverseTransform(d);if(!t.nativeExtent.intersects(_))return{location:_,value:null};d=_}let f=0;const p=a!=null&&o!=null&&t.hasMultidimensionalTranspose;if(J(this)){const _=this.primaryRasters.rasters[0];if(p)return _.identify(d,i);const{pixelSize:L}=t,v=3,z=L.x*v/2,W=L.y*v/2,G=new U({xmin:d.x-z,xmax:d.x+z,ymin:d.y-W,ymax:d.y+W,spatialReference:c}),A={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:T}=await _.fetchPixels(G,v,v,A),{pixelBlock:S}=await this.fetchPixels(G,v,v,A);if(T==null)return{location:d,value:null};const P=Math.floor(v*v*.5),H=!T.mask||T.mask[P]?T.pixels.map(D=>D[P]):null;let E;return S!=null&&(E=!S.mask||S.mask[P]?S.pixels.map(D=>D[P]):void 0),{location:d,value:H,processedValue:E,pyramidLevel:0}}if(!p){if(i.srcResolution)f=Re(i.srcResolution,t,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(e,i),f==null)return{location:d,value:null}}const g=this.identifyPixelLocation(d,f,null,p);if(g===null)return{location:d,value:null};const{row:y,col:m,rowOffset:w,colOffset:x,blockWidth:k}=g,B=await this._tileFetchQueue.push({pyramidLevel:f,row:y,col:m,options:i},{signal:i.signal});if(!B?.pixels?.length)return{location:d,value:null};const C=w*k+x;return this._processIdentifyResult(B,{srcLocation:d,position:C,pyramidLevel:f,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(e,i,s,n={}){e=yt(e),n=this._getRequestOptionsWithSliceId(n);const{_hasNoneOrGCSShiftTransform:t}=this;if(n.requestRawData&&t)return this._fetchPixels(e,i,s,n);const r=Q(e.spatialReference),o=oe(e);if(r==null||o===0||o===1&&this._isGlobalWrappableSource&&t)return this._fetchPixels(e,i,s,n);if(o>=3)return{extent:e,pixelBlock:null};const a=[],{xmin:l,xmax:c}=e,u=Math.round(r/(c-l)*i),h=u-Math.round((r/2-l)/(c-l)*i);let d=0;const f=[];for(let m=0;m<=o;m++){const w=new U({xmin:m===0?l:-r/2,xmax:m===o?c-r*m:r/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),x=m===0?u-h:m===o?i-d:u;d+=x,f.push(x);const k=n.disableWrapAround&&m>0?null:this._fetchPixels(w,x,s,n);a.push(k)}const p=(await Promise.all(a)).map(m=>m?.pixelBlock);let g=null;const y={width:i,height:s};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},n)).pixelBlock:g=re(p,y,{blockWidths:f}),{extent:e,srcExtent:Y(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,i,s,n={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const t=await this._fetchRawTiles(e,i,s,n),{nativeExtent:r,nativePixelSize:o,storageInfo:a}=this.rasterInfo,l=2**e,c=o.x*l,u=o.y*l,h=new U({xmin:r.xmin+c*i.x,xmax:r.xmin+c*(i.x+s.width-1),ymin:r.ymax-u*(i.y+s.height-1),ymax:r.ymax-u*i.y,spatialReference:r.spatialReference});if(!t)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:d,mosaicSize:f}=t;if(d.length===1&&d[0]!=null&&d[0].width===s.width&&d[0].height===s.height)return{extent:h,srcExtent:h,pixelBlock:t.pixelBlocks[0]};const p=e>0?a.pyramidBlockWidth:a.blockWidth,g=e>0?a.pyramidBlockHeight:a.blockHeight,y={x:i.x%p,y:i.y%g};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:f,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock:m=re(d,f,{clipOffset:y,clipSize:s}),{extent:h,srcExtent:h,pixelBlock:m}}fetchRawTile(e,i,s,n){throw new M("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return Y(this.rasterInfo.extent,e)}decodePixelBlock(e,i){return!this.rasterJobHandler||i.useCanvas?rt(e,i):this.rasterJobHandler.decode({data:e,options:i})}async request(e,i,s=0){const{customFetchParameters:n}=this.ioConfig,{range:t,query:r,headers:o}=i;s=s??i.retryCount??this.ioConfig.retryCount;const a=t?{Range:`bytes=${t.from}-${t.to}`}:null;try{return await ve(e,{...i,query:{...r,...n},headers:{...o,...a}})}catch(l){if(s>0)return s--,this.request(e,i,s);throw l}}getSliceIndex(e){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||e==null||e.length===0?null:et(e,i)}getTileExtentFromTileInfo(e,i,s,n){const t=n.lodAt(e);return t?this.getTileExtent({x:t.resolution,y:t.resolution},i,s,n.origin,n.spatialReference,n.size):null}updateTileInfo(){const{storageInfo:e,spatialReference:i,extent:s,pixelSize:n}=this.rasterInfo,{pyramidResolutions:t}=e;if(!e.tileInfo){const r=[],o=e.maximumPyramidLevel||0;let a=(n.x+n.y)/2,l=1/.0254*96*a;for(let u=0;u<=o&&(r.unshift(new ht({level:o-u,resolution:a,scale:l})),u!==o);u++)if(t){const h=(t[u].x+t[u].y)/2;l*=h/a,a=h}else a*=2,l*=2;const c=new F({x:s.xmin,y:s.ymax,spatialReference:i});e.tileInfo=new ie({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:i,lods:r}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,i=512,s=512,n){const{width:t,height:r,nativeExtent:o,pixelSize:a,spatialReference:l}=e,c=new F({x:o.xmin,y:o.ymax,spatialReference:l});n==null&&(n=Math.max(0,Math.round(Math.log(Math.max(t,r))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],n);e.storageInfo=new ot({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,i={}){return 0}computeBlockBoundary(e,i,s,n,t,r=0,o=2){if(t.length===1&&r>0){t=[...t];let{x:u,y:h}=t[0];for(let d=0;d<r;d++)u*=o,h*=o,t.push({x:u,y:h})}const a=[],{x:l,y:c}=n;for(let u=0;u<t.length;u++){const{x:h,y:d}=t[u];a.push({minCol:Math.floor((e.xmin-l+.1*h)/i/h),maxCol:Math.floor((e.xmax-l-.1*h)/i/h),minRow:Math.floor((c-e.ymax+.1*d)/s/d),maxRow:Math.floor((c-e.ymin-.1*d)/s/d)})}return a}getPyramidPixelSize(e){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(e===0)return i;if(s!=null&&s.length)return s[e-1];const t=n**e;return{x:i.x*t,y:i.y*t}}identifyPixelLocation(e,i,s,n){const{spatialReference:t,nativeExtent:r,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:c}=o,u=n&&c!=null?c.tileSize[0]:o.blockWidth,h=n&&c!=null?c.tileSize[1]:o.blockHeight,d=xe(e,t,s);if(!r.intersects(d)||i<0||i>a)return null;const f=this.getPyramidPixelSize(i),{x:p,y:g}=f,y=(l.y-d.y)/g/h,m=(d.x-l.x)/p/u,w=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),x=Math.min(u-1,Math.floor((m-Math.floor(m))*u));return{pyramidLevel:i,row:Math.floor(y),col:Math.floor(m),rowOffset:w,colOffset:x,blockWidth:u,srcLocation:d}}getTileExtent(e,i,s,n,t,r){const[o,a]=r,l=n.x+s*o*e.x,c=l+o*e.x,u=n.y-i*a*e.y,h=u-a*e.y;return new U({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:t})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,i,s){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<i||n.maxCol<s||n.minRow>i||n.minCol>s}updateImageSpaceRasterInfo(e){const{pixelSize:i}=e,{width:s,height:n}=e,t=be.WebMercator;e.spatialReference=t,e.extent=e.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-n,spatialReference:t}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new F({x:1,y:1,spatialReference:t});const{extent:r,storageInfo:o}=e;if(o){o.origin=new F({x:r.xmin,y:r.ymax,spatialReference:t});const{pyramidResolutions:a,tileInfo:l}=o;if(a&&a.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=o.origin;const c=(e.nativePixelSize.x+e.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(e,i,s,n={}){let t=oe(e);if(t>=2)return{extent:e,pixelBlock:null};const r=this._getSourceDataInfo(e,i,s,n),{pyramidLevel:o,srcResolution:a,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=r;if(c===0||u===0)return{extent:e,srcExtent:l,pixelBlock:null};const{rasterInfo:d}=this,f=d.transform,p=f?.type==="gcs-shift",g=Q(e.spatialReference)!=null;!p&&g||(t=oe(r.srcExtent,p));const y=await this._fetchRawTiles(o,h,{width:c,height:u,wrapCount:t},n);if(!y)return{extent:e,srcExtent:l,pixelBlock:null};const m=d.storageInfo,w=o>0?m.pyramidBlockWidth:m.blockWidth,x=o>0?m.pyramidBlockHeight:m.blockHeight;let{x:k,y:B}=d.pixelSize;if(o>0){const{pyramidResolutions:N,pyramidScalingFactor:Ce}=m;if(N!=null&&N[o-1])({x:k,y:B}=N[o-1]);else{const me=Ce**o;k*=me,B*=me}}const C=d.spatialReference,_=new F({x:k,y:B,spatialReference:C}),L=w===c&&x===u&&h.x%w===0&&h.y%x===0,v=new F({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/s,spatialReference:e.spatialReference}),z=!e.spatialReference.equals(C),W=C.isGeographic?1e-9:1e-4,{datumTransformation:G}=n;if(!z&&L&&y.pixelBlocks.length===1&&w===i&&x===s&&Ct(a,v,W))return{extent:e,srcExtent:l,srcTilePixelSize:_,pixelBlock:y.pixelBlocks[0]};const A=g&&Q(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,T=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");T&&!this.rasterJobHandler&&await ce();const S=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:v.toJSON(),datumTransformation:G,rasterTransform:f,hasWrapAround:t>0||A,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:T},n):gt({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:v,datumTransformation:G,rasterTransform:f,hasWrapAround:t>0||A,isAdaptive:!1,includeGCSGrid:T});let P;const H=!n.requestRawData,E={rows:S.spacing[0],cols:S.spacing[1]},D=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(o,y.extent.xmin):void 0,{pixelBlocks:O,mosaicSize:q,isPartiallyFilled:Z}=y;let $=null;if(this.rasterJobHandler)({pixelBlock:P,localNorthDirections:$}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:q,destDimension:H?{width:i,height:s}:null,coefs:H?S.coefficients:null,sampleSpacing:H?E:null,projectDirections:T,gcsGrid:T?S.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:n.interpolation,alignmentInfo:D,blockWidths:null},n));else{const N=re(O,q,{alignmentInfo:D});P=H?Be(N,{width:i,height:s},S.coefficients,E,n.interpolation):N,T&&S.gcsGrid&&($=at({width:i,height:s},S.gcsGrid),P=lt(P,this.rasterInfo.dataType,$))}return n.requestRawData||T?{extent:e,srcExtent:l,srcTilePixelSize:_,pixelBlock:P,transformGrid:S,localNorthDirections:$,isPartiallyFilled:Z}:{extent:e,srcExtent:l,srcTilePixelSize:_,pixelBlock:P}}async _fetchRawTiles(e,i,s,n){const{origin:t,blockBoundary:r}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:a}=this.getBlockWidthHeight(e);let{x:l,y:c}=i,{width:u,height:h,wrapCount:d}=s;const f=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(l-=n.buffer.cols,c-=n.buffer.rows,u+=2*n.buffer.cols,h+=2*n.buffer.rows);let p=0,g=0,y=0;d&&f!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:p}=f,g*f.blockWidth-p>=l+u&&(p=0));const m=Math.floor(l/o),w=Math.floor(c/a),x=Math.floor((l+u+p-1)/o),k=Math.floor((c+h+p-1)/a),B=r[e];if(!B)return null;const{minRow:C,minCol:_,maxCol:L,maxRow:v}=B;if(d===0&&(k<C||x<_||w>v||m>L))return null;const z=new Array;let W=!1;const G=this.ioConfig.allowPartialFill==null?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let D=w;D<=k;D++)for(let O=m;O<=x;O++){let q=O;if(!n.disableWrapAround&&d&&f!=null&&g<=O&&(q=O-g-y),D>=C&&q>=_&&v>=D&&L>=q){const Z=this._tileFetchQueue.push({pyramidLevel:e,row:D,col:q,options:n},{signal:n.signal});G?z.push(new Promise($=>{Z.then(N=>$(N)).catch(()=>{W=!0,$(null)})})):z.push(Z)}else z.push(Promise.resolve(null))}if(z.length===0)return null;const A=await Promise.all(z),T={height:(k-w+1)*a,width:(x-m+1)*o},{spatialReference:S}=this.rasterInfo,P=this.getPyramidPixelSize(e),{x:H,y:E}=P;return{extent:new U({xmin:t.x+m*o*H,xmax:t.x+(x+1)*o*H,ymin:t.y-(k+1)*a*E,ymax:t.y-w*a*E,spatialReference:S}),pixelBlocks:A,mosaicSize:T,isPartiallyFilled:W}}_fetchRawTile(e,i,s,n){const{storageInfo:t}=this.rasterInfo,r=t.transposeInfo!=null&&!!n.transposedVariableName;if(!r){const h=t.blockBoundary[e];if(!h)return Promise.resolve(null);const{minRow:d,minCol:f,maxCol:p,maxRow:g}=h;if(i<d||s<f||i>g||s>p)return Promise.resolve(null)}const o=r?n.transposeVariableName:n.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?n.bandIds:null,l=vt(this.rasterId,o,a),c=`${e}/${i}/${s}`;let u=kt(l,n.registryId,c);if(u==null){const h=new AbortController;u=this.fetchRawTile(e,i,s,{...n,signal:h.signal}),Tt(l,n.registryId,c,u,h),u.catch(()=>Bt(l,n.registryId,c))}return n.signal&&Me(n,()=>{St(l,n.registryId,c)}),u}_computeMagDirValues(e){const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||e?.length!==2||!e[0]?.length)return null;const n=e[0].length;if(s==="vector-magdir"){const l=e[1].map(c=>(c+360)%360);return[e[0],l]}const[t,r]=e,o=[],a=[];for(let l=0;l<n;l++){const[c,u]=ct([t[l],r[l]]);o.push(c),a.push(u)}return[o,a]}_getRasterTileAlignmentInfo(e,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=xt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,i,s,n={}){const t={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};n.srcResolution&&(t.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,t));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=t,c=o/i,u=a/s,h=l<r&&c*u>=16,d=l===r&&this._requireTooManySrcTiles(o,a,i,s);if(h||d||o===0||a===0){const f=new F({x:(e.xmax-e.xmin)/i,y:(e.ymax-e.ymin)/s,spatialReference:e.spatialReference});let p=Rt(f,this.rasterInfo.spatialReference,e,t.datumTransformation);const g=!p||n.srcResolution&&p.x+p.y<n.srcResolution.x+n.srcResolution.y;if(h&&n.srcResolution&&g){const y=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(r-l+3>=y){const m=2**y;p={x:n.srcResolution.x*m,y:n.srcResolution.y*m}}}p&&(t.srcResolution=p,this._updateSourceDataInfo(e,t))}return this._requireTooManySrcTiles(t.srcWidth,t.srcHeight,i,s)&&(t.srcWidth=0,t.srcHeight=0),t}_requireTooManySrcTiles(e,i,s,n){const{tileInfo:t}=this.rasterInfo.storageInfo,r=Math.ceil(e/t.size[0])*Math.ceil(i/t.size[1]),o=e/s,a=i/n,l=Math.max(1,(s+n)/1024);return r>=Pt*l||o>Ie||a>Ie}_updateSourceDataInfo(e,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,n=s.spatialReference,{srcResolution:t,datumTransformation:r}=i,{pyramidLevel:o,pyramidResolution:a,excessiveReading:l}=Re(t,s,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||Y(e,n,r);if(c==null)return;const u=s.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:h}=s.storageInfo,{width:d,height:f,ul:p}=mt(c,h,a,o);i.pyramidLevel=o,i.pyramidResolution=a,i.srcWidth=d,i.srcHeight=f,i.ul=p}_getRequestOptionsWithSliceId(e){return this.rasterInfo.multidimensionalInfo!=null&&e.sliceId==null&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,i){const{srcLocation:s,position:n,pyramidLevel:t,useTransposedTile:r}=i,o=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[n]))return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(a==null||!r){const y=e.pixels.map(x=>x[n]),m={location:s,value:y,pyramidLevel:t},w=this._computeMagDirValues(y.map(x=>[x]));return w?.length&&(m.magdirValue=w.map(x=>x[0])),m}let l=e.pixels.map(y=>y.slice(n*o,n*o+o)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=i;let d=tt(a,h.transposedVariableName);if(u){const y=it(d,h.multidimensionalDefinition,h.timeExtent);l=l.map(m=>y.map(w=>m[w])),c=c?.map(m=>y.map(w=>m[w])),d=y.map(m=>d[m])}const f=e.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:e.pixelType};let g;return f!=null&&(pt(p,f),g=p.mask),{location:s,value:null,dataSeries:d.map((y,m)=>{const w={value:g?.[m]===0?null:l.map(x=>x[m]),multidimensionalDefinition:y.multidimensionalDefinition.map(x=>new ke({...x,isSlice:!0}))};return c?.length&&(w.magdirValue=[c[0][m],c[1][m]]),w}),pyramidLevel:t}}};function Ct(e,i,s){return Math.abs(e.x-i.x)<s&&Math.abs(e.y-i.y)<s}R([I()],b.prototype,"_rasterTileAlignmentInfo",void 0),R([I()],b.prototype,"_tileFetchQueue",void 0),R([I({readOnly:!0})],b.prototype,"_isGlobalWrappableSource",null),R([I({readOnly:!0})],b.prototype,"_hasNoneOrGCSShiftTransform",null),R([I()],b.prototype,"_openPromise",void 0),R([I()],b.prototype,"rasterJobHandler",null),R([I({readOnly:!0})],b.prototype,"rasterId",null),R([I(Se)],b.prototype,"url",null),R([I({type:String,json:{write:!0}})],b.prototype,"datasetName",void 0),R([I({type:String,json:{write:!0}})],b.prototype,"datasetFormat",void 0),R([I()],b.prototype,"hasUniqueSourceStorageInfo",void 0),R([I()],b.prototype,"rasterInfo",void 0),R([I()],b.prototype,"ioConfig",void 0),R([I()],b.prototype,"sourceJSON",void 0),b=R([he("esri.layers.support.rasterDatasets.BaseRaster")],b);const Dt=40;let V=class extends b{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,i,s,n={}){const{rasters:t,rasterIds:r}=this.primaryRasters;let o=!1;const{interpolation:a}=n,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!n.requestRawData&&l&&(o=t.length===1&&!n.skipRasterFunction,n={...n,interpolation:"bilinear",requestRawData:o}),n.requestRawData&&t.length>1&&!this.hasUniqueSourceStorageInfo&&(o=!1,n={...n,requestRawData:!1});const c=t.map(x=>x.fetchPixels(e,i,s,n)),u=await Promise.all(c),h=u.map(x=>x.pixelBlock),d=o||n.requestRawData?u.map(x=>x.srcTilePixelSize):null;if(n.skipRasterFunction||h.every(x=>x==null))return u[0];const f=u.find(x=>x.pixelBlock!=null)?.extent??e;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:r}):this.rasterFunction.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:r});const{transformGrid:g}=u[0];if(!o||p==null||g==null){const x=n.noClip?null:this.getClippingGeometry(f.spatialReference);return!n.noClip&&p!=null&&x&&(p=await ue(p,f,x)),{...u[0],pixelBlock:p}}const y={rows:g.spacing[0],cols:g.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:s},coefs:g.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},n)).pixelBlock:m=Be(p,{width:i,height:s},g.coefficients,y,a);const w=n.noClip?null:this.getClippingGeometry(e.spatialReference);return n.noClip||m==null||w==null||(m=await ue(m,e,w)),{extent:e,srcExtent:u[0].srcExtent,pixelBlock:m}}getClippingGeometry(e){const i=this._clippingGeometry.get("0");if(!e||!i)return i;const s=Mt(e);let n=this._clippingGeometry.get(s);return n!=null||(n=e.equals(i.spatialReference)?i:le(i,e),this._clippingGeometry.set(s,n)),n}async _open(e){const{rasterFunction:i}=this;i.isRoot=!0,this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:s,rasterIds:n}=this.primaryRasters,t=s.map(c=>c.rasterInfo?void 0:c.open(e));await Promise.all(t);const r=s.map(({rasterInfo:c})=>c),o=i.bind({rasterInfos:r,rasterIds:n});if(i.rawSourceRasterInfos=r,!o.success||r.length===0)throw new M("raster-function:open",`cannot bind the function: ${o.error??""}`);const a=i.functionName==="Table"?i:i.functionArguments?.raster;a?.functionName==="Table"&&(i.rasterInfo.attributeTable=bt.fromJSON(a.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=r[0];this.hasUniqueSourceStorageInfo=r.length===1||r.slice(1).every(c=>zt(c,l)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let i=e?.clippingGeometry;if(i&&e.clippingType==="inside"){const{extent:s}=this.rasterInfo,n=await ee(()=>te(()=>import("./densifyOperator-Bz1TMN0X-C8v09yyy.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])).then(o=>o.d),K([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])),t=await ee(()=>te(()=>import("./differenceOperator-FK-6kJ32-DV6O3Rfr.js"),__vite__mapDeps([20,7,8,9,10,11,1,12,13,3,4,5,6,14,15,16,2,17,19])).then(o=>o.d),K([20,7,8,9,10,11,1,12,13,3,4,5,6,14,15,16,2,17,19]));let r=n.execute(dt.fromExtent(s),2*(s.width+s.height)/Dt);r=le(r,i.spatialReference),i=t.execute(r,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function zt(e,i){const{storageInfo:s,pixelSize:n,spatialReference:t,extent:r}=e,{storageInfo:o,pixelSize:a,spatialReference:l,extent:c}=i;return n.x===a.x&&n.y===a.y&&t.equals(l)&&r.equals(c)&&s.blockHeight===o.blockHeight&&s.blockWidth===o.blockWidth&&s.maximumPyramidLevel===o.maximumPyramidLevel&&s.firstPyramidLevel===o.firstPyramidLevel&&s.pyramidBlockWidth===o.pyramidBlockWidth&&s.pyramidBlockHeight===o.pyramidBlockHeight&&s.pyramidScalingFactor===o.pyramidScalingFactor}function Mt(e){return String(e.wkid??e.wkt??e.wkt2)}R([I({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),R([I()],V.prototype,"tileType",void 0),R([I()],V.prototype,"rasterFunction",void 0),R([I()],V.prototype,"primaryRasters",void 0),V=R([he("esri.layers.support.rasterDatasets.FunctionRaster")],V);const we=1e3,ii=e=>{const i=e;let s=class extends i{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=J(t[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){t?.functionName?.toLowerCase()==="none"&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",_e(t,ae.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:t,presetRenderers:r}=this;return t?r?.find(({name:o})=>o===t)?.renderer.clone():this.internalRenderer}set renderer(t){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=t}set internalRenderer(t){t==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",t),this.updateRenderer())}readRenderer(t,r,o){const a=r?.layerDefinition?.drawingInfo?.renderer;return Le(a,o)||void 0}async computeStatisticsHistograms(t,r){await this.load(r),t=X(We,t).clone();const{serviceRasterInfo:o}=this;if(o==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:a}=t;if(a==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=a;const{spatialReference:c}=o;if(!a.spatialReference.equals(c)){await ce();const m=a.type==="extent"?Y(a,c):le(a,c);if(m==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=m}const u=t.pixelSize??new F({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:c}),{extent:h,width:d,height:f}=It(o,l,u),p=await this.fetchPixels(h,d,f,{...r,interpolation:"nearest"});if(p.pixelBlock==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ue(p.pixelBlock,h,l),y=this._rasterJobHandler;return y?y.computeStatisticsHistograms({pixelBlock:g},r):nt(g)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:r}=this.serviceRasterInfo??{};if(r==null)return t;const o=Ge({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:t.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:t.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...t,multidimensionalDefinition:o,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:t,symbolizer:r,renderer:o}=this;if(!t||!r||!o)return;const{rasterInfo:a}=this.raster,l=fe(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),c=l?.name,u=pe(a,c);return this._updateSymbolizer(r,o,c,u)}async applyRenderer(t,r,o){const a=t?.pixelBlock;if(!(a!=null&&a.pixels&&a.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:c}=await this._symbolize({pixelData:t,simpleStretchParams:r,bandIds:l,symbolizer:this.symbolizer},o);return c}getRawDisplayBandIds(){let{bandIds:t,raster:r}=this;if(this.rasterFunction&&J(r)){const o=r.rasterFunction.rawInputBandIds;t=t?.length&&o?.length&&r.rasterInfo.bandCount!==1?t.map(a=>o[Math.min(a,o.length-1)]):o}return t&&t.length>3&&t.every((o,a)=>o===a)?null:t}getTileUrl(t,r,o){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${t}/${r}/${o}`:""}getCompatibleTileInfo(t,r,o=!1){if(!this.loaded||r==null)return null;if(o&&t.equals(this.spatialReference))return this.tileInfo;const a=He(t);return ie.create({size:256,spatialReference:t,origin:a?{x:a.origin[0],y:a.origin[1]}:{x:r.xmin,y:r.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,r,o,a={}){if(n(this),a.requestAsImageElement){const c=this.getTileUrl(t,r,o);return ve(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:a.signal}).then(u=>u.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null){const c=a.tileInfo||l.storageInfo.tileInfo,u=this.raster.getTileExtentFromTileInfo(t,r,o,c);if(u)return{extent:u,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(a={...a,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,r,o,a)}async fetchPixels(t,r,o,a={}){if(this.serviceRasterInfo.multidimensionalInfo!=null&&(a=this.normalizeRasterFetchOptions(a)).multidimensionalDefinition==null)return{extent:t,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),r=Math.round(r),o=Math.round(o);const l=await this.raster.fetchPixels(t,r,o,a);return a.bandIds?.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=l.pixelBlock?.extractBands(a.bandIds)),l}async getSamples(t,r){if(await this.load(),(t=X(Ae,t).clone()).interpolation&&t.interpolation!=="nearest")throw new M("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const o=t.mosaicRule?.multidimensionalDefinition,a={...r,multidimensionalDefinition:o},l=(await this._getSampleLocations(t)).map(u=>this.identify(u,a).then(h=>(h.location=u,h))),c=(await Promise.all(l)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new qe({samples:c})}async identify(t,r={}){await this.load(),t=X(F,t).clone().normalize();const{raster:o,serviceRasterInfo:a}=this;if(a?.multidimensionalInfo!=null&&!(a.hasMultidimensionalTranspose&&!(!Te(r.multidimensionalDefinition)&&!r.transposedVariableName))&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{location:t,value:null};const l=this.multidimensionalSubset?.areaOfInterest;if(l&&!l.contains(t))throw new M("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let c;if(this.serviceRasterInfo?.storageInfo.isBsqTile){const u=J(o)?this.getRawDisplayBandIds():this.bandIds;c=u?.length?u:void 0}return o.identify(t,{...r,bandIds:c})}hasStandardTime(){const t=this.serviceRasterInfo?.multidimensionalInfo;if(t==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const r=this.multidimensionalDefinition,o=r?.[0]?.variableName;return t.variables.some(a=>a.name===o&&(!r?.[0].dimensionName||a.dimensions.some(l=>l.name==="StdTime")))}getStandardTimeValue(t){return new Date($e(t)).toISOString()}getMultidimensionalSubsetVariables(t){const r=t??this.serviceRasterInfo?.multidimensionalInfo;return Ve(this.multidimensionalSubset,r)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ue(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&J(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;n(this);const{raster:t}=this;t.rasterJobHandler=this._rasterJobHandler,J(t)&&t.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){const{geometry:r}=t;if(r.type==="point")return[r];const{spatialReference:o,type:a}=r;if(a==="multipoint")return r.points.map(m=>new F({x:m[0],y:m[1],spatialReference:o}));if(a==="polyline"){let m=r;if(t.sampleCount||t.sampleDistance){const w=await ee(()=>te(()=>import("./densifyOperator-Bz1TMN0X-C8v09yyy.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])).then(C=>C.d),K([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19])),x=(await ee(async()=>{const{execute:C}=await te(()=>import("./lengthOperator-qjwwYihz-BVTflvrs.js"),__vite__mapDeps([21,3,4,5,1,6,7,9,8,10,11,12,13,14,15,16,2,17,19])).then(_=>_.l);return{execute:C}},K([21,3,1,4,5,6,7,9,8,10,11,12,13,14,15,16,2,17,19]))).execute(r,{unit:"meters"}),k=Math.min(t.sampleCount||100,we);let B=t.sampleDistance;B||(B=x/(k+(m.paths[0].length===2?1:0))),m=w.execute(r,B,{unit:"meters"})}return m.paths.flatMap(w=>w.map(x=>new F({x:x[0],y:x[1],spatialReference:o})))}const l=Math.min(t.sampleCount||100,we),c=r.type==="extent",u=c?r:r.extent,h=Math.sqrt(u.width*u.height/l),d=u.height/h,f=u.width/h,{xmin:p,ymax:g}=u,y=[];for(let m=0;m<d;m++)for(let w=0;w<f;w++){const x=new F({x:p+(w+.5)*h,y:g-(m+.5)*h,spatialReference:o});(c||r.contains(x))&&y.push(x)}return y}_configDefaultInterpolation(){if(this.interpolation==null){n(this);const{raster:t}=this,r=Ke(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",r)}}_configDefaultRenderer(t="no"){n(this);const{rasterInfo:r}=this.raster,o=fe(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),a=o?.name,l=Ze({variableName:a,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&r.bandCount>1&&(this.bandIds=l?.bandIds??Qe(r)),!this.renderer||t==="override"){const d=Xe(this.raster),f=l?.renderer??ye(r,{bandIds:this.bandIds,variableName:a,rasterFunctionColorRamp:d}),p=r.statistics,g=p&&p.length>0?p[0]:null,y=g?.max??0,m=g?.min??0;this.raster.datasetFormat==="WCSServer"&&f.type==="raster-stretch"&&(y>1e24||m<-1e24)&&(f.dynamicRangeAdjustment=!0,f.customStatistics=null,f.stretchType==="none"&&(f.stretchType="min-max")),this.renderer=f}const c=Ye({...this.renderer.toJSON(),variableName:a}),u=pe(r,a);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=u):this.symbolizer=new st({rendererJSON:c,rasterInfo:u});const h=this.symbolizer.bind();if(h.success){if(t==="auto"){const{colormap:d}=this.raster.rasterInfo,f=this.renderer;if(d!=null&&f.type==="raster-colormap"){const p=ye(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if(f.type==="raster-stretch"){const p=this.bandIds?.length,g=f.customStatistics?.length;!f.dynamicRangeAdjustment&&g&&p&&g!==p&&this._configDefaultRenderer("override")}}}else ae.getLogger(this).warn("imagery-tile-mixin",h.error||"The given renderer is not supported by the layer."),t==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&J(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",de.fromJSON(h)))}let t,r=this.raster,o=!1;J(r)?(t=r.primaryRasters.rasters,r=t[0],o=!0):t=[r];const{rasterFunction:a}=this;if(a){const h={raster:r};t.length>1&&t.forEach(p=>h[p.url]=p);const d=wt(a.functionDefinition?.toJSON()??a.toJSON(),h),f=new V({rasterFunction:d});f.rasterJobHandler=this._rasterJobHandler,await f.open(),this.raster=f}else this.raster=r,await r.open();if(this._cachedRendererJson=void 0,!o&&!a)return;const{bandIds:l}=this,{bandCount:c}=this.raster.rasterInfo,u=l?.length?l.some(h=>h>=c):c>=3;l&&(u||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(t,r){const{rasterInfo:o}=this.raster,a=o.storageInfo.pyramidScalingFactor**(t.pyramidLevel??0),l=(o.pixelSize.x+o.pixelSize.y)/2*a;if(!t.dataSeries?.length)return[new ge({location:t.location,pixelValue:t.value,locationId:r,resolution:l})];const c=[];return t.dataSeries.forEach(({value:u,multidimensionalDefinition:h},d)=>{const f={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:g})=>g).join(",")};for(const{dimensionName:g,values:y}of h){f[g]=Array.isArray(y[0])?y[0][0]:y[0];const m=y[y.length-1];f[`${g}_Max`]=Array.isArray(m)?m[m.length-1]:m}const p=new ge({location:t.location,pixelValue:u,rasterId:d,locationId:r,resolution:l,attributes:f});c.push(p)}),c}};function n(t){if(!t.raster||!t.serviceRasterInfo)throw new M("imagery-tile","no raster")}return R([I({clonable:!1})],s.prototype,"_cachedRasterFunctionJson",void 0),R([I({clonable:!1})],s.prototype,"_compatibleFullExtent",void 0),R([I({clonable:!1})],s.prototype,"_isConstructedFromFunctionRaster",void 0),R([I({clonable:!1})],s.prototype,"_rasterFunctionUpdatePromise",void 0),R([I({type:[De],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],s.prototype,"bandIds",void 0),R([I({json:{origins:{service:{read:{source:"copyrightText"}}}}})],s.prototype,"copyright",void 0),R([I({json:{read:!1}})],s.prototype,"fullExtent",null),R([I({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(ut)],s.prototype,"interpolation",void 0),R([I()],s.prototype,"ioConfig",void 0),R([I({type:[ke],json:{write:!0}})],s.prototype,"multidimensionalDefinition",null),R([I({type:Oe,json:{write:!0}})],s.prototype,"multidimensionalSubset",void 0),R([I()],s.prototype,"raster",void 0),R([I({type:de})],s.prototype,"rasterFunction",null),R([I()],s.prototype,"serviceRasterInfo",void 0),R([I()],s.prototype,"sourceJSON",void 0),R([I({readOnly:!0,type:be,json:{read:!1}})],s.prototype,"spatialReference",void 0),R([I({type:ie})],s.prototype,"tileInfo",void 0),R([I(Se)],s.prototype,"url",null),R([I()],s.prototype,"renderer",null),R([I({types:je,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!t}}},origins:{"web-scene":{types:Ne,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&t.type!=="vector-field"})}}}}})],s.prototype,"internalRenderer",null),R([Ee("internalRenderer")],s.prototype,"readRenderer",null),R([I({clonable:!1})],s.prototype,"symbolizer",void 0),s=R([he("esri.layers.mixins.ImageryTileMixin")],s),s};function ne(e,i){if(!e||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const n=[];if(i){const r=ne(e,s);for(let o=0;o<r.length;o++)ne(r[o],i).forEach(a=>n.push(a));return n}const t=e.getElementsByTagNameNS("*",s);if(!t||t.length===0)return[];for(let r=0;r<t.length;r++)n.push(t[r]||t.item(r));return n}function Pe(e,i){if(!e||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const n=ne(e,s);return n.length>0?i?Pe(n[0],i):n[0]:null}function Fe(e,i=null){const s=i?Pe(e,i):e;let n;return s?(n=s.textContent||s.nodeValue,n?n.trim():null):null}function Ht(e,i){const s=ne(e,i),n=[];let t;for(let r=0;r<s.length;r++)t=s[r].textContent||s[r].nodeValue,t&&(t=t.trim(),t!==""&&n.push(t));return n}function ni(e,i=null){return Fe(e,i)?.split(" ").map(s=>Number(s))??[]}function si(e,i){return Ht(e,i).map(s=>Number(s))}function ri(e,i){const s=Fe(e,i);return Number(s)}function oi(e,i){const s=e?.nodeName?.toLowerCase(),n=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===n}function ai(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{Ht as $,Pe as B,Fe as P,V as U,b as _,ri as a,ne as i,ai as l,ii as n,oi as o,ni as r,si as s};
