import{a1 as F}from"./jsonMap-Bs3hmeCU.js";import{a as j,c as U,n as K}from"./Point2D-CMz7woHH.js";import{i as w,aZ as N,C as q,u as g,P as x,a_ as b,a$ as I,b0 as P,b1 as $,b2 as B,D,b3 as H}from"./ProjectionTransformation-PJc9H7Gq.js";import"./Envelope2D-mFnl8dXR.js";import"./Extent-Bbnm65bN.js";import"./Polyline-BtUG5wiC.js";import"./Point-BN8RINcc.js";import"./Polygon-BdLNJfwi.js";import"./jsonConverter-Dk2FSxYW.js";import{t as J}from"./SimpleGeometryCursor-B92kdZ15.js";import{getSpatialReference as L,fromSpatialReference as Q,fromPolyline as W,fromGeometry as X,toGeometry as Y}from"./apiConverter-HTBxo72t.js";var R=H;function f(l,e){return{m_geometry:l,m_side:e}}function tt(l,e,o,t,m,n){if(e.isEmpty()){const a=f(e,0);return void m.push(a)}if(o.isEmpty()){const a=f(e,0);return void m.push(a)}const s=[],r=new x;{const a=r.createGeometryUserIndex(),C=r.addGeometry(e),S=r.addGeometry(o),p=new $(n);let d=0,i=null;if(r.hasCurves()){i=new R;const h=r.getEnvelope2D(n);d=b(t.total());const _=I(t.total(),h);P(r,_,t.total(),12e3,i,null,n)}r.dbgVerifyCurves(),p.setEditShapeCrackAndCluster(r,t),p.cut(l,a,C,S,s);for(const h of s){i!==null&&i.stitchCurves(r,h,d,!1);const _=f(r.getGeometry(h),B(r.getGeometryUserIndex(h,a)));m.push(_)}i!==null&&i.clearStitcher(r)}}function et(l,e,o,t,m,n){if(e.isEmpty()){const a=f(e,0);return void m.push(a)}if(o.isEmpty()){const a=f(e,0);return void m.push(a)}const s=[],r=new x;{const a=r.createGeometryUserIndex(),C=r.addGeometry(e),S=r.addGeometry(o),p=new $(n);let d=0,i=null;if(r.hasCurves()){i=new R;const c=r.getEnvelope2D(n);d=b(t.total());const y=I(t.total(),c);P(r,y,t.total(),12e3,i,null,n)}r.dbgVerifyCurves(),p.setEditShapeCrackAndCluster(r,t),p.cut(!1,a,C,S,s),i!==null&&i.stitchCurves(r,D,d,!0);let h=r.getGeometry(C);const _=new g,E=new g,v=[];for(let c=0;c<s.length;c++){let y=null;{const u=new x,k=u.addGeometry(h),T=u.addGeometry(r.getGeometry(s[c]));if(u.hasCurves()){const O=u.getEnvelope2D(n);d=b(t.total());const Z=I(t.total(),O);P(u,Z,t.total(),12e3,i,null,n)}p.setEditShapeCrackAndCluster(u,t);const A=p.intersection(k,T);if(i!==null&&i.stitchCurves(u,D,d,!0),y=u.getGeometry(A),y.isEmpty())continue;const G=r.getGeometryUserIndex(s[c],a);G===2?_.add(y,!1):G===1?E.add(y,!1):v.push(y)}{const u=new x,k=u.addGeometry(h),T=u.addGeometry(r.getGeometry(s[c]));if(u.hasCurves()){const G=u.getEnvelope2D(n);d=b(t.total());const O=I(t.total(),G);P(u,O,t.total(),12e3,i,null,n)}p.setEditShapeCrackAndCluster(u,t);const A=p.difference(k,T);i!==null&&i.stitchCurves(u,D,d,!0),h=u.getGeometry(A)}}if(!h.isEmpty()&&s.length>0&&v.push(h),_.isEmpty()&&E.isEmpty())return;if(!_.isEmpty()){const c=f(_,1);m.push(c)}if(!E.isEmpty()){const c=f(E,2);m.push(c)}for(let c=0,y=v.length;c<y;++c){const u=f(v[c],3);m.push(u)}}}class st{getOperatorType(){return 10005}accelerateGeometry(e,o,t){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}execute(e,o,t,m,n){return new rt(e,o,t,m,n)}}class rt extends J{constructor(e,o,t,m,n){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=n,this.m_cuttee=o.clone(),this.m_cutter=new w({copy:t}),this.m_bConsiderTouch=e;const s=N(o,t);this.m_tolerance=q(m,s,!0)}next(){return this.m_cutIndex===-1&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case j.enumPolyline:this.generatePolylineCuts();break;case j.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const e=new w,o=new w,t=new w;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(o);const m=[];tt(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,m,this.m_progressTracker);for(let n=0;n<m.length;n++){const s=m[n];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2||s.m_side===4?o.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?t.add(s.m_geometry,!1):U("")}t.isEmpty()||e.isEmpty()&&o.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(t),e.isEmpty()&&o.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const e=new g,o=new g,t=new g;this.m_cuts.length=0,this.m_cuts.push(e),this.m_cuts.push(o);const m=[];et(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,m,this.m_progressTracker);for(let n=0;n<m.length;n++){const s=m[n];s.m_side===1?e.add(s.m_geometry,!1):s.m_side===2?o.add(s.m_geometry,!1):s.m_side===3?this.m_cuts.push(s.m_geometry):s.m_side===0?t.add(s.m_geometry,!1):U("")}K(t.isEmpty()||m.length===1),e.isEmpty()&&o.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}}const z=new st;function ot(l,e,o){const t=z.execute(!0,l,e,o,null);return Array.from(t)}function nt(){return z.supportsCurves()}function M(l,e){const o=L(l);return ot(X(l),W(e),Q(o)).map(t=>Y(t,o)).filter(F)}const V=nt(),ft=Object.freeze(Object.defineProperty({__proto__:null,execute:M,supportsCurves:V},Symbol.toStringTag,{value:"Module"})),gt=Object.freeze(Object.defineProperty({__proto__:null,execute:M,supportsCurves:V},Symbol.toStringTag,{value:"Module"}));export{gt as c,ft as i};
