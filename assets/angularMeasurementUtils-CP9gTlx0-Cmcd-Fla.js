import{M as I,r as q}from"./Cyclical-BLSxUpe7-Bj8R2Yk-.js";import{H as z,I as c}from"./ShadowCastClear.glsl-CeOT_rAo-iOFMl8eB.js";import{af as M,R as L}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{L as T}from"./Polygon-D6wEPb3W-CpL9Efjx.js";import{o as _,b as j}from"./vec2f64-rIxtbMRN-Kai9mK1i.js";import{c as A,I as B,L as d}from"./vec32-CewSdTn3-DHOFKD0R.js";import{t as u}from"./collectionUtils-jDyktm0P-ArdXNs6F.js";import{x as p}from"./projectVectorToVector-Csv3NYZI-BsIKHfQD.js";import{p as v,q as D,z as E,h as F}from"./euclideanLengthMeasurementUtils-CpHh36Dt-B3Q3Npaw.js";function P(r,t){if(r==null||t==null)return;const e=b(r,t);return e!=null?c(e,"radians","geographic"):void 0}const b=(()=>{const r=u(),t=u();return(e,a)=>(d(r,e.x,e.y,e.z??0),d(t,a.x,a.y,a.z??0),X(r,t,e.spatialReference,a.spatialReference))})(),X=(()=>{const r=_(),t=u(),e=u();return(a,n,l,f)=>{if(A(a,n))return;const o=v(l),s=v(f);if(o&&s&&L(o,s)&&p(a,l,t,o)&&p(n,f,e,s)){const{azimuth:m}=D(k,t,e,o);return m!=null?M(m,"degrees","radians"):void 0}r[0]=n[0]-a[0],r[1]=n[1]-a[1];let i=T(j,r);return r[0]<0&&(i=C-i),i}})();function Y(r,t,e,a="absolute"){if(t&&e)switch(a){case"absolute":return P(t,e);case"relative":return y(x(r,t,e),"relative");case"relative-bilateral":return y(x(r,t,e),"relative-bilateral")}}function x(r,t,e){if(!r||!t||!e)return;const a=b(r,t),n=b(t,e);return a!=null&&n!=null?c(n-a,"radians","geographic"):void 0}function y(r,t){if(r!=null)switch(t){case"absolute":return Z(r);case"relative":{const e=h(r);let a=w.normalize(e,0,!0);return a===-180&&(a=180),c(a,"degrees","geographic")}case"relative-bilateral":{const e=h(r),a=Math.abs(w.normalize(e,0,!0));return c(a,"degrees","geographic")}}}function Z(r){const t=h(r),e=G.normalize(t,0,!0);return c(e,"degrees","geographic")}const rr=(()=>{const r=u();return(t,e,a,n,l,f="geodesic")=>{B(r,e);const o=h(l);if(f==="geodesic"){const g=v(a);if(g&&p(r,a,r,g))return F(t,r,o,n,g),t[2]=e[2],!!p(t,g,t,a)}const s=z(o,"geographic","arithmetic"),i=M(s,"degrees","radians"),m=e[0]+n*Math.cos(i),$=e[1]+n*Math.sin(i),H=e[2];return d(t,m,$,H),!0}})();function h(r){if(r!=null)return z(R(r),r.rotationType,"geographic")}function er(r){if(r!=null)return z(R(r),r.rotationType,"arithmetic")}function R(r){return M(r.value,r.unit,"degrees")}const k=new E,C=2*Math.PI,G=I,w=new q(-180,180);export{X as A,Z as B,y as M,Y as Z,P as _,er as e,h,rr as r};
