import{z as l}from"./Extent-CgDMOSRD-CU1qE5Kr.js";import{b as x}from"./Point-BfTTZoMu-BAT2Wq6O.js";import{c as y}from"./projectionUtils-BGH_5_I3-BySNUA-B.js";import{d as i}from"./PixelBlock-DA_u_GpM-weQWKsre.js";import{t as h,Y as O,f as g,G as k,N,A as B,y as J,H as P,q as b,j as w,J as z,K as v,g as T}from"./RasterSymbolizer-Dqn5Dve--B2hts7xc.js";import{K as D}from"./rasterFunctionHelper-Dh1b3BL7-CxBi_D0M.js";import{V as F,n as I}from"./rasterProjectionHelper-CKWxY3oy-CcS-Q5Ne.js";import{c as L,d as j,h as G}from"./PolynomialTransform-Q4rQG_Hj-7sX9Bcwm.js";import{Y as S,G as E}from"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import{B as K}from"./Color-CERqXxxY-BuYn26eI.js";import{x as R}from"./dataUtils-1NJ_tbX7-DOg3Y4ON.js";import"./index-CTl7hdrJ.js";import"./collectionUtils-jDyktm0P-ArdXNs6F.js";import"./reactiveUtils-SO2Ko3sy-BCLX8Jdy.js";import"./Polyline-CoiTLswR-BLagWJLS.js";import"./Polygon-D6wEPb3W-CpL9Efjx.js";import"./mathUtils-PIGhLnI9-B1tKUlUb.js";import"./vec42-B8VM4vXb-BnA9MysM.js";import"./vec4f64-DPb6J-GU-C7c2DqbZ.js";import"./typeUtils-DqrRcjBx-ZWdHcSIJ.js";import"./colorRamps-DswZzxkO-BqSFavfl.js";import"./Field-Cm_ZejYW-CwJZmSru.js";import"./fieldType-DVUzXtk_-tUuvnZJM.js";import"./reader-DcGs6kKN-DHJfK-tm.js";import"./SimpleObservable-CvFyr0NA-DXpoMYph.js";import"./aaBoundingRect-CjwcS2F3-D7aII9DY.js";import"./_commonjsHelpers-DCkdB7M8-DwXtFsJ3.js";import"./colorUtils-CeIi7j7j-nwrKvQYb.js";import"./jsonUtils-CmpazY1u-ateEpj4Q.js";var u;let c=u=class extends G{constructor(){super(...arguments),this.type="identity"}clone(){return new u}};S([K({IdentityXform:"identity"})],c.prototype,"type",void 0),c=u=S([E("esri.layers.support.rasterTransforms.IdentityTransform")],c);const A={GCSShiftXform:j,IdentityXform:c,PolynomialXform:L};function X(n){if(!n?.type)return null;const r=A[n?.type];if(r){const e=new r;return e.read(n),e}return null}function a(n){if(!n)return{result:null,transferList:[]};const{pixelBlock:r,transferList:e}=n.getTransferableObject();return{result:r,transferList:e}}class yr{convertVectorFieldData(r){const e=i.fromJSON(r.pixelBlock),s=a(h(e,r.type));return Promise.resolve(s)}convertPixelBlockToFeatures(r){const e=O({pixelBlock:i.fromJSON(r.pixelBlock),extent:l.fromJSON(r.extent),fieldNames:r.fieldNames,skipFactor:r.skipFactor,skipSpatialReference:!0,pixelIdOffset:r.pixelIdOffset,imageRowSize:r.imageRowSize});return Promise.resolve(e)}computeStatisticsHistograms(r){const e=i.fromJSON(r.pixelBlock),s=g(e,{histogramSize:r.histogramSize,includeSkewnessKurtosis:r.includeSkewnessKurtosis});return Promise.resolve(s)}async decode(r){return a(await k(r.data,r.options))}symbolize(r){r.pixelBlock=i.fromJSON(r.pixelBlock),r.extent=r.extent?l.fromJSON(r.extent):null;const e=a(this.symbolizer.symbolize(r));return Promise.resolve(e)}highlightPixels(r){const e=i.fromJSON(r.pixelBlock),s=i.fromJSON(r.renderedPixelBlock);return N(e,s,r.highlightOptions),Promise.resolve(s.toJSON())}async updateSymbolizer(r){this.symbolizer=B.fromJSON(r.symbolizerJSON),r.histograms&&this.symbolizer?.rendererJSON.type==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=r.histograms)}async updateRasterFunction(r){this.rasterFunction=D(r.rasterFunctionJSON)}async process(r){return a(this.rasterFunction.process({extent:l.fromJSON(r.extent),primaryPixelBlocks:r.primaryPixelBlocks.map(e=>e!=null?i.fromJSON(e):null),primaryPixelSizes:r.primaryPixelSizes?.map(e=>e!=null?x.fromJSON(e):null),primaryRasterIds:r.primaryRasterIds}))}stretch(r){const e=a(this.symbolizer.simpleStretch(i.fromJSON(r.srcPixelBlock),r.stretchParams));return Promise.resolve(e)}estimateStatisticsHistograms(r){const e=J(i.fromJSON(r.srcPixelBlock));return Promise.resolve(e)}split(r){const e=P(i.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel??0,r.useBilinear===!1),s=[];let t;return e&&(t=new Map,e.forEach((o,f)=>{if(o){const{pixelBlock:p,transferList:m}=o.getTransferableObject();t.set(f,p),m.forEach(d=>{s.includes(d)||s.push(d)})}})),Promise.resolve({result:t,transferList:s})}clipTile(r){const e=i.fromJSON(r.pixelBlock),s=a(b({...r,pixelBlock:e}));return Promise.resolve(s)}async mosaicAndTransform(r){const e=r.srcPixelBlocks.map(m=>m?new i(m):null),s=w(e,r.srcMosaicSize,{blockWidths:r.blockWidths,alignmentInfo:r.alignmentInfo,clipOffset:r.clipOffset,clipSize:r.clipSize});let t,o=s;r.coefs&&(o=z(s,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation)),r.projectDirections&&r.gcsGrid&&(t=v(r.destDimension,r.gcsGrid),o=T(o,r.isUV?"vector-uv":"vector-magdir",t));const{result:f,transferList:p}=a(o);return{result:{pixelBlock:f,localNorthDirections:t},transferList:p}}async createFlowMesh(r,e){const s={data:new Float32Array(r.flowData.buffer),mask:new Uint8Array(r.flowData.maskBuffer),width:r.flowData.width,height:r.flowData.height},{vertexData:t,indexData:o}=await R(r.meshType,r.simulationSettings,s,e.signal);return{result:{vertexBuffer:t.buffer,indexBuffer:o.buffer},transferList:[t.buffer,o.buffer]}}async getProjectionOffsetGrid(r){const e=l.fromJSON(r.projectedExtent),s=l.fromJSON(r.srcBufferExtent);let t=null;r.datumTransformationSteps?.length&&(t=new y({steps:r.datumTransformationSteps})),await F();const o=r.rasterTransform?X(r.rasterTransform):null;return I({...r,projectedExtent:e,srcBufferExtent:s,datumTransformation:t,rasterTransform:o})}}export{yr as default};
