const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/RealisticTree.glsl-IWCjmMLr.js","assets/mathUtils-PIGhLnI9.js","assets/Polygon-BdLNJfwi.js","assets/jsonMap-Bs3hmeCU.js","assets/Extent-Bbnm65bN.js","assets/Point-BN8RINcc.js","assets/reader-DcGs6kKN.js","assets/index-C-2WWcaK.js","assets/index-Cv2ko1Ob.css","assets/aaBoundingRect-CrU5VtR_.js","assets/mat4-n_G6OS58.js","assets/collectionUtils-Dk3LoVuX.js","assets/reactiveUtils-SO2Ko3sy.js","assets/SimpleObservable-CvFyr0NA.js","assets/mat4f64-q_b6UJoq.js","assets/vec2f64-rIxtbMRN.js","assets/vec32-CNF8e3LG.js","assets/vec4f64-DPb6J-GU.js","assets/BufferView-BMlFYMIb.js","assets/vec42-CkbV-zLi.js","assets/Emissions.glsl-B8XKMjLy.js","assets/Color-CERqXxxY.js","assets/InterleavedLayout-8W9JN4bc.js","assets/types-BKo2foNY.js","assets/enums-B4pqBiXb.js","assets/VertexElementDescriptor-BlxU8vCE.js","assets/projectionUtils-zKDw1yLq.js","assets/Polyline-BtUG5wiC.js","assets/aaBoundingBox-CtkshuSS.js","assets/DoubleArray-DExKNiTh.js","assets/meshVertexSpaceUtils-DM2fDb9e.js","assets/MeshLocalVertexSpace-oQGry7Qx.js","assets/projectVectorToVector-DkxXb83V.js","assets/projectPointToVector-CELlCh-8.js","assets/Graphic-BiQTZi7k.js","assets/getPopupProvider-DjIxdahS.js","assets/lengthUtils-Ceo6858g.js","assets/date-IqUzANpt.js","assets/Layer-Ciy6IOGe.js","assets/jsonUtils-UGNxUp3z.js","assets/typeUtils-Dk-Jta7H.js","assets/createFeatureId-CVwTD0fV.js","assets/typeUtils-W6WEjFtn.js","assets/lineMarkers-CDwLe3J6.js","assets/PolygonSymbol3D-D50k8Fcq.js","assets/ExtrudeSymbol3DLayer-DSc1ou2x.js","assets/screenUtils-BitdhK1O.js","assets/opacityUtils-DuFH0EC9.js","assets/Font-Ct7_LYCJ.js","assets/SimpleFillSymbol-CDawtd9z.js","assets/SimpleMarkerSymbol-BGAFRS9_.js","assets/PictureMarkerSymbol-LudhOruE.js","assets/TextSymbol-DH6PXxVy.js","assets/vec3f32-WCVSSNPR.js","assets/Indices-D0_UQPPr.js","assets/plane-CYSvzg5X.js","assets/vector-CGHTqcz0.js","assets/quatf64-CCm9z-pX.js","assets/sphere-9lseHxo-.js","assets/orientedBoundingBox-VXwBwem5.js","assets/quat-CK9e8_eG.js","assets/spatialReferenceEllipsoidUtils-T3ZM6b8E.js","assets/computeTranslationToOriginAndRotation-Cz93wRWF.js","assets/memoryEstimations-Bd726a_p.js","assets/HUDIntersectorResult-D3KkIdaq.js","assets/Intersector-BDgm95L3.js","assets/frustum-BypfKDJS.js"])))=>i.map(i=>d[i]);
import{e as ne,r as or,t as Cl}from"./mat4f64-q_b6UJoq.js";import{c as ce,o as U,p as da,s as Z,H as We,R as Xe,P as we,Z as ln,X as us,g as q,r as te,_ as Ae,A as Te,K as fa,E as Fe,q as qe,u as pe,v as Es,I as lr,y as pa,W as El,N as Il}from"./vec32-CNF8e3LG.js";import{e as Al,A as Fl}from"./Indices-D0_UQPPr.js";import{_ as f,m as x,a as zt,al as rt,v as Rl,r as Ol,l as Mr,i as yt,s as Y,G as Sr,bb as cr,a8 as Pl,aG as xi,bY as ma,aq as Dl,bZ as zl,b_ as $r,n as Nl,d as ur,g as Ll,t as Ct,a7 as Vl,b$ as Bl,ap as Cr,H as Si,c0 as Hl,Q as jl,aA as Is,c1 as ga,c2 as Gl,c3 as Ul,ar as Ni,am as vi,A as Wl,w as kl,a6 as ql,o as Xl}from"./jsonMap-Bs3hmeCU.js";import{s as W,h as Yl,o as er,m as Zl,T as hr,f as cn,g as ri,J as un,p as Kl,y as Jl,l as Ql,I as hn}from"./BufferView-BMlFYMIb.js";import{f as ec,l as tc,n as g,N as dn,r as ve,i as ot,t as bi,o as $i,k as Li,j as Ci}from"./collectionUtils-Dk3LoVuX.js";import{b as mt,P as Er,I as va,V as _a,S as ic,v as rc,k as xa,a as sc,d as ba,W as nc,e as ac,s as ya}from"./sphere-9lseHxo-.js";import{h as wa,x as oc,d as Ta,m as lc,k as cc,S as uc,w as hc,O as dc,e as fc,q as pc,A as mc,b as gc,v as Ma}from"./frustum-BypfKDJS.js";import{f as vc}from"./vector-CGHTqcz0.js";import{t as h,i as ie,g as _c,e as ue,a as ze,n as G,b as Sa,c as tr,r as xc,f as xt,h as kt,j as Ee,k as $a,l as dr,o as Ot,x as bc,m as jr}from"./Emissions.glsl-B8XKMjLy.js";import{r as Le,o as ge,M as lt,b as fr,s as _e,l as Ri}from"./mathUtils-PIGhLnI9.js";import{_ as yc,A as wc,R as Ce,O as pr,Y as Q,E as A,G as mr,T as yi,N as hs,S as Tc,D as Gr,C as Ur,U as Mc,n as Sc}from"./enums-B4pqBiXb.js";import{Z as $c,u as Cc,d as Ec}from"./aaBoundingBox-CtkshuSS.js";import{aq as Ic,aA as Ac,aF as Fc,a as wt,ar as Rc,P as ds,C as Ca,e as Ea,E as Ia,F as Pt,$ as Oc,M as Pc,D as Dc,a0 as ai}from"./Polygon-BdLNJfwi.js";import{n as ei,c as Ei,h as ir,s as fs,A as zc,C as Nc,X as Lc,R as Vc,l as Aa,p as Bc,b as Hc,r as jc,f as Gc,i as gr,o as Uc,x as Wc,m as kc,H as Fa,G as Ra}from"./mat4-n_G6OS58.js";import{G as qc,K as Xc}from"./orientedBoundingBox-VXwBwem5.js";import{_ as Oi}from"./index-C-2WWcaK.js";import{r as ps,n as at,i as Yc}from"./vec4f64-DPb6J-GU.js";import{t as ms,Q as As}from"./InterleavedLayout-8W9JN4bc.js";import{l as Oa,h as Zc,i as Pa}from"./reactiveUtils-SO2Ko3sy.js";import{L as Kc,a as fn,j as pn,q as Jc,O as mn,Z as Qc,k as eu,g as tu}from"./plane-CYSvzg5X.js";import{f as iu,y as ru,u as su}from"./screenUtils-BitdhK1O.js";import{m as gn,L as vn,E as Wr,a as qt,x as _n,z as Vi,s as $e,p as nu}from"./vec42-CkbV-zLi.js";import{s as Fs,a2 as au,n as Lt,m as xn}from"./lengthUtils-Ceo6858g.js";import{r as Da,n as Pi,t as bn,a as ou}from"./vec2f64-rIxtbMRN.js";import{a as lu,r as cu}from"./Cyclical-BLSxUpe7.js";import{b as gt,s as kr,a5 as Di,F as uu,f as za,ar as hu,H as du,an as fu,Z as yn,M as pu,br as mu}from"./Point-BN8RINcc.js";import{o as gu}from"./reader-DcGs6kKN.js";import"./projectionUtils-zKDw1yLq.js";import{i as gs}from"./projectPointToVector-CELlCh-8.js";import{n as vr}from"./projectVectorToVector-DkxXb83V.js";import{F as vu}from"./aaBoundingRect-CrU5VtR_.js";import{c as _u,o as vs,f as rr}from"./HUDIntersectorResult-D3KkIdaq.js";import{z as Rs}from"./Extent-Bbnm65bN.js";import{A as xu}from"./normalizeUtils-BDt2F_N3.js";import{n as Na,a as si,t as bu}from"./VertexElementDescriptor-BlxU8vCE.js";import{p as yu}from"./Color-CERqXxxY.js";import{r as wu}from"./videoUtils-Dwx3AEgj.js";let Ft=class extends ec{constructor(e){super(e),this.row=0,this.column=0,this.rows=1,this.columns=1}equals(e){return e!=null&&this.row===e.row&&this.rows===e.rows&&this.column===e.column&&this.columns===e.columns}};f([x({type:Number,nonNullable:!0,json:{read:!1,write:!1}})],Ft.prototype,"row",void 0),f([x({type:Number,nonNullable:!0,json:{read:!1,write:!1}})],Ft.prototype,"column",void 0),f([x({type:Number,nonNullable:!0,json:{read:!1,write:!1}})],Ft.prototype,"rows",void 0),f([x({type:Number,nonNullable:!0,json:{read:!1,write:!1}})],Ft.prototype,"columns",void 0),Ft=f([zt("esri.CameraLayout")],Ft);const La=Ft;let Ue=class extends tc(Rl){constructor(...e){super(...e),this.position=new gt([0,0,0]),this.heading=0,this.tilt=0,this.fov=55,this.layout=new La}normalizeCtorArgs(e,i,r,s){if(e&&typeof e=="object"&&("x"in e||Array.isArray(e))){const n={position:e};return i!=null&&(n.heading=i),r!=null&&(n.tilt=r),s!=null&&(n.fov=s),n}return e}writePosition(e,i,r,s){const n=e.clone();n.x=rt(e.x||0),n.y=rt(e.y||0),n.z=e.hasZ?rt(e.z||0):e.z,i[r]=n.write({},s)}readPosition(e,i){const r=new gt;return r.read(e,i),r.x=rt(r.x||0),r.y=rt(r.y||0),r.z=r.hasZ?rt(r.z||0):r.z,r}equals(e){return e!=null&&this.tilt===e.tilt&&this.heading===e.heading&&this.fov===e.fov&&this.position.equals(e.position)&&this.layout.equals(e.layout)}};f([x({type:gt,json:{write:{isRequired:!0}}})],Ue.prototype,"position",void 0),f([Ol("position")],Ue.prototype,"writePosition",null),f([gu("position")],Ue.prototype,"readPosition",null),f([x({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}}),kr(t=>lu.normalize(rt(t)))],Ue.prototype,"heading",void 0),f([x({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}}),kr(t=>Le(rt(t),-180,180))],Ue.prototype,"tilt",void 0),f([x({type:Number,nonNullable:!0,json:{default:55,write:!0}}),kr(t=>Le(rt(t,55),1,170))],Ue.prototype,"fov",void 0),f([x({type:La,nonNullable:!0,json:{read:!1,write:!1}})],Ue.prototype,"layout",void 0),Ue=f([zt("esri.Camera")],Ue);const Tu=Ue;function Mu(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/e)}function Su(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/i)}function $u(t,e,i){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}function Cu(t,e,i){return 2*Math.atan(i*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}var _s;let z=_s=class extends Mr{constructor(t){super(t),this._ray=mt(),this._viewport=ps(0,0,1,1),this._padding=ps(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=Da(1,1e3),this._viewDirty=!0,this._viewMatrix=ne(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=ne(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=ne(),this._frustumDirty=!0,this._frustum=wa(),this._fullViewport=at(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=g(),this._up=g(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return ce(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){ei(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),U(g(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),U(g(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),U(g(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=gn(at(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&vn(t,e)?e:t}get screenPadding(){if(this.pixelRatio===1)return this._padding;const t=gn(at(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&vn(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[3],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[2],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[1]+this._padding[3]}set fullWidth(t){this.width=t-(this._padding[1]+this._padding[3])}get fullHeight(){return this._viewport[3]+this._padding[0]+this._padding[2]}set fullHeight(t){this.height=t-(this._padding[0]+this._padding[2])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[3],this._fullViewport[1]=this._viewport[1]-this._padding[2],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){Wr(this._padding,t)||(this._viewport[0]+=t[3]-this._padding[3],this._viewport[1]+=t[2]-this._padding[2],this._viewport[2]-=t[1]+t[3]-(this._padding[1]+this._padding[3]),this._viewport[3]-=t[0]+t[2]-(this._padding[0]+this._padding[2]),qt(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(Ei(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return ir(ne(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||ne()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return $u(this._fov,this.width,this.height)}set fovX(t){this._fov=Mu(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return Cu(this._fov,this.width,this.height)}set fovY(t){this._fov=Su(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return da(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(ir(this._viewInverseTransposeMatrix,this.viewMatrix),fs(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const{near:e,far:i}=this;return 2*e*i/(i+e-t*(i-e))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}get _projectionMatrixInternal(){const t=this.width,e=this.height,i=this.near*Math.tan(this.fovY/2)*2,r=i*this._aspect,s=i/this.rows,n=r/this.columns,a=-r/2+this.column*n,l=a+n,o=-i/2+this.row*s,c=o+s,u=zc(ne(),a*(1+2*this._padding[3]/t),l*(1+2*this._padding[1]/t),o*(1+2*this._padding[2]/e),c*(1+2*this._padding[0]/e),this.near,this.far),d=this._get("projectionMatrix");return d&&Nc(d,u)?d:u}copyFrom(t){Z(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,qt(this._viewport,t.viewport),this.notifyChange("_viewport"),qt(this._padding,t.padding),this.notifyChange("_padding"),Ic(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(ei(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(oc(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(ei(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),qt(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up,this.fov=t.fov}clone(){return new _s().copyFrom(this)}equals(t){return We(this.eye,t.eye)&&We(this.center,t.center)&&We(this.up,t.up)&&Wr(this._viewport,t.viewport)&&Wr(this._padding,t.padding)&&Ac(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const e=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||_n(t.screenPadding,this.screenPadding)>=e||_n(this.screenViewport,t.screenViewport)>=e||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;Xe(re,t.eye,t.center),Xe(Ge,this.eye,this.center);const i=we(re,Ge),r=ln(re),s=ln(Ge),n=5e-4;return i*i>=(1-1e-10)*r*s&&us(t.eye,this.eye)<Math.max(r,s)*n*n}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs(vc(this.viewForward,ce(re,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=iu()){return t[0]=(this.padding[3]+this.width/2)/this.pixelRatio,t[1]=(this.padding[0]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,i=.5){return t[0]=this.padding[3]+this.width*e,t[1]=this.padding[2]+this.height*i,t[2]=.5,t}setGLViewport(t){const e=this.viewport,i=this.padding;t.setViewport(e[0]-i[3],e[1]-i[2],e[2]+i[1]+i[3],e[3]+i[0]+i[2])}applyProjection(t,e){t!==B&&Z(B,t),B[3]=1,Vi(B,B,this.projectionMatrix);const i=Math.abs(B[3]);q(B,B,1/i);const r=this.fullViewport;e[0]=ge(0,r[0]+r[2],.5+.5*B[0]),e[1]=ge(0,r[1]+r[3],.5+.5*B[1]),e[2]=.5*(B[2]+1),e[3]=i}unapplyProjection(t,e){const i=this.fullViewport;B[0]=(t[0]/(i[0]+i[2])*2-1)*t[3],B[1]=(t[1]/(i[1]+i[3])*2-1)*t[3],B[2]=(2*t[2]-1)*t[3],B[3]=t[3],this.inverseProjectionMatrix!=null&&(Vi(B,B,this.inverseProjectionMatrix),e[0]=B[0],e[1]=B[1],e[2]=B[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,qr),this.renderToScreen(qr,e),e}projectToRenderScreen(t,e){if(B[0]=t[0],B[1]=t[1],B[2]=t[2],B[3]=1,Vi(B,B,this.viewProjectionMatrix),B[3]===0)return null;const i=B;q(i,i,1/Math.abs(B[3]));const r=this.fullViewport,s=ge(0,r[0]+r[2],.5+.5*i[0]),n=ge(0,r[1]+r[3],.5+.5*i[1]);return"x"in e?(e.x=s,e.y=n):(e[0]=s,e[1]=n,e.length>2&&(e[2]=.5*(i[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,qr),e)}unprojectFromRenderScreen(t,e){if(Ei(Bi,this.projectionMatrix,this.viewMatrix),!ir(Bi,Bi))return null;const i=this.fullViewport;return B[0]=2*(t[0]-i[0])/i[2]-1,B[1]=2*(t[1]-i[1])/i[3]-1,B[2]=2*t[2]-1,B[3]=1,Vi(B,B,Bi),B[3]===0?null:(e[0]=B[0]/B[3],e[1]=B[1]/B[3],e[2]=B[2]/B[3],e)}constrainWindowSize(t,e,i,r){const s=t*this.pixelRatio,n=e*this.pixelRatio,a=Math.max(s-i/2,0),l=Math.max(this.fullHeight-n-r/2,0),o=-Math.min(s-i/2,0),c=-Math.min(this.fullHeight-n-r/2,0),u=i-o- -Math.min(this.fullWidth-s-i/2,0),d=r-c- -Math.min(n-r/2,0);return[Math.round(a),Math.round(l),Math.round(u),Math.round(d)]}computeUp(t){t===1?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const i=t[0]*this.pixelRatio,r=this.fullHeight-t[1]*this.pixelRatio;return e[0]=i,e[1]=r,e}renderToScreen(t,e){const i=t[0]/this.pixelRatio,r=(this.fullHeight-t[1])/this.pixelRatio;e[0]=i,e[1]=r}_computeUpGlobal(){ce(re,this.center,this.eye);const t=te(this.center);t<1?We(this._up,dn)&&(Z(this._up,dn),this._markViewDirty(),this.notifyChange("_up")):Math.abs(we(re,this.center))>.9999*te(re)*t||(Ae(Ge,re,this.center),Ae(Ge,Ge,re),Te(Ge,Ge),We(this._up,Ge)||(Z(this._up,Ge),this.notifyChange("_up"),this._markViewDirty()))}_computeUpLocal(){fa(re,this.eye,this.center),Math.abs(re[2])<=.9999&&(q(re,re,re[2]),U(re,-re[0],-re[1],1-re[2]),Te(re,re),We(this._up,re)||(Z(this._up,re),this.notifyChange("_up"),this._markViewDirty()))}_compareAndSetView(t,e,i=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?We(t,e)||(Z(e,t),this._markViewDirty(),i.length&&this.notifyChange(i)):yt.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Ta(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Lc(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};f([x()],z.prototype,"_viewport",void 0),f([x()],z.prototype,"_padding",void 0),f([x()],z.prototype,"_fov",void 0),f([x()],z.prototype,"_nearFar",void 0),f([x()],z.prototype,"_viewDirty",void 0),f([x()],z.prototype,"_viewMatrix",void 0),f([x()],z.prototype,"_pixelRatio",void 0),f([x()],z.prototype,"pixelRatio",null),f([x()],z.prototype,"row",void 0),f([x()],z.prototype,"column",void 0),f([x()],z.prototype,"_rows",void 0),f([x()],z.prototype,"rows",null),f([x()],z.prototype,"_columns",void 0),f([x()],z.prototype,"columns",null),f([x()],z.prototype,"eye",null),f([x()],z.prototype,"center",null),f([x()],z.prototype,"_center",void 0),f([x()],z.prototype,"up",null),f([x()],z.prototype,"_up",void 0),f([x()],z.prototype,"viewMatrix",null),f([x({readOnly:!0})],z.prototype,"viewForward",null),f([x({readOnly:!0})],z.prototype,"viewUp",null),f([x({readOnly:!0})],z.prototype,"viewRight",null),f([x({readOnly:!0})],z.prototype,"nearFar",null),f([x()],z.prototype,"near",null),f([x()],z.prototype,"far",null),f([x()],z.prototype,"viewport",null),f([x({readOnly:!0})],z.prototype,"screenViewport",null),f([x({readOnly:!0})],z.prototype,"screenPadding",null),f([x()],z.prototype,"x",null),f([x()],z.prototype,"y",null),f([x()],z.prototype,"width",null),f([x()],z.prototype,"height",null),f([x()],z.prototype,"fullWidth",null),f([x()],z.prototype,"fullHeight",null),f([x({readOnly:!0})],z.prototype,"_aspect",null),f([x()],z.prototype,"padding",null),f([x({readOnly:!0})],z.prototype,"projectionMatrix",null),f([x({readOnly:!0})],z.prototype,"inverseProjectionMatrix",null),f([x()],z.prototype,"fov",null),f([x()],z.prototype,"fovX",null),f([x()],z.prototype,"fovY",null),f([x()],z.prototype,"viewInverseTransposeMatrix",null),f([x({readOnly:!0})],z.prototype,"_projectionMatrixInternal",null),f([x()],z.prototype,"relativeElevation",void 0),z=_s=f([zt("esri.views.3d.webgl.RenderCamera")],z);const Va=z,B=at(),Bi=ne(),re=g(),Ge=g(),qr=ru();let xs=class bs{constructor(e=1/0,i=-1/0){this.near=e,this.far=i}set(e,i){this.near=e,this.far=i}union(e){e!=null&&(this.near=Math.min(this.near,e.near),this.far=Math.max(this.far,e.far))}within(e){return this.near<=e&&e<=this.far}equals(e){return this.near===e.near&&this.far===e.far}static{this.Zero=new bs(0,0)}static{this.Infinite=new bs}},Eu=class{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerViewUids=[],this.store=2,this.normalRequired=!0,this.excludeLabels=!1}},Iu=class{constructor(){this._transform=ne(),this._transformInverse=new Hi({value:this._transform},ir,ne),this._transformInverseTranspose=new Hi(this._transformInverse,fs,ne),this._transformTranspose=new Hi({value:this._transform},fs,ne),this._transformInverseRotation=new Hi({value:this._transform},Fc,wt)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(e){ei(this._transform,e)}multiplyTransform(e){Ei(this._transform,this._transform,e)}set(e){ei(this._transform,e),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(e,i){this.setTransformMatrix(e),this.multiplyTransform(i),this._invalidateLazyTransforms()}},Hi=class{constructor(e,i,r){this._original=e,this._update=i,this._dirty=!0,this._transform=r()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}},Au=class{constructor(e=0){this.offset=e,this.tmpVertex=g()}applyToVertex(e,i,r){const s=U(Os,e,i,r),n=pe(Ba,s,this.localOrigin),a=this.offset/te(n);return qe(this.tmpVertex,s,n,a),this.tmpVertex}applyToAabb(e){const i=Ou,r=Pu,s=Du;for(let o=0;o<3;++o)i[o]=e[0+o]+this.localOrigin[o],r[o]=e[3+o]+this.localOrigin[o],s[o]=i[o];const n=this.applyToVertex(i[0],i[1],i[2]);for(let o=0;o<3;++o)e[o]=n[o],e[o+3]=n[o];const a=o=>{const c=this.applyToVertex(o[0],o[1],o[2]);for(let u=0;u<3;++u)e[u]=Math.min(e[u],c[u]),e[u+3]=Math.max(e[u+3],c[u])};for(let o=1;o<8;++o){for(let c=0;c<3;++c)s[c]=o&1<<c?r[c]:i[c];a(s)}let l=0;for(let o=0;o<3;++o)i[o]*r[o]<0&&(l|=1<<o);if(l!==0&&l!==7){for(let o=0;o<8;++o)if((l&o)===0){for(let c=0;c<3;++c)s[c]=l&1<<c?0:o&1<<c?i[c]:r[c];a(s)}}for(let o=0;o<3;++o)e[o]-=this.localOrigin[o],e[o+3]-=this.localOrigin[o];return e}},Fu=class{constructor(e=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=g(),this._tmpMbs=Er(),this._tmpObb=new qc,this._resetOffset(e)}_resetOffset(e){this._offset=e,this._totalOffset=e}set offset(e){this._resetOffset(e)}get offset(){return this._offset}set componentOffset(e){this._totalOffset=this._offset+e}set localOrigin(e){this.componentLocalOriginLength=te(e)}applyToVertex(e,i,r){const s=U(Os,e,i,r),n=U(Ba,e,i,r+this.componentLocalOriginLength),a=this._totalOffset/te(n);return qe(this._tmpVertex,s,n,a),this._tmpVertex}applyToAabb(e){const i=this.componentLocalOriginLength,r=e[0],s=e[1],n=e[2]+i,a=e[3],l=e[4],o=e[5]+i,c=Math.abs(r),u=Math.abs(s),d=Math.abs(n),m=Math.abs(a),v=Math.abs(l),p=Math.abs(o),_=.5*(1+Math.sign(r*a))*Math.min(c,m),b=.5*(1+Math.sign(s*l))*Math.min(u,v),y=.5*(1+Math.sign(n*o))*Math.min(d,p),M=Math.max(c,m),w=Math.max(u,v),S=Math.max(d,p),I=Math.sqrt(_*_+b*b+y*y),P=Math.sign(c+r),F=Math.sign(u+s),$=Math.sign(d+n),C=Math.sign(m+a),O=Math.sign(v+l),T=Math.sign(p+o),E=this._totalOffset;if(I<E)return e[0]-=(1-P)*E,e[1]-=(1-F)*E,e[2]-=(1-$)*E,e[3]+=C*E,e[4]+=O*E,e[5]+=T*E,e;const R=E/Math.sqrt(M*M+w*w+S*S),D=E/I,N=D-R,V=-N;return e[0]+=r*(P*V+D),e[1]+=s*(F*V+D),e[2]+=n*($*V+D),e[3]+=a*(C*N+R),e[4]+=l*(O*N+R),e[5]+=o*(T*N+R),e}applyToMbs(e){const i=va(e),r=te(i),s=this._totalOffset/r,n=qe(Ha,i,i,s),a=e[3]+e[3]*this._totalOffset/r;return _a(this._tmpMbs,n,a),this._tmpMbs}applyToObb(e){return Xc(e,this._totalOffset,this._totalOffset,1,this._tmpObb),this._tmpObb}},Ru=class{constructor(e=0){this.offset=e,this.sphere=Er(),this.tmpVertex=g()}applyToVertex(e,i,r){const s=this.objectTransform.transform,n=U(Os,e,i,r),a=Fe(n,n,s),l=this.offset/te(a);qe(a,a,a,l);const o=this.objectTransform.inverse;return Fe(this.tmpVertex,a,o),this.tmpVertex}applyToMinMax(e,i){const r=this.offset/te(e);qe(e,e,e,r);const s=this.offset/te(i);qe(i,i,i,s)}applyToAabb(e){const i=this.offset/Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);e[0]+=e[0]*i,e[1]+=e[1]*i,e[2]+=e[2]*i;const r=this.offset/Math.sqrt(e[3]*e[3]+e[4]*e[4]+e[5]*e[5]);return e[3]+=e[3]*r,e[4]+=e[4]*r,e[5]+=e[5]*r,e}applyToBoundingSphere(e){const i=va(e),r=te(i),s=this.offset/r,n=qe(Ha,i,i,s),a=e[3]+e[3]*this.offset/r;return _a(this.sphere,n,a),this.sphere}};const wn=new Ru;function ys(t){return t!=null?(wn.offset=t,wn):null}const Tn=new Fu;function ov(t){return t!=null?(Tn.offset=t,Tn):null}const Mn=new Au;function lv(t){return t!=null?(Mn.offset=t,Mn):null}const cv="terrain",Os=g(),Ba=g(),Ou=g(),Pu=g(),Du=g(),Ha=g(),Sn=1e-5;let zu=class{constructor(e){this.options=new Eu,this._results=new Nu,this.transform=new Iu,this.camera=new Va,this.tolerance=Sn,this.verticalOffset=null,this._ray=mt(),this._rayEnd=g(),this._rayBeginTransformed=g(),this._rayEndTransformed=g(),this.viewingMode=e??1}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(e,i,r){this.resetWithRay(ic(e,i,this._ray),r)}resetWithRay(e,i){this.camera=i,e!==this._ray&&rc(e,this._ray),this.options.verticalOffset!==0?this.viewingMode===2?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,pe(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(e=null,i,r,s,n){this.point=i,this.filterPredicate=s,this.tolerance=r??Sn;const a=ys(this.verticalOffset);if(e&&e.length>0){const l=n?o=>{n(o)&&this.intersectObject(o)}:o=>{this.intersectObject(o)};for(const o of e){const c=o.getSpatialQueryAccelerator?.();c!=null?(a!=null?c.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,l,a):c.forEachAlongRay(this._ray.origin,this._ray.direction,l),this.options.selectionMode&&this.options.hud&&c.forEachDegenerateObject(l)):o.objects.forEach(u=>l(u))}}this.sortResults()}intersectObject(e){const i=e.geometries;if(!i)return;const r=e.effectiveTransformation,s=ys(this.verticalOffset);for(const n of i){if(!n.visible)continue;const{material:a,id:l}=n;if(!a.visible)continue;this.transform.setAndInvalidateLazyTransforms(r,n.transformation),Fe(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),Fe(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const o=this.transform.transform;s!=null&&(s.objectTransform=this.transform),a.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(c,u,d,m)=>this.handleObjectIntersection({object:e,geometryId:l,primitiveIndex:d},c,u,o,m))}}handleObjectIntersection(e,i,r,s,n){if(i<0||this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,i))return;const a=n?this._results.hud:this._results;e=n?new _u(e,n):e;const l=n?o=>o.set(1,e,i,r):o=>o.set(4,e,i,r,s);if((a.min.distance==null||i<a.min.distance)&&l(a.min),this.options.store!==0&&(a.max.distance==null||i>a.max.distance)&&l(a.max),this.options.store===2)if(n){const o=new vs(this._ray);l(o),this._results.hud.all.push(o)}else{const o=new rr(this._ray);l(o),this._results.all.push(o)}}sortResults(e=this._results.all){e.sort((i,r)=>i.distance!==r.distance?(i.distance??0)-(r.distance??0):i.drapedLayerOrder!==r.drapedLayerOrder?$n(i.drapedLayerOrder,r.drapedLayerOrder):$n(i.renderPriority,r.renderPriority))}};function $n(t,e){return(e??-Number.MAX_VALUE)-(t??-Number.MAX_VALUE)}let Nu=class{constructor(){this.min=new rr(mt()),this.max=new rr(mt()),this.hud={min:new vs(mt()),max:new vs(mt()),all:new Array},this.ground=new rr(mt()),this.all=[]}init(e){this.min.init(e),this.max.init(e),this.ground.init(e),this.all.length=0,this.hud.min.init(e),this.hud.max.init(e),this.hud.all.length=0}};function dv(t,e,i,r){return t.renderCoordsHelper.fromRenderCoords(e.eye,_r,r)!=null&&vu(i,_r)}function Lu(t,e){return t.elevationProvider?t.elevationProvider.getElevation(e[0],e[1],e[2],t.renderCoordsHelper.spatialReference,"ground")??0:0}function Vu(t,e,i,r){const s=t.state.camera.clone();e&&i&&r&&(s.eye=e,s.center=i,s.up=r),Bu(t,s.ray,ut)||Z(ut,s.center);const n=t.state.constraints,a=n.minimumPoiDistance;if(Es(s.eye,ut)<a){const l=n.collision.enabled;Z(Et,s.viewForward),q(Et,Et,a),l?s.eye=ce(_r,ut,Et):pe(ut,s.eye,Et);const o=t.renderCoordsHelper,c=o.getAltitude(s.eye),u=n.collision.elevationMargin;l&&c<u&&(ce(Et,ut,s.eye),s.eye=o.setAltitude(_r,u,s.eye),pe(ut,s.eye,Et))}return s.center=ut,s}function Cn(t,e,i){if(!t.state.isGlobal||!t.stateManager.constraintsManager)return!1;const r=Lu(t,e),s=t.stateManager.constraintsManager.nearFarHeuristic;let n=En.get(t);n===void 0&&(n=new Va,En.set(t,n)),n.eye=e,n.center=i;const{far:a}=s.compute(n,t.renderDataExtent,xs.Infinite,r),l=a*a;return Es(e,i)>l}function Bu(t,e,i){let r=ws[t.viewingMode];r||(r=new zu(t.state.viewingMode),r.options.backfacesTerrain=!t.state.isGlobal,r.options.invisibleTerrain=!0,ws[t.viewingMode]=r);const{isGlobal:s}=t.state;return!(!t.sceneIntersectionHelper.intersectRay(e,r,i)||Cn(t,e.origin,i))||!(!t.renderCoordsHelper.intersectManifold(e,0,i)||Cn(t,e.origin,i))||!!s&&Hu(e,i,Di(t.spatialReference).radius)}function Hu(t,e,i){const r=we(t.origin,t.origin)-i*i,s=r>0?Math.sqrt(r)/3:1;return q(e,t.direction,s/te(t.direction)),pe(e,e,t.origin),!0}let ws={};function fv(){ws={}}const _r=g(),ut=g(),Et=g(),En=new WeakMap;function ju(t,e){const i=[],r=[];return ji(i,t,e,0),ji(r,i,e,1),ji(i,r,e,2),ji(r,i,e,3),r}function ji(t,e,i,r){const s=Gu(i,r);if(t.length=0,e.length){s(Gi,e[0],e[0])===1&&li(t,e[0]);for(let n=0;n<e.length;n++){const a=e[n===e.length-1?0:n+1];switch(s(Gi,e[n],a)){case 1:li(t,a);break;case 3:li(t,bn(Gi));break;case 2:li(t,bn(Gi)),li(t,a)}}}}function li(t,e){t.length!==0&&Rc(t.at(-1),e)||t.push(e)}function Gu(t,e){const i=e===0||e===2?0:1,r=t[e],s=e===0||e===1?1:-1,n=i===0?1:0;return(a,l,o)=>{if(l[i]<r&&o[i]<r)return s===1?0:1;if(l[i]>r&&o[i]>r)return s===1?1:0;const c=(o[n]-l[n])/(o[i]-l[i]),u=l[n]+c*(r-l[i]);return a[i]=r,a[n]=u,(l[i]<r?1:-1)*s>0?2:3}}const Gi=Pi(),Uu=g(),Ui=g();function ja(){return{direction:g(),up:g()}}function Ga(t,e,i,r,s){let n=Te(Uu,t),a=we(n,r);const l=a>0;a=Math.abs(a),a>.99&&(a=Math.abs(we(e,r)),a<.99?(Z(n,e),l&&q(n,n,-1)):n=null);let o=0;if(n){q(Ui,r,we(r,n)),ce(n,n,Ui);const u=we(n,s)/(te(n)*te(s));Ae(Ui,n,s),o=(we(Ui,r)>0?1:-1)*lt(fr(u))}const c=lt(fr(-we(r,t)/te(t)));return i?(i.heading=o,i.tilt=c,i):{heading:o,tilt:c}}function Ua(t,e,i,r){ce(In,i,e),Kc(r,lc(e,In),t)||t===i||Z(t,i)}const In=g(),Wa=ve(0,1,0),ka=ve(0,0,1),ci=ne(),Qe=g(),et=g();function qa(t,e,i,r=ja()){const{direction:s,up:n}=r;return Vc(ci,-_e(e)),Aa(ci,ci,_e(i)),Fe(s,ka,ci),q(s,s,-1),Fe(n,Wa,ci),r}function Wu(t,e,i,r){return Ga(e,i,r,ka,Wa)}function ku(t,e,i,r){const s=qa(t,i,r),n=g();return q(n,s.direction,-e),pe(n,n,t),{up:s.up,eye:n,heading:i,tilt:r}}function qu(t){return lt(t)}function Xu(t){return _e(t)}function Yu(t,e,i,r,s){const n=t.renderSpatialReference,a=t.spatialReference??e.spatialReference;return gs(e,Qe,n),gs(e,et,n),Qe[0]-=i/2,et[0]+=i/2,Qe[1]-=r/2,et[1]+=r/2,vr(Qe,n,Qe,a),vr(et,n,et,a),s?(s.xmin=Qe[0],s.ymin=Qe[1],s.xmax=et[0],s.ymax=et[1],s.spatialReference=a):s=new Rs(Qe[0],Qe[1],et[0],et[1],a),s}function Zu(t,e){const i=t.frustum,{renderCoordsHelper:r}=t,s=r.getAltitude(e),n=t.spatialReference,a=t.state.camera.eye,l=[],o=i.planes[5];for(let c=0;c<4;c++){const u=i.lines[c];r.intersectInfiniteManifold(xa(u.origin,u.direction),s,De)||Ku(De,i,r,u.endpoint,s),Ua(De,a,De,o),l.push(Da(De[0],De[1]))}return Ju(ju(l,r.extent),r,n)}function Ku(t,e,i,r,s){const n=e.lines[11].direction,a=(s-i.getAltitude(r))/n[2];qe(t,r,n,a)}function Ju(t,e,i){const r=t.map(s=>(U(De,s[0],s[1],0),e.fromRenderCoords(De,De,i),[De[0],De[1]]));return r.length<=2?new ds({spatialReference:i}):(r.push(r[0].slice()),Ca(r)||r.reverse(),new ds({rings:[r],spatialReference:i}))}const De=g(),Qu=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:Wu,eyeForCenterWithHeadingTilt:ku,eyeTiltToLookAtTilt:Xu,headingTiltToDirectionUp:qa,lookAtTiltToEyeTilt:qu,toArea:Zu,toExtent:Yu},Symbol.toStringTag,{value:"Module"}));let eh=class{get planes(){return this.frustum}get points(){return this._points}get mutablePoints(){return this._points}get direction(){return this._direction}get origin(){return this._origin}constructor(e){this.renderCoordsHelper=e,this.frustum=wa(),this._points=cc(),this.lines=new Array(12),this._origin=g(),this._direction=g(),this._altitude=null;for(let i=0;i<12;i++)this.lines[i]={origin:null,direction:g(),endpoint:null}}update(e){Ta(e.viewMatrix,e.projectionMatrix,this.frustum,this._points),Z(this._origin,e.eye),Z(this._direction,e.viewForward),this._altitude=this.renderCoordsHelper.getAltitude(this._origin),this._updateLines()}updatePoints(e){for(let i=0;i<this._points.length;i++)Z(this._points[i],e[i]);uc(this.frustum,this._points),this._updateLines()}get altitude(){return this._altitude}intersectsSphere(e){return hc(this.frustum,e)}intersectsRay(e){return dc(this.frustum,e)}intersectsLineSegment(e,i){return fc(this.frustum,e,i)}intersectsPoint(e){return pc(this.frustum,e)}_updateLines(){const e=this._points;for(let i=0;i<4;i++){const r=i+4;Xr(this.lines[i],e[i],e[r]),Xr(this.lines[i+4],e[i],i===3?e[0]:e[i+1]),Xr(this.lines[i+8],e[r],i===3?e[4]:e[r+1])}}static{this.planePointIndices=mc}static{this.nearFarLineIndices=[[0,4],[1,5],[2,6],[3,7]]}};function Xr(t,e,i){t.origin=e,t.endpoint=i,fa(t.direction,e,i)}function th(t){return Le((t-An)/(ih-An),0,1)}const An=1e5,ih=1e6,mv=1e4,Yr=ve(parseFloat(5802e-9.toFixed(6)),parseFloat(13558e-9.toFixed(6)),parseFloat(331e-7.toFixed(6))),Zr=3,Kr=ve(Zr*parseFloat(65e-8.toFixed(6)),Zr*parseFloat(1881e-9.toFixed(6)),Zr*parseFloat(85e-9.toFixed(6))),gv=3996e-9,vv=ve(parseFloat(Number(Yr[0]+Kr[0]).toFixed(6)),parseFloat(Number(Yr[1]+Kr[1]).toFixed(6)),parseFloat(Number(Yr[2]+Kr[2]).toFixed(6)));function _v(t,e,i){return t===1?new sh(e,i):new rh(e,i)}let rh=class{constructor(e,i){this._elevationProvider=e,this._referenceEllipsoid=Di(i),this._unitInMeters=uu(i,this._referenceEllipsoid.metersPerDegree)}compute(e,i,r,s){const{eye:n,center:a}=e;let l=n[2]*this._unitInMeters;const o=l,c=l-s,u=this._elevationProvider?.visibleElevationBounds;u&&(l=c>=0?o-this._unitInMeters*u.min:this._unitInMeters*u.max-o),i??=new Rs({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0});const d={x:i.xmax-i.xmin,y:i.ymax-i.ymin,z:4*Math.max(i.xmax-i.xmin,i.ymax-i.ymin)},m=Math.max(d.x,d.y,d.z);ce(ft,a,n),be[0]=ft[0]>0?i.xmax:i.xmin,be[1]=ft[1]>0?i.ymax:i.ymin,be[2]=ft[2]>0?m/2:-m/2,ce(be,be,n),Te(ft,ft);const v=1.1*we(be,ft)*this._unitInMeters,p=Math.sqrt(l*(l+2*this._referenceEllipsoid.radius)),_=Math.max(i.xmax-i.xmin,i.ymax-i.ymin),b=_*ah*this._unitInMeters,y=_*oh*this._unitInMeters,M=Le((l-y)/(b-y),0,1)**3,w=Math.min(ge(p,v,M),p)*Math.max(Math.log(Math.abs(c)),1);return Xa(Math.min(w,Math.max(34064e4,m))/this._unitInMeters,sr,this._unitInMeters,Gt)}},sh=class{constructor(e,i){this._elevationProvider=e,this._referenceEllipsoid=Di(i)}compute(e,i,r,s){const{eye:n}=e,a=te(n),l=a-this._referenceEllipsoid.radius,o=this._referenceEllipsoid.radius+Math.min(0,s),c=Math.abs(l-s),u=Math.max(c,Math.abs(l)),d=this._elevationProvider?.visibleElevationBounds.max??0,m=th(u),v=Math.sqrt(u*(u+2*o)),p=a+this._referenceEllipsoid.radius,_=1.2*ge(v,p,m),b=(Math.log(u)-Fn)/(nh-Fn);Xa(_,Le(sr-b*(sr-Rn),Rn,sr),1,Gt);const y=this._referenceEllipsoid.radius+d,M=this._referenceEllipsoid.radius+this._referenceEllipsoid.atmosphereHeight,w=Math.max(y,M),S=a-w;if(m>0&&S>Ps){const I=Te(be,q(be,e.eye,-1)),P=Te(ft,e.viewForward),F=fr(we(I,P)),$=.5*e.fovY,C=Math.cos($);let O=xs.Infinite.near;if(F<=$)O=S*C;else{const E=Te(be,e.viewUp),R=Math.tan($),D=q(be,E,R),N=Te(be,ce(be,P,D)),V=sc(e.eye,N,ch),j=ba(lh,w);if(nc(j,V,be)){const X=ce(be,be,e.eye);O=te(X)*C}}const T=.99*Math.min(r.near,O);if(T<xs.Infinite.near&&T>Gt.near){const E=ge(Gt.near,T,m);Gt.near=E}}return Gt}};function Xa(t,e,i,r){const s=Ps/i,n=t/e;return n>s?(r.far=t,r.near=n):(r.near=s,r.far=r.near*e),r}const Fn=7.983,nh=16.994,sr=2e4,Rn=100,Ps=2,ah=.001,oh=1e-4,be=g(),ft=g(),Gt={near:0,far:0},lh=Er(),ch=mt();function uh(t,e,i){t.worldUpAtPosition(e,On),ce(Jr,i,e);const r=te(Jr);return r===0?0:fr(we(Jr,On)/r)}const On=g(),Jr=g();function Pn(t,e,i){if(e.longitude==null||e.latitude==null||i.longitude==null||i.latitude==null)throw new Error("Invalid points: no lon/lat");return hh(t,e.longitude,e.latitude,i.longitude,i.latitude)}function hh(t,e,i,r,s){const n=_e(i),a=_e(s),l=n-a,o=_e(e)-_e(r),c=Math.sin(l/2),u=Math.sin(o/2),d=2*Ri(Math.sqrt(c*c+Math.cos(n)*Math.cos(a)*u*u))*t;return Math.round(1e4*d)/1e4}function yv(t,e,i){const r=e.spatialReference,s=Di(r),n=new gt(e.x,t.y,r),a=new gt(i.x,t.y,r),l=new gt(t.x,e.y,r),o=new gt(t.x,i.y,r);return{lon:Pn(s.radius,n,a),lat:Pn(s.radius,l,o)}}function dh(t,e,i){const r=e/i,s=_e(t),n=Math.sin(r/2),a=Math.cos(s),l=2*Ri(Math.sqrt(n*n/(a*a)));return lt(l)}function fh(t,e){return t/15}function wv(t,e){const i=t?.[0];if(i==null)return null;e||(e={hours:0,minutes:0,seconds:0}),e.hours=fh(i);const r=e.hours%1;e.hours-=r,e.minutes=60*r;const s=e.minutes%1;return e.minutes-=s,e.seconds=Math.round(60*s),e}const Ya=ve(0,0,1),Za=Te(g(),ve(1,1,1)),ui=ne(),pt=g(),Vt=g();function Ka(t,e,i,r=ja()){Ae(pt,t,Ya),we(pt,pt)===0&&Ae(pt,t,Za),Bc(ui,-_e(e),t),Hc(ui,ui,-_e(i),pt);const{up:s,direction:n}=r;return Ae(s,pt,t),Te(s,s),Fe(s,s,ui),Te(n,t),pa(n,n),Fe(n,n,ui),r}function ph(t,e,i,r){const s=pt,n=Vt;return Te(s,t),Ae(Vt,s,Ya),we(Vt,Vt)===0&&Ae(Vt,s,Za),Ae(n,Vt,s),Ga(e,i,r,s,n)}function mh(t,e,i,r){const s={eye:g(),up:null,tilt:r,heading:i},n=pt;n[0]=t[0],n[1]=t[2],n[2]=-t[1];const a=e,l=_e(i),o=_e(r),c=Math.sin(l),u=Math.cos(l),d=Math.sin(o),m=Math.cos(o),v=te(n);let p;if(Math.abs(o)<1e-8)p=a+v;else{const V=v/d,j=Ri(a/V),X=Math.PI-o-j;p=V*Math.sin(X)}const _=m*a,b=a*a*(d*d),y=u*u*b,M=p-_,w=M*M,S=y*(y+w-n[1]*n[1]);if(S<0)return q(s.eye,n,p/v),s.tilt=0,Wi(s,t);const I=Math.sqrt(S),P=n[1]*M,F=y+w;let $;if($=u>0?-I+P:I+P,Math.abs(F)<1e-8)return v<1e-8?(s.eye[0]=0,s.eye[1]=0,s.eye[2]=a):q(s.eye,n,p/v),s.tilt=0,Qr(s.eye),Wi(s,t);s.eye[1]=$/F;const C=c*c*b,O=d*a,T=u*O*s.eye[1],E=s.eye[1]*s.eye[1],R=1-E,D=Math.sqrt(R),N=y*E+C-2*T*D*M+R*w;return Math.abs(N)<1e-8?(q(s.eye,n,p/v),s.tilt=0,Qr(s.eye),Wi(s,t)):(s.eye[0]=(R*(p*n[0]-_*n[0])-O*D*(n[0]*s.eye[1]*u+n[2]*c))/N,s.eye[2]=(R*(p*n[2]-_*n[2])-O*D*(n[2]*s.eye[1]*u-n[0]*c))/N,q(s.eye,s.eye,p),Qr(s.eye),Wi(s,t))}function Qr(t){const e=t[1];t[1]=-t[2],t[2]=e}function Wi(t,e){const i=Ka(e,t.heading,t.tilt);return t.up=i.up,t}function gh(t,e,i){const r=te(e),s=Math.sqrt(i*i+r*r-2*i*r*Math.cos(Math.PI-t)),n=Ri(i/(s/Math.sin(t)));return lt(t-n)}function vh(t,e,i){const r=_e(t),s=te(e);return Ri(i/(s/Math.sin(r)))+r}function _h(t,e,i,r,s){let n,a,l,o;const c=e.latitude,u=Di(t.spatialReference).radius,d=e.longitude,m=dh(c,i,u)/2;n=d-m,a=d+m;const v=_e(c),p=(1+Math.sin(v))/(1-Math.sin(v)),_=(p+1)*Math.tan(r/u/2),b=_*_;function y(w){const S=Math.PI/2;return(w=cu.normalize(w,-S))>S&&(w=Math.PI-w),w}if(l=1.5*Math.PI-2*Math.atan(.5*(_+Math.sqrt(4*p+b))),o=l+r/u,l=y(l),o=y(o),o<l){const w=o;o=l,l=w}if(l=Math.max(lt(l),-90),o=Math.min(lt(o),90),a=xu.monotonic(n,a),a-n>180){const w=(a-n-180)/2;n+=w,a-=w}const M=t.spatialReference&&t.spatialReference.isGeographic?t.spatialReference:za.WGS84;return s?(s.xmin=n,s.ymin=l,s.xmax=a,s.ymax=o,s.spatialReference=M):s=new Rs(n,l,a,o,M),t.spatialReference&&t.spatialReference.isWebMercator&&hu(s,!1,s),s}function xh(t,e){const{renderCoordsHelper:i}=t,r=t.state.camera.clone(),s=new eh(i);r.near=Ps,s.update(r);const n=i.getAltitude(e),a=t.spatialReference,l=i.referenceEllipsoid.radius,o=r.eye,c=1+da(o,e)/(l+n),u=Math.sqrt(c*c-1),{minCurvature:d,maxCurvature:m,minSamples:v,maxSamples:p}=Th,_=wh(t),b=Le((u-d)/(m-d),0,1),y=Math.round(ge(v,p,b)),M=r.aboveGround,w=s.planes[5],S=[],I=fn(ot,Mh,pn()),P=fn(ot,Sh,pn());$e(es,0,0,0,0);const F=C=>{};for(let C=0;C<4;C++){const O=C===1&&!M||C===3&&M?1-_:0,T=C===1&&M||C===3&&!M?_:1,E=s.lines[C],R=s.lines[C===3?0:C+1];for(let D=0;D<y;D++){const N=D/y,V=D===0?0:ge(O,T,C===1?1-(1-N)**2:C===3?N**2:N),j=lr(Ch,E.origin,R.origin,V),X=Jc(E.direction,R.direction,V,$h);i.intersectManifoldClosestSilhouette(xa(j,X),n,ye),Ua(ye,o,ye,w),S.push(bi(ye)),S.length!==0&&F(us(S.at(-1),ye));const oe=(mn(I,ye)?1:0)|(mn(P,ye)?2:0);es[oe]=1}}S.length>2&&F(us(S[0],S.at(-1)));const $=bh(nu(es)>1?yh(Ja(S,I),P):[S],i,a);return new ds({rings:$,spatialReference:a})}function bh(t,e,i){const r=2*Ea();return t.map(s=>{const n=[];let a=!1;for(const l of s)e.fromRenderCoords(l,ye,i),Math.abs(l[0])<r&&Math.abs(l[1])<r?(n.push([null,ye[1]]),n.push([null,ye[1]]),a=!0):n.push([ye[0],ye[1]]);if(a)for(let l=0;l<n.length;l++){const o=n[l];if(o[0]!=null)continue;const c=n[l+1],u=n.at(l===0?-1:l-1);o[0]=u[0],l++;const d=n.at(l===n.length-1?0:l+1);c[0]=d[0]}return n.push(n[0]),Ca(n)||n.reverse(),n})}function yh(t,e){const i=[];for(const r of t)i.push(...Ja(r,e));return i}function Ja(t,e){const i=[],r=[],s=Ea();for(let a=0;a<t.length;a++){const l=t[a],o=a===t.length-1?t[0]:t[a+1],c=gc(l,o,Eh),u=Qc(e,c.origin,c.vector,0,ye);switch(u){case 2:i.push(l);break;case 3:r.push(l);break;case 0:case 1:{const[d,m,v]=u===0?[1,i,r]:[-1,r,i],p=eu(e),_=qe(g(),ye,p,d*s),b=qe(g(),ye,p,d*-s);m.push(l),m.push(_),v.push(b)}}}const n=[];return i.length&&n.push(i),r.length&&n.push(r),n}function wh(t){const{renderCoordsHelper:e,state:{camera:i}}=t,{center:r,eye:s}=i,n=Math.abs(e.getAltitude(r)),a=Math.abs(Math.PI/2-uh(e,r,s));return ba(Dn,e.referenceEllipsoid.radius+n),ac(Dn,a,i.distance,i.fovY)}const Th={minCurvature:_e(5),maxCurvature:_e(50),minSamples:1,maxSamples:6},Mh=ve(1,0,0),Sh=ve(0,1,0),$h=g(),Ch=g(),ye=g(),Dn=Er(),Eh=Ma(),es=at(),Ih=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:ph,eyeForCenterWithHeadingTilt:mh,eyeTiltToLookAtTilt:vh,headingTiltToDirectionUp:Ka,lookAtTiltToEyeTilt:gh,toArea:xh,toExtent:_h},Symbol.toStringTag,{value:"Module"}));function Qa({state:t}){return t.isGlobal?Ih:Qu}function Ah(t,e,i,r,s){return Qa(t).directionToHeadingTilt(e,i,r,s)}const Fh={OPAQUE:"opaque-color",TRANSPARENT:"transparent-color",COMPOSITE:"composite-color",FINAL:"final-color"},zn={SSAO:"ssao",LASERLINES:"laserline-color",ANTIALIASING:"aa-color",HIGHLIGHTS:"highlight-color",MAGNIFIER:"magnifier-color",OCCLUDED:"occluded-color",VIEWSHED:"viewshed-color",CUTFILL_DEPTH:"cutfill-depth",CUTFILL_COLOR:"cutfill-color",OPAQUE_TERRAIN:"opaque-terrain-color",OPAQUE_ENVIRONMENT:"opaque-environment-color",TRANSPARENT_ENVIRONMENT:"transparent-environment-color",FOCUSAREA:"focusarea",FOCUSAREA_COLOR:"focusarea-color"};function Tv(t,e,i){const r=t.renderSpatialReference,s=Ah(t,e.eye,e.viewForward,e.up,Rh);let n=t.spatialReference;return vr(e.eye,r,Bt,n)||(n=za.WGS84,vr(e.eye,r,Bt,n)),i==null?i=new Tu(new gt(Bt,n),s.heading,s.tilt,lt(e.fov)):(i.position.x=Bt[0],i.position.y=Bt[1],i.position.z=Bt[2],i.position.spatialReference=n,i.heading=s.heading,i.tilt=s.tilt,i.fov=lt(e.fov)),i.layout.row=e.row,i.layout.rows=e.rows,i.layout.column=e.column,i.layout.columns=e.columns,i}function Mv(t,e){if(!e)return null;const i=t.renderSpatialReference,r=Qa(t).headingTiltToDirectionUp,s=g();if(!gs(e.position,s,i))return null;const n=r(s,e.heading,e.tilt);q(n.direction,n.direction,t.state.camera.distance),pe(n.direction,n.direction,s);const a=Vu(t,s,n.direction,n.up);return a.fov=_e(e.fov),a.row=e.layout.row,a.rows=e.layout.rows,a.column=e.layout.column,a.columns=e.layout.columns,a}const Bt=g(),Rh={heading:0,tilt:0};function eo(t,e=!0){t.attributes.add("position","vec2"),e&&t.varyings.add("uv","vec2"),t.vertex.main.add(h`
      gl_Position = vec4(position, 0.0, 1.0);
      ${e?h`uv = position * 0.5 + vec2(0.5);`:""}
  `)}let to=class extends ie{constructor(e,i,r){super(e,"vec2",1,(s,n,a)=>s.setUniform2fv(e,i(n,a),r))}},Ye=class extends ie{constructor(e,i,r){super(e,"mat3",1,(s,n,a)=>s.setUniformMatrix3fv(e,i(n,a),r))}},Oh=class{};const Ve=Oh,Ev=new Ve,Ds=()=>yt.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");let io=class{constructor(){this._includedModules=new Map}include(e,i){this._includedModules.has(e)?this._includedModules.get(e):(this._includedModules.set(e,i),e(this.builder,i))}},Ir=class extends io{constructor(){super(...arguments),this.vertex=new Nn,this.fragment=new Nn,this.attributes=new Nh,this.varyings=new Lh,this.extensions=new Vh,this.outputs=new Bh}get fragmentUniforms(){return this.fragment.uniforms.entries}get attributeNames(){return this.attributes.names}get builder(){return this}generate(e,i=!1){const r=this.extensions.generateSource(e),s=this.attributes.generateSource(e),n=this.varyings.generateSource(e),a=e==="vertex"?this.vertex:this.fragment,l=a.uniforms.generateSource(),o=a.code.generateSource(),c=a.main.generateSource(i),u=e==="vertex"?Gh:jh,d=a.constants.generateSource(),m=this.outputs.generateSource(e);return`#version 300 es
${r.join(`
`)}
${u}
${d.join(`
`)}
${l.join(`
`)}
${s.join(`
`)}
${n.join(`
`)}
${m.join(`
`)}
${o.join(`
`)}
${c.join(`
`)}`}generateBind(e){const i=new Map;this.vertex.uniforms.entries.forEach(n=>{const a=n.bind[0];a&&i.set(n.name,a)}),this.fragment.uniforms.entries.forEach(n=>{const a=n.bind[0];a&&i.set(n.name,a)});const r=Array.from(i.values()),s=r.length;return n=>{for(let a=0;a<s;++a)r[a](e,n)}}generateBindPass(e){const i=new Map;this.vertex.uniforms.entries.forEach(n=>{const a=n.bind[1];a&&i.set(n.name,a)}),this.fragment.uniforms.entries.forEach(n=>{const a=n.bind[1];a&&i.set(n.name,a)});const r=Array.from(i.values()),s=r.length;return(n,a)=>{for(let l=0;l<s;++l)r[l](e,n,a)}}generateBindDraw(e){const i=new Map;this.vertex.uniforms.entries.forEach(n=>{const a=n.bind[2];a&&i.set(n.name,a)}),this.fragment.uniforms.entries.forEach(n=>{const a=n.bind[2];a&&i.set(n.name,a)});const r=Array.from(i.values()),s=r.length;return(n,a,l)=>{for(let o=0;o<s;++o)r[o](e,l,n,a)}}},Ph=class{constructor(e){this._stage=e,this._entries=new Map}add(...e){for(const i of e)this._add(i);return this._stage}get(e){return this._entries.get(e)}_add(e){if(e!=null){if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new Y("shaderbuilder:duplicate-uniform",`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}else Ds().error(`Trying to add null Uniform from ${new Error().stack}.`)}generateSource(){return Array.from(this._entries.values()).map(({name:e,arraySize:i,type:r})=>i!=null?`uniform ${r} ${e}[${i}];`:`uniform ${r} ${e};`)}get entries(){return Array.from(this._entries.values())}},Dh=class{constructor(e){this._stage=e,this._bodies=new Array}add(e){return this._bodies.push(e),this._stage}generateSource(e){if(this._bodies.length>0)return[`void main() {
 ${this._bodies.join(`
`)||""} 
}`];if(e)throw new Y("shaderbuilder:missing-main","Shader does not contain main function body.");return[]}},zh=class{constructor(e){this._stage=e,this._entries=new Array}add(e){return this._entries.push(e),this._stage}generateSource(){return this._entries}},Nn=class extends io{constructor(){super(...arguments),this.uniforms=new Ph(this),this.main=new Dh(this),this.code=new zh(this),this.constants=new Hh(this)}get builder(){return this}},Nh=class{constructor(){this._entries=new Array}add(e,i){this._entries.push([e,i])}generateSource(e){return e==="fragment"?[]:this._entries.map(i=>`in ${i[1]} ${i[0]};`)}get names(){return this._entries.map(([e])=>e)}},Lh=class{constructor(){this._entries=new Map}add(e,i,r){this._entries.has(e)?Ds().warn(`Ignoring duplicate varying ${i} ${e}`):this._entries.set(e,{type:i,invariant:r?.invariant??!1})}generateSource(e){const i=new Array;return this._entries.forEach((r,s)=>i.push((r.invariant&&e==="vertex"?"invariant ":"")+(r.type==="int"?"flat ":"")+(e==="vertex"?"out":"in")+` ${r.type} ${s};`)),i}},Vh=class Ts{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const i=e==="vertex"?Ts.ALLOWLIST_VERTEX:Ts.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter(r=>i.includes(r)).map(r=>`#extension ${r} : enable`)}static{this.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"]}static{this.ALLOWLIST_VERTEX=[]}},Bh=class Ms{constructor(){this._entries=new Map}add(e,i,r=0){const s=this._entries.get(r);s?.name!==e||s?.type!==i?this._entries.set(r,{name:e,type:i}):Ds().warn(`Fragment shader output location ${r} occupied`)}static{this.DEFAULT_TYPE="vec4"}static{this.DEFAULT_NAME="fragColor"}generateSource(e){if(e==="vertex")return[];this._entries.size===0&&this._entries.set(0,{name:Ms.DEFAULT_NAME,type:Ms.DEFAULT_TYPE});const i=new Array;return this._entries.forEach((r,s)=>i.push(`layout(location = ${s}) out ${r.type} ${r.name};`)),i}},Hh=class k{constructor(e){this._stage=e,this._entries=new Set}add(e,i,r){let s="ERROR_CONSTRUCTOR_STRING";switch(i){case"float":s=k._numberToFloatStr(r);break;case"int":s=k._numberToIntStr(r);break;case"bool":s=r.toString();break;case"vec2":s=`vec2(${k._numberToFloatStr(r[0])},                            ${k._numberToFloatStr(r[1])})`;break;case"vec3":s=`vec3(${k._numberToFloatStr(r[0])},                            ${k._numberToFloatStr(r[1])},                            ${k._numberToFloatStr(r[2])})`;break;case"vec4":s=`vec4(${k._numberToFloatStr(r[0])},                            ${k._numberToFloatStr(r[1])},                            ${k._numberToFloatStr(r[2])},                            ${k._numberToFloatStr(r[3])})`;break;case"ivec2":s=`ivec2(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])})`;break;case"ivec3":s=`ivec3(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])},                             ${k._numberToIntStr(r[2])})`;break;case"ivec4":s=`ivec4(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])},                             ${k._numberToIntStr(r[2])},                             ${k._numberToIntStr(r[3])})`;break;case"uvec2":s=`uvec2(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])})`;break;case"uvec3":s=`uvec3(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])},                             ${k._numberToIntStr(r[2])})`;break;case"uvec4":s=`uvec4(${k._numberToIntStr(r[0])},                             ${k._numberToIntStr(r[1])},                             ${k._numberToIntStr(r[2])},                             ${k._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":s=`${i}(${Array.prototype.map.call(r,n=>k._numberToFloatStr(n)).join(", ")})`}return this._entries.add(`const ${i} ${e} = ${s};`),this._stage}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}};const jh=`#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
  precision highp int;
  precision highp sampler2D;
  precision highp usampler2D;
  precision highp sampler2DArray;
  precision highp sampler2DShadow;
#else
  precision mediump float;
  precision mediump int;
  precision mediump sampler2D;
  precision mediump usampler2D;
  precision mediump sampler2DArray;
  precision mediump sampler2DShadow;
#endif`,Gh=`precision highp float;
 precision highp sampler2D;
 precision highp usampler2D;
 precision highp sampler2DArray;
 precision highp sampler2DShadow;


 invariant gl_Position;
 `;let Ar=class{constructor(e,i){this._module=e,this._load=i}get(){return this._module}async reload(){return this._module=await this._load(),this._module}};const Uh=()=>yt.getLogger("esri.views.webgl.checkWebGLError");function ro(t){switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const so=!!Sr("enable-feature:webgl-debug");function Ii(){return so}function Lv(){return so}function ke(t,e=Ii()){if(e){const i=ro(t);if(i){const r=new Error().stack;Uh().error(new Y("webgl-error","WebGL error occurred",{message:i,stack:r}))}}}let Ln=class{constructor(e,i,r){this._context=e,this.locations=r,this._textures=new Map,this.source=Ii()?i:null,i.attributeNames.forEach(s=>{r.has(s)||console.error(`Missing VertexAttributeLocation for ${s} used in shader`)}),this._glProgram=e.programCache.acquire(i.generate("vertex",!0),i.generate("fragment",!0),r),this._glProgram.stop=()=>{throw new Error("Wrapped _glProgram used directly")},this.bind=i.generateBind(this),this.bindPass=i.generateBindPass(this),this.bindDraw=i.generateBindDraw(this)}dispose(){this._glProgram.dispose()}get glName(){return this._glProgram.glName}get hasTransformFeedbackVaryings(){return this._glProgram.hasTransformFeedbackVaryings}get compiled(){return this._glProgram.compiled}setUniform1b(e,i){this._glProgram.setUniform1i(e,i?1:0)}setUniform1i(e,i){this._glProgram.setUniform1i(e,i)}setUniform1f(e,i,r){this._glProgram.setUniform1f(e,i,r)}setUniform2fv(e,i,r){this._glProgram.setUniform2fv(e,i,r)}setUniform3fv(e,i,r){this._glProgram.setUniform3fv(e,i,r)}setUniform4fv(e,i,r){this._glProgram.setUniform4fv(e,i,r)}setUniformMatrix3fv(e,i,r){this._glProgram.setUniformMatrix3fv(e,i,!1,r)}setUniformMatrix4fv(e,i,r){this._glProgram.setUniformMatrix4fv(e,i,!1,r)}setUniformMatrices4fv(e,i,r){this._glProgram.setUniformMatrices4fv(e,i,!1,r)}setUniform1fv(e,i,r){this._glProgram.setUniform1fv(e,i,r)}setUniform1iv(e,i){this._glProgram.setUniform1iv(e,i)}setUniform2iv(e,i){this._glProgram.setUniform2iv(e,i)}setUniform3iv(e,i){this._glProgram.setUniform3iv(e,i)}setUniform4iv(e,i){this._glProgram.setUniform4iv(e,i)}assertCompatibleVertexAttributeLocations(e,i){let r=e.locations;if(i){const s=new Map(r);i.forEach((n,a)=>s.set(a,r.size+n)),r=s}r.size!==this.locations.size&&console.error(`VertexAttributeLocations are incompatible: ${r}, ${this.locations}`),this.locations.forEach((s,n)=>{r.get(n)!==s&&console.error(`VertexAttributeLocations are incompatible: Program has ${n} at position ${s}, VAO has it at position ${r.get(n)}.`)})}stop(){this._textures.clear()}bindTexture(e,i){i?.glName||(Ii()&&console.error(`Texture sampler ${e} has no given Texture in ${new Error().stack} `),i=this._context.emptyTexture);const r=this._ensureTextureUnit(e,i);this._context.useProgram(this),this.setUniform1i(e,r.unit),this._context.bindTexture(i,r.unit)}_ensureTextureUnit(e,i){let r=this._textures.get(e);return r==null?(r={texture:i,unit:this._textures.size},this._textures.set(e,r)):r.texture=i,r}};function Fr(t,e,i=32774,r=[0,0,0,0]){return{srcRgb:t,srcAlpha:t,dstRgb:e,dstAlpha:e,opRgb:i,opAlpha:i,color:{r:r[0],g:r[1],b:r[2],a:r[3]}}}function zs(t,e,i,r,s=32774,n=32774,a=[0,0,0,0]){return{srcRgb:t,srcAlpha:e,dstRgb:i,dstAlpha:r,opRgb:s,opAlpha:n,color:{r:a[0],g:a[1],b:a[2],a:a[3]}}}const Bv=Fr(0,771),Hv=Fr(1,0),jv=Fr(1,1),no=Fr(1,771),Wh=zs(770,1,771,771),Gv=zs(0,0,768,1),kh={face:1029,mode:2305},qh={face:1028,mode:2305},Xh=t=>t===2?kh:t===1?qh:null,Yh={zNear:0,zFar:1},Rr={r:!0,g:!0,b:!0,a:!0};function Zh(t){return nd.intern(t)}function Kh(t){return ad.intern(t)}function Jh(t){return od.intern(t)}function Qh(t){return ld.intern(t)}function ed(t){return cd.intern(t)}function td(t){return ud.intern(t)}function id(t){return hd.intern(t)}function rd(t){return dd.intern(t)}function sd(t){return fd.intern(t)}function Or(t){return pd.intern(t)}let Ze=class{constructor(e,i){this._makeKey=e,this._makeRef=i,this._interns=new Map}intern(e){if(!e)return null;const i=this._makeKey(e),r=this._interns;return r.has(i)||r.set(i,this._makeRef(e)),r.get(i)??null}};function Ke(t){return"["+t.join(",")+"]"}const nd=new Ze(ao,t=>({__tag:"Blending",...t}));function ao(t){return t?Ke([t.srcRgb,t.srcAlpha,t.dstRgb,t.dstAlpha,t.opRgb,t.opAlpha,t.color.r,t.color.g,t.color.b,t.color.a]):null}const ad=new Ze(oo,t=>({__tag:"Culling",...t}));function oo(t){return t?Ke([t.face,t.mode]):null}const od=new Ze(lo,t=>({__tag:"PolygonOffset",...t}));function lo(t){return t?Ke([t.factor,t.units]):null}const ld=new Ze(co,t=>({__tag:"DepthTest",...t}));function co(t){return t?Ke([t.func]):null}const cd=new Ze(uo,t=>({__tag:"StencilTest",...t}));function uo(t){return t?Ke([t.function.func,t.function.ref,t.function.mask,t.operation.fail,t.operation.zFail,t.operation.zPass]):null}const ud=new Ze(ho,t=>({__tag:"DepthWrite",...t}));function ho(t){return t?Ke([t.zNear,t.zFar]):null}const hd=new Ze(fo,t=>({__tag:"ColorWrite",...t}));function fo(t){return t?Ke([t.r,t.g,t.b,t.a]):null}const dd=new Ze(po,t=>({__tag:"StencilWrite",...t}));function po(t){return t?Ke([t.mask]):null}const fd=new Ze(mo,t=>({__tag:"DrawBuffers",...t}));function mo(t){return t?Ke(t.buffers):null}const pd=new Ze(md,t=>({blending:Zh(t.blending),culling:Kh(t.culling),polygonOffset:Jh(t.polygonOffset),depthTest:Qh(t.depthTest),stencilTest:ed(t.stencilTest),depthWrite:td(t.depthWrite),colorWrite:id(t.colorWrite),stencilWrite:rd(t.stencilWrite),drawBuffers:sd(t.drawBuffers)}));function md(t){return t?Ke([ao(t.blending),oo(t.culling),lo(t.polygonOffset),co(t.depthTest),uo(t.stencilTest),ho(t.depthWrite),fo(t.colorWrite),po(t.stencilWrite),mo(t.drawBuffers)]):null}let Wv=class{constructor(e){this._pipelineInvalid=!0,this._blendingInvalid=!0,this._cullingInvalid=!0,this._polygonOffsetInvalid=!0,this._depthTestInvalid=!0,this._stencilTestInvalid=!0,this._depthWriteInvalid=!0,this._colorWriteInvalid=!0,this._stencilWriteInvalid=!0,this._drawBuffersInvalid=!0,this._stateSetters=e}setPipeline(e){(this._pipelineInvalid||e!==this._pipeline)&&(this._setBlending(e.blending),this._setCulling(e.culling),this._setPolygonOffset(e.polygonOffset),this._setDepthTest(e.depthTest),this._setStencilTest(e.stencilTest),this._setDepthWrite(e.depthWrite),this._setColorWrite(e.colorWrite),this._setStencilWrite(e.stencilWrite),this._setDrawBuffers(e.drawBuffers),this._pipeline=e),this._pipelineInvalid=!1}invalidateBlending(){this._blendingInvalid=!0,this._pipelineInvalid=!0}invalidateCulling(){this._cullingInvalid=!0,this._pipelineInvalid=!0}invalidatePolygonOffset(){this._polygonOffsetInvalid=!0,this._pipelineInvalid=!0}invalidateDepthTest(){this._depthTestInvalid=!0,this._pipelineInvalid=!0}invalidateStencilTest(){this._stencilTestInvalid=!0,this._pipelineInvalid=!0}invalidateDepthWrite(){this._depthWriteInvalid=!0,this._pipelineInvalid=!0}invalidateColorWrite(){this._colorWriteInvalid=!0,this._pipelineInvalid=!0}invalidateStencilWrite(){this._stencilTestInvalid=!0,this._pipelineInvalid=!0}invalidateDrawBuffers(){this._drawBuffersInvalid=!0,this._pipelineInvalid=!0}_setBlending(e){this._blending=this._setSubState(e,this._blending,this._blendingInvalid,this._stateSetters.setBlending),this._blendingInvalid=!1}_setCulling(e){this._culling=this._setSubState(e,this._culling,this._cullingInvalid,this._stateSetters.setCulling),this._cullingInvalid=!1}_setPolygonOffset(e){this._polygonOffset=this._setSubState(e,this._polygonOffset,this._polygonOffsetInvalid,this._stateSetters.setPolygonOffset),this._polygonOffsetInvalid=!1}_setDepthTest(e){this._depthTest=this._setSubState(e,this._depthTest,this._depthTestInvalid,this._stateSetters.setDepthTest),this._depthTestInvalid=!1}_setStencilTest(e){this._stencilTest=this._setSubState(e,this._stencilTest,this._stencilTestInvalid,this._stateSetters.setStencilTest),this._stencilTestInvalid=!1}_setDepthWrite(e){this._depthWrite=this._setSubState(e,this._depthWrite,this._depthWriteInvalid,this._stateSetters.setDepthWrite),this._depthWriteInvalid=!1}_setColorWrite(e){this._colorWrite=this._setSubState(e,this._colorWrite,this._colorWriteInvalid,this._stateSetters.setColorWrite),this._colorWriteInvalid=!1}_setStencilWrite(e){this._stencilWrite=this._setSubState(e,this._stencilWrite,this._stencilWriteInvalid,this._stateSetters.setStencilWrite),this._stencilTestInvalid=!1}_setDrawBuffers(e){this._drawBuffers=this._setSubState(e,this._drawBuffers,this._drawBuffersInvalid,this._stateSetters.setDrawBuffers),this._drawBuffersInvalid=!1}_setSubState(e,i,r,s){return(r||e!==i)&&(s(e),this._pipelineInvalid=!0),e}};const gd=()=>yt.getLogger("esri.views.3d.webgl.ShaderTechnique");let Ns=class{constructor(e,i,r,s){this.primitiveType=yc.TRIANGLES,this.key=i.key,this._program=new Ln(e.rctx,r.get().build(i),s),this._pipeline=this.initializePipeline(i),this.reload=async n=>{n&&await r.reload(),this.key.equals(i.key)||gd().warn("Configuration was changed after construction, cannot reload shader.",r),cr(this._program),this._program=new Ln(e.rctx,r.get().build(i),s),this._pipeline=this.initializePipeline(i)}}destroy(){this._program=cr(this._program),this._pipeline=null}get program(){return this._program}get compiled(){return this.program.compiled}ensureAttributeLocations(e){this.program.assertCompatibleVertexAttributeLocations(e)}getPipeline(e,i){return this._pipeline}initializePipeline(e){return Or({blending:no,colorWrite:Rr})}};function vd(t,e){return _c(t)?{buffers:[wc]}:e??null}const Xv=[],_d=[new si("position",3,Ce.FLOAT,0,12)],xd=[new si("position",2,Ce.FLOAT,0,8)],go=Na(xd),Yv=Na(_d),Zv=[new si("position",2,Ce.FLOAT,0,12),new si("uv0",2,Ce.HALF_FLOAT,8,12)],Kv=[new si("position",2,Ce.FLOAT,0,16),new si("uv0",2,Ce.FLOAT,8,16)];let bd=class{constructor(e){this._bits=[...e]}equals(e){return Pl(this._bits,e.bits)}get code(){return this._code??=String.fromCharCode(...this._bits),this._code}get bits(){return this._bits}},yd=class extends Ve{constructor(){super(),this._parameterBits=this._parameterBits?.map(()=>0)??[],this._parameterNames??=[]}get key(){return this._key??=new bd(this._parameterBits),this._key}decode(e=this.key){const i=this._parameterBits;this._parameterBits=[...e.bits];const r=this._parameterNames.map(s=>`    ${s}: ${this[s]}`).join(`
`);return this._parameterBits=i,r}};function L(t={}){return(e,i)=>{e.hasOwnProperty("_parameterNames")||Object.defineProperty(e,"_parameterNames",{value:e._parameterNames?.slice()??[],configurable:!0,writable:!0}),e.hasOwnProperty("_parameterBits")||Object.defineProperty(e,"_parameterBits",{value:e._parameterBits?.slice()??[0],configurable:!0,writable:!0}),e._parameterNames.push(i);const r=t.count||2,s=Math.ceil(Math.log2(r)),n=e._parameterBits;let a=0;for(;n[a]+s>16;)a++,a>=n.length&&n.push(0);const l=n[a],o=(1<<s)-1<<l;n[a]+=s,t.count?Object.defineProperty(e,i,{get(){return(this._parameterBits[a]&o)>>l},set(c){if(this[i]!==c){if(this._key=null,this._parameterBits[a]=this._parameterBits[a]&~o|+c<<l&o,typeof c!="number")throw new Y("internal:invalid-shader-configuration",`Configuration value for ${i} must be a number, got ${typeof c}`);if(t.count==null)throw new Y("internal:invalid-shader-configuration",`Configuration value for ${i} must provide a count option`)}}}):Object.defineProperty(e,i,{get(){return!!((this._parameterBits[a]&o)>>l)},set(c){if(this[i]!==c&&(this._key=null,this._parameterBits[a]=this._parameterBits[a]&~o|+c<<l&o,typeof c!="boolean"))throw new Y("internal:invalid-shader-configuration",`Configuration value for ${i} must be boolean, got ${typeof c}`)}})}}const Vn=()=>yt.getLogger("esri.views.webgl.BufferObject"),wd=!!Sr("esri-tests-disable-gpu-memory-measurements");let Td=class Ut{static createIndex(e,i,r){return new Ut(e,34963,i,r)}static createUniform(e,i,r){return new Ut(e,35345,i,r)}static createPixelPack(e,i=35041,r){const s=new Ut(e,35051,i);return r&&s.setSize(r),s}static createPixelUnpack(e,i=35040,r){return new Ut(e,35052,i,r)}static createTransformFeedback(e,i=35044,r){const s=new Ut(e,35982,i);return s.setSize(r),s}constructor(e,i,r,s){this._context=e,this.bufferType=i,this.usage=r,this._glName=null,this._size=-1,this._indexType=void 0,e.instanceCounter.increment(pr.BufferObject,this),this._glName=this._context.gl.createBuffer(),ke(this._context.gl),s&&this.setData(s)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get sizeBytes(){if(this.bufferType===34963){if(this._indexType===Ce.UNSIGNED_INT)return 4*this._size;if(this._indexType===Ce.UNSIGNED_SHORT)return 2*this._size}return this._size}get usedMemory(){return wd?0:this.sizeBytes}get _isVAOAware(){return this.bufferType===34963||this.bufferType===34962}dispose(){this._context?.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(pr.BufferObject,this),this._context=null):this._glName&&Vn().warn("Leaked WebGL buffer object")}setSize(e,i=null){if(this.bufferType===34963&&i!=null)switch(this._indexType=i,i){case Ce.UNSIGNED_SHORT:e*=2;break;case Ce.UNSIGNED_INT:e*=4}this._setBufferData(e)}setData(e){if(!e)return;let i=e.byteLength;this.bufferType===34963&&(xi(e)?this._indexType=Ce.UNSIGNED_BYTE:ma(e)?(i/=2,this._indexType=Ce.UNSIGNED_SHORT):Dl(e)&&(i/=4,this._indexType=Ce.UNSIGNED_INT)),this._setBufferData(i,e)}_setBufferData(e,i=null){this._size=e;const r=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const s=this._context.gl;i!=null?s.bufferData(this.bufferType,i,this.usage):s.bufferData(this.bufferType,e,this.usage),ke(s),this._isVAOAware&&this._context.bindVAO(r)}setSubData(e,i,r,s){if(!e)return;const n=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const{gl:a}=this._context;a.bufferSubData(this.bufferType,i*e.BYTES_PER_ELEMENT,e,r,s-r),ke(a),this._isVAOAware&&this._context.bindVAO(n)}getSubData(e,i=0,r,s){if(r<0||s<0)return;const n=Md(e)?e.BYTES_PER_ELEMENT:1;if(n*((r??0)+(s??0))>e.byteLength)return;i+n*(s??0)>this.usedMemory&&Vn().warn("Potential problem getting subdata: requested data exceeds buffer size!");const a=this._context.gl;this.bufferType===35982?(this._context.bindBuffer(this,35982),a.getBufferSubData(35982,i,e,r,s),this._context.unbindBuffer(35982)):(this._context.bindBuffer(this,36662),a.getBufferSubData(36662,i,e,r,s),this._context.unbindBuffer(36662))}async getSubDataAsync(e,i=0,r,s){await this._context.clientWaitAsync(),this.getSubData(e,i,r,s)}};function Md(t){return zl(t)}function e0(t,e,i,r=0){const s=t.gl;t.bindBuffer(i);for(const n of i.layout){const a=e.get(n.name);if(a==null){console.warn(`There is no location for vertex attribute '${n.name}' defined.`);continue}const l=r*n.stride;if(n.count<=4)s.vertexAttribPointer(a,n.count,n.type,n.normalized,n.stride,n.offset+l),s.enableVertexAttribArray(a),n.divisor>0&&s.vertexAttribDivisor(a,n.divisor);else if(n.count===9)for(let o=0;o<3;o++)s.vertexAttribPointer(a+o,3,n.type,n.normalized,n.stride,n.offset+12*o+l),s.enableVertexAttribArray(a+o),n.divisor>0&&s.vertexAttribDivisor(a+o,n.divisor);else if(n.count===16)for(let o=0;o<4;o++)s.vertexAttribPointer(a+o,4,n.type,n.normalized,n.stride,n.offset+16*o+l),s.enableVertexAttribArray(a+o),n.divisor>0&&s.vertexAttribDivisor(a+o,n.divisor);else console.error("Unsupported vertex attribute element count: "+n.count);if(Ii()){const o=ro(t.gl);o&&console.error(`Unable to bind vertex attribute "${n.name}" with baseInstanceOffset ${l}:`,o,n)}}}function Sd(t){switch(t){case 6406:case 6409:case 6403:case 36244:case 6402:case 34041:return 1;case 6410:case 33319:case 33320:return 2;case 6407:case 36248:return 3;case 6408:case 36249:return 4}return 0}function vo(t){switch(t){case 6406:case 6409:case 6403:case 36244:case A.R8:case A.R8I:case A.R8UI:case A.R8_SNORM:case 36168:return 1;case 6410:case 33319:case 33320:case A.RGBA4:case A.R16F:case A.R16I:case A.R16UI:case A.RG8:case A.RG8I:case A.RG8UI:case A.RG8_SNORM:case A.RGB565:case A.RGB5_A1:case yi.DEPTH_COMPONENT16:return 2;case 6407:case 36248:case A.RGB8:case A.RGB8I:case A.RGB8UI:case A.RGB8_SNORM:case A.SRGB8:case yi.DEPTH_COMPONENT24:return 3;case 6408:case 36249:case A.RGBA8:case A.R32F:case A.R11F_G11F_B10F:case A.RG16F:case A.R32I:case A.R32UI:case A.RG16I:case A.RG16UI:case A.RGBA8I:case A.RGBA8UI:case A.RGBA8_SNORM:case A.SRGB8_ALPHA8:case A.RGB9_E5:case A.RGB10_A2UI:case A.RGB10_A2:case yi.DEPTH_COMPONENT32F:case mr.DEPTH24_STENCIL8:return 4;case mr.DEPTH32F_STENCIL8:return 5;case A.RGB16F:case A.RGB16I:case A.RGB16UI:return 6;case A.RG32F:case A.RG32I:case A.RG32UI:case A.RGBA16F:case A.RGBA16I:case A.RGBA16UI:return 8;case A.RGB32F:case A.RGB32I:case A.RGB32UI:return 12;case A.RGBA32F:case A.RGBA32I:case A.RGBA32UI:return 16;case Q.COMPRESSED_RGB_S3TC_DXT1_EXT:case Q.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case Q.COMPRESSED_RGBA_S3TC_DXT3_EXT:case Q.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case Q.COMPRESSED_R11_EAC:case Q.COMPRESSED_SIGNED_R11_EAC:case Q.COMPRESSED_RGB8_ETC2:case Q.COMPRESSED_SRGB8_ETC2:case Q.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Q.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case Q.COMPRESSED_RG11_EAC:case Q.COMPRESSED_SIGNED_RG11_EAC:case Q.COMPRESSED_RGBA8_ETC2_EAC:case Q.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}let Ls=class{constructor(e=0,i=e){this.width=e,this.height=i,this.type=0,this.target=3553,this.pixelFormat=6408,this.dataType=hs.UNSIGNED_BYTE,this.samplingMode=9729,this.wrapMode=10497,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.compareEnabled=!1,this.linearFilterDepth=!1,this.depth=1,this.isImmutable=!1}};function $d(t){return t.width<=0||t.height<=0||t.depth<=0?0:Math.round(t.width*t.height*t.depth*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:vo(t.internalFormat))*(t.target===34067?6:1))}const hi=()=>yt.getLogger("esri/views/webgl/textureUtils");function di(t){const{width:e,height:i,depth:r}=t;(e!=null&&e<0||i!=null&&i<0||r!=null&&r<0)&&hi().error("Negative dimension parameters are not allowed!");const{internalFormat:s}=t;if(s&&(_o(s)||xo(s))){const{linearFilterDepth:n,compareEnabled:a,samplingMode:l,hasMipmap:o}=t;o&&hi().error("Depth textures cannot have mipmaps"),n?l!==9729&&l!==9728&&hi().error("Depth textures cannot sample mipmaps"):(l!==9728&&hi().error("Depth textures without filtering must use NEAREST filtering"),a&&hi().error("Depth textures without filtering cannot use compare function"))}}function Cd(t){return Tc.includes(t)}function _o(t){return $r(yi,t)}function xo(t){return $r(mr,t)}function Ed(t){return t!=null&&$r(Q,t)}function Wt(t){return t!=null&&"type"in t&&t.type==="compressed"}function Id(t){return t!=null&&"byteLength"in t}function Bn(t){return t!=null&&!Wt(t)&&!Id(t)}function Ht(t){return t===32879||t===35866}function Hn(t,e,i,r=1){let s=Math.max(e,i);return t===32879&&(s=Math.max(s,r)),Math.floor(Math.log2(s))+1}function ki(t){if(t.internalFormat!=null)return t.internalFormat;switch(t.dataType){case hs.FLOAT:switch(t.pixelFormat){case 6408:return A.RGBA32F;case 6407:return A.RGB32F;default:throw new Y("texture:unknown-format","Unable to derive format")}case hs.UNSIGNED_BYTE:switch(t.pixelFormat){case 6408:return A.RGBA8;case 6407:return A.RGB8}}const{pixelFormat:e}=t;return t.internalFormat=e===34041?mr.DEPTH24_STENCIL8:e===6402?yi.DEPTH_COMPONENT24:e,t.internalFormat}function Ad(t){let e="width"in t?t.width:t.codedWidth,i="height"in t?t.height:t.codedHeight;return t instanceof HTMLVideoElement&&(e=t.videoWidth,i=t.videoHeight),{width:e,height:i,depth:1}}let Fd=class bo extends Ls{constructor(e,i){switch(super(),this.context=e,Object.assign(this,i),this.internalFormat){case A.R16F:case A.R32F:case A.R8_SNORM:case A.R8:this.pixelFormat=6403;break;case A.R8I:case A.R8UI:case A.R16I:case A.R16UI:case A.R32I:case A.R32UI:this.pixelFormat=36244}}static validate(e,i){return new bo(e,i)}};const Rd=!!Sr("esri-tests-disable-gpu-memory-measurements"),tt=()=>yt.getLogger("esri/views/webgl/Texture");let ti=class Se{static{this.TEXTURE_UNIT_FOR_UPDATES=0}static{this.compressionWorkerHandle=null}constructor(e,i=null,r=null){if(this.type=1,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._shadowFilterDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=i;else{const s=Fd.validate(e,i);if(!s)throw new Y("texture:invalid-descriptor","Texture descriptor invalid");this._descriptor=s}this._descriptor.target===34067?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return Rd?0:$d(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty||this._shadowFilterDirty}get hasWebGLTextureObject(){return!!this._glName}dispose(){this.abortCompression(),this.hasWebGLTextureObject&&this._descriptor.context?.gl&&(this._descriptor.context.instanceCounter.decrement(pr.Texture,this),this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null,this._descriptor=null)}release(){this.dispose()}[Symbol.dispose](){this.dispose()}resize(e,i){const r=this._descriptor;if(r.width!==e||r.height!==i){if(this._wasImmutablyAllocated)throw new Y("texture:immutable-resize","Immutable textures can't be resized!");r.width=e,r.height=i,this._descriptor.target===34067?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.compress=e}disableCompression(){this._descriptor.compress=void 0}setData(e){this.abortCompression(),!Wt(e)&&this._descriptor.internalFormat&&$r(Q,this._descriptor.internalFormat)&&(this._descriptor.internalFormat=void 0),this._setData(e),!Wt(e)&&this._descriptor.compress&&this._compressOnWorker(e)}updateData(e,i,r,s,n,a,l=0){a||tt().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||tt().error("An attempt to update uninitialized texture!");const o=this._descriptor;o.internalFormat=ki(o);const{context:c,pixelFormat:u,dataType:d,target:m,isImmutable:v}=o;if(v&&!this._wasImmutablyAllocated)throw new Y("texture:uninitialized","Cannot update immutable texture before allocation!");const p=c.bindTexture(this,Se.TEXTURE_UNIT_FOR_UPDATES,!0);(i<0||r<0||i+s>o.width||r+n>o.height)&&tt().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:_}=c;l&&(s&&n||tt().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),_.pixelStorei(_.UNPACK_SKIP_ROWS,l)),Bn(a)?_.texSubImage2D(m,e,i,r,s,n,u,d,a):Wt(a)?_.compressedTexSubImage2D(m,e,i,r,s,n,o.internalFormat,a.levels[e]):_.texSubImage2D(m,e,i,r,s,n,u,d,a),l&&_.pixelStorei(_.UNPACK_SKIP_ROWS,0),c.bindTexture(p,Se.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,i,r,s,n,a,l,o){o||tt().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||tt().error("An attempt to update an uninitialized texture!");const c=this._descriptor;c.internalFormat=ki(c);const{context:u,pixelFormat:d,dataType:m,isImmutable:v,target:p}=c;if(v&&!this._wasImmutablyAllocated)throw new Y("texture:uninitialized","Cannot update immutable texture before allocation!");Ht(p)||tt().warn("Attempting to set 3D texture data on a non-3D texture");const _=u.bindTexture(this,Se.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(Se.TEXTURE_UNIT_FOR_UPDATES),(i<0||r<0||s<0||i+n>c.width||r+a>c.height||s+l>c.depth)&&tt().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:b}=u;if(Wt(o))o=o.levels[e],b.compressedTexSubImage3D(p,e,i,r,s,n,a,l,c.internalFormat,o);else{const y=o;b.texSubImage3D(p,e,i,r,s,n,a,l,d,m,y)}u.bindTexture(_,Se.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(e.width===0||e.height===0)return;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new Y("texture:immutable-change","Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,di(e)}e.samplingMode===9729?(this._samplingModeDirty=!0,e.samplingMode=9985):e.samplingMode===9728&&(this._samplingModeDirty=!0,e.samplingMode=9984);const i=this._descriptor.context.bindTexture(this,Se.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(Se.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(i,Se.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new Y("texture:immutable-change","Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,di(e)}e.samplingMode===9985?(this._samplingModeDirty=!0,e.samplingMode=9729):e.samplingMode===9984&&(this._samplingModeDirty=!0,e.samplingMode=9728)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,di(this._descriptor),this._wrapModeDirty=!0)}setShadowFiltering(e){e!==this._descriptor.linearFilterDepth&&(this._descriptor.linearFilterDepth=this._descriptor.compareEnabled=e,this.setSamplingMode(e?9729:9728),di(this._descriptor),this._shadowFilterDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1),this._shadowFilterDirty&&(this._applyShadowMode(),this._shadowFilterDirty=!1)}abortCompression(){this._compressionAbortController=Nl(this._compressionAbortController)}_setData(e,i){const r=this._descriptor,s=r.context?.gl;if(!s)return;ke(s),this.hasWebGLTextureObject||(this._glName=s.createTexture(),r.context.instanceCounter.increment(pr.Texture,this)),di(r);const n=r.context.bindTexture(this,Se.TEXTURE_UNIT_FOR_UPDATES);r.context.setActiveTexture(Se.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),ke(s);const a=i??r.target,l=Ht(a);if(Bn(e))this._setDataFromTexImageSource(e,a);else{const{width:o,height:c,depth:u}=r;if(o==null||c==null)throw new Y("texture:missing-size","Width and height must be specified!");if(l&&u==null)throw new Y("texture:missing-depth","Depth must be specified!");if(r.internalFormat=ki(r),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,r.internalFormat,r.hasMipmap,o,c,u),Wt(e)){if(!Ed(r.internalFormat))throw new Y("texture:format-mismatch","Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(e,r.internalFormat,a)}else this._texImage(a,0,r.internalFormat,o,c,u,e),ke(s),r.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),this._applyShadowMode(),ke(s),r.context.bindTexture(n,Se.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let i=34069;i<=34074;i++)this._setData(e,i)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:i,flipped:r,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,i),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_setDataFromTexImageSource(e,i){const{gl:r}=this._descriptor.context,s=this._descriptor;s.internalFormat=ki(s);const n=Ht(i),{width:a,height:l,depth:o}=Ad(e);s.width&&s.height,s.width||(s.width=a),s.height||(s.height=l),n&&s.depth,n&&(s.depth=o),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(i,s.internalFormat,s.hasMipmap,a,l,o),this._texImage(i,0,s.internalFormat,a,l,o,e),ke(r),s.hasMipmap&&(this.generateMipmap(),ke(r))}_setDataFromCompressedSource(e,i,r){const s=this._descriptor,{width:n,height:a,depth:l}=s,o=e.levels,c=Hn(r,n,a,l),u=Math.min(c,o.length)-1;this._descriptor.context.gl.texParameteri(s.target,33085,u),this._forEachMipmapLevel((d,m,v,p)=>{const _=o[Math.min(d,o.length-1)];this._compressedTexImage(r,d,i,m,v,p,_)},u)}_texStorage(e,i,r,s,n,a){const{gl:l}=this._descriptor.context;if(!Cd(i)&&!_o(i)&&!xo(i))throw new Y("texture:missing-format","Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const o=r?Hn(e,s,n,a):1;if(Ht(e)){if(a==null)throw new Y("texture:missing-depth","Missing depth dimension for 3D texture upload");l.texStorage3D(e,o,i,s,n,a)}else l.texStorage2D(e,o,i,s,n);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,n,a,l){const o=this._descriptor.context.gl,c=Ht(e),{isImmutable:u,pixelFormat:d,dataType:m}=this._descriptor;if(u){if(l!=null){const v=l;if(c){if(a==null)throw new Y("texture:missing-depth","Missing depth dimension for 3D texture upload");o.texSubImage3D(e,i,0,0,0,s,n,a,d,m,v)}else o.texSubImage2D(e,i,0,0,s,n,d,m,v)}}else{const v=l;if(c){if(a==null)throw new Y("texture:missing-depth","Missing depth dimension for 3D texture upload");o.texImage3D(e,i,r,s,n,a,0,d,m,v)}else o.texImage2D(e,i,r,s,n,0,d,m,v)}}_compressedTexImage(e,i,r,s,n,a,l){const o=this._descriptor.context.gl,c=Ht(e);if(this._descriptor.isImmutable){if(l!=null)if(c){if(a==null)throw new Y("texture:missing-depth","Missing depth dimension for 3D texture upload");o.compressedTexSubImage3D(e,i,0,0,0,s,n,a,r,l)}else o.compressedTexSubImage2D(e,i,0,0,s,n,r,l)}else if(c){if(a==null)throw new Y("texture:missing-depth","Missing depth dimension for 3D texture upload");o.compressedTexImage3D(e,i,r,s,n,a,0,l)}else o.compressedTexImage2D(e,i,r,s,n,0,l)}async _compressOnWorker(e){const{width:i,height:r,context:s,flipped:n,preMultiplyAlpha:a,hasMipmap:l}=this._descriptor,o=this._descriptor.compress?.compressionTracker,c=this._descriptor.compress?.compressionCallback,{compressedTextureETC:u,compressedTextureS3TC:d}=s.capabilities;if(!Se.compressionWorkerHandle?.isCompressible(e,this._descriptor)||!u&&!d)return;this.abortCompression();const m=new AbortController;let v;this._compressionAbortController=m,o?.increment();try{e instanceof Uint8Array?v=e.buffer:(v=await createImageBitmap(e,{imageOrientation:n?"flipY":"none"}),ur(m));const p={data:v,width:i,height:r,needsFlip:e instanceof Uint8Array&&this.descriptor.flipped,components:this._descriptor.pixelFormat===6408?4:3,preMultiplyAlpha:a,hasMipmap:l,hasETC:!!u,hasS3TC:!!d},_=await Se.compressionWorkerHandle.invoke(p,m.signal,"low");if(ur(m),_.compressedTexture&&this.hasWebGLTextureObject){const b=this.usedMemory;this._descriptor.internalFormat=_.internalFormat,this._setData(_.compressedTexture),c?.(b-this.usedMemory)}}catch(p){Ll(p)||tt().error("Texture compression failed!")}finally{o?.decrement(),this._compressionAbortController?.signal.aborted&&(this._compressionAbortController=null),v instanceof ImageBitmap&&v.close()}}_forEachMipmapLevel(e,i=1/0){let{width:r,height:s,depth:n,hasMipmap:a,target:l}=this._descriptor;const o=l===32879;if(r==null||s==null||o&&n==null)throw new Y("texture:missing-size","Missing texture dimensions for mipmap calculation");for(let c=0;e(c,r,s,n),a&&(r!==1||s!==1||o&&n!==1)&&!(c>=i);++c)r=Math.max(1,r>>1),s=Math.max(1,s>>1),o&&(n=Math.max(1,n>>1))}_applySamplingMode(){const e=this._descriptor,i=e.context?.gl;let r=e.samplingMode,s=e.samplingMode;r===9985||r===9987?(r=9729,e.hasMipmap||(s=9729)):r!==9984&&r!==9986||(r=9728,e.hasMipmap||(s=9728)),i.texParameteri(e.target,i.TEXTURE_MAG_FILTER,r),i.texParameteri(e.target,i.TEXTURE_MIN_FILTER,s)}_applyWrapMode(){const e=this._descriptor,i=e.context?.gl;typeof e.wrapMode=="number"?(i.texParameteri(e.target,i.TEXTURE_WRAP_S,e.wrapMode),i.texParameteri(e.target,i.TEXTURE_WRAP_T,e.wrapMode)):(i.texParameteri(e.target,i.TEXTURE_WRAP_S,e.wrapMode.s),i.texParameteri(e.target,i.TEXTURE_WRAP_T,e.wrapMode.t))}_applyShadowMode(){const e=this._descriptor,i=e.context?.gl,r=e.compareEnabled?i.COMPARE_REF_TO_TEXTURE:i.NONE;i.texParameteri(e.target,i.TEXTURE_COMPARE_MODE,r),e.compareEnabled&&i.texParameteri(e.target,i.TEXTURE_COMPARE_FUNC,i.GREATER),ke(i)}_applyAnisotropicFilteringParameters(){const e=this._descriptor,i=e.context.capabilities.textureFilterAnisotropic;i&&e.context.gl.texParameterf(e.target,i.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}},Dt=class extends ie{constructor(e,i,r){super(e,"vec3",0,(s,n)=>s.setUniform3fv(e,i(n),r))}},nr=class extends ie{constructor(e,i,r){super(e,"mat4",0,(s,n)=>s.setUniformMatrix4fv(e,i(n),r))}},Rt=class extends Mr{constructor(e){super(e),this.view=null,this.consumes={required:[]},this.produces=Fh.COMPOSITE,this.requireGeometryDepth=!1,this._dirty=!0}initialize(){this.addHandles([Oa(()=>this.view.ready,e=>{e&&this.view.stage?.renderer.addRenderNode(this)},Zc)])}destroy(){this.view.stage?.renderer?.removeRenderNode(this)}precompile(){}render(){throw new Y("RenderNode:render-function-not-implemented","render() is not implemented.")}get camera(){return this.view.state.camera.clone()}get sunLight(){return this.bindParameters.lighting.legacy}get gl(){return this.view.stage.renderView.renderingContext.gl}get techniques(){return this.view.stage.renderView.techniques}acquireOutputFramebuffer(){const e=this._frameBuffer?.getTexture()?.descriptor,i=this.view.stage.renderer.fboCache.acquire(e?.width??640,e?.height??480,this.produces);return i.fbo?.initializeAndBind(),i}bindRenderTarget(){return this._frameBuffer?.fbo?.initializeAndBind(),this._frameBuffer}requestRender(e){switch(e){case 2:this.view.state.fading=!0;case 1:this.view.stage?.renderView.requestRender(e);case 0:case void 0:this._dirty=!0}}resetWebGLState(){this.renderingContext.resetState(),this.renderingContext.bindFramebuffer(this._frameBuffer?.fbo)}get fboCache(){return this.view.stage.renderer.fboCache}get bindParameters(){return this.renderContext.bind}get renderingContext(){return this.view.stage.renderView.renderingContext}get renderContext(){return this.view.stage?.renderer.renderContext}updateAnimation(e){return!!this._dirty&&(this._dirty=!1,!0)}doRender(e){this._frameBuffer=e.find(({name:i})=>i===this.produces);try{return this.render(e)}finally{this._frameBuffer=null}}};f([x({constructOnly:!0})],Rt.prototype,"view",void 0),f([x({constructOnly:!0})],Rt.prototype,"consumes",void 0),f([x()],Rt.prototype,"produces",void 0),f([x({readOnly:!0})],Rt.prototype,"techniques",null),Rt=f([zt("esri.views.3d.webgl.RenderNode")],Rt);let Od=class extends Td{constructor(e,i,r,s=35044){super(e,34962,s,r),this.layout=i}},Pd=class{constructor(e=$i()){this.intensity=e}},Dd=class{constructor(e=$i(),i=ve(.57735,.57735,.57735)){this.intensity=e,this.direction=i}},Ss=class{constructor(e=$i(),i=ve(.57735,.57735,.57735),r=!0,s=1,n=1){this.intensity=e,this.direction=i,this.castShadows=r,this.specularStrength=s,this.environmentStrength=n}},yo=class{constructor(){this.r=[0],this.g=[0],this.b=[0]}},J=class extends Mr{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.TEXT_SHOW_BASELINE=!1,this.TEXT_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TESTS_DISABLE_OPTIMIZATIONS=!1,this.TESTS_DISABLE_FAST_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.TERRAIN_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1,this.LINE_WIREFRAMES=!1}};f([x()],J.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),f([x()],J.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),f([x()],J.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),f([x()],J.prototype,"DECONFLICTOR_SHOW_GRID",void 0),f([x()],J.prototype,"LABELS_SHOW_BORDER",void 0),f([x()],J.prototype,"TEXT_SHOW_BASELINE",void 0),f([x()],J.prototype,"TEXT_SHOW_BORDER",void 0),f([x()],J.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),f([x()],J.prototype,"OVERLAY_SHOW_CENTER",void 0),f([x()],J.prototype,"SHOW_POI",void 0),f([x()],J.prototype,"TESTS_DISABLE_OPTIMIZATIONS",void 0),f([x()],J.prototype,"TESTS_DISABLE_FAST_UPDATES",void 0),f([x()],J.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),f([x()],J.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),f([x()],J.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),f([x()],J.prototype,"TERRAIN_TILE_TREE_SHOW_TILES",void 0),f([x()],J.prototype,"I3S_TREE_SHOW_TILES",void 0),f([x()],J.prototype,"I3S_SHOW_MODIFICATIONS",void 0),f([x()],J.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),f([x()],J.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),f([x()],J.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),f([x()],J.prototype,"LINE_WIREFRAMES",void 0),J=f([zt("esri.views.3d.support.debugFlags")],J);const zd=new J;let $s=class{constructor(){this._scale=0,this._angleFactor=0,this._minScale=0}update(e,i,r,s){r?(this._scale=Math.min(r.divisor/(i-r.offset),1),this._angleFactor=Nd(e),this._minScale=s!=null?Math.min(r.minPixelSize/s,1):0):(this._scale=1,this._minScale=1,this._angleFactor=1)}apply(e){const{_scale:i,_angleFactor:r,_minScale:s}=this;return e*Le(ge(i,1,r),s,1)}applyVec2(e,i){e[0]=this.apply(i[0]),e[1]=this.apply(i[1])}},d0=class{constructor(){this.evaluator=new $s,this.alignmentEvaluator=new $s}update(e,i,r,s,n,a){this.evaluator.update(e,i,r,s),this.alignmentEvaluator.update(e,i,n??r,(n?a:null)??s)}};function Nd(t){return Math.abs(t)**3}function p0(t){return!!t&&!0}let Ld=class{constructor(){this.distance=0,this.fovY=0}},g0=class{constructor(){this.camera=new Ld,this.offset=0,this.divisor=0,this.minPixelSize=0}};function Vs(){return!!Sr("enable-feature:objectAndLayerId-rendering")}let Bs=class{constructor(e){this.field=e}},Vd=class extends Bs{constructor(e){super(e),this.minSize=[0,0,0],this.maxSize=[0,0,0],this.offset=[0,0,0],this.factor=[0,0,0],this.type=[0,0,0],this.fallback=[0,0,0]}},jn=class extends Bs{constructor(e){super(e),this.colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.values=[0,0,0,0,0,0,0,0],this.fallback=[0,0,0,0]}},Bd=class extends Bs{constructor(e,i=0){super(e),this.fallback=i,this.values=[0,0,0,0,0,0,0,0],this.opacityValues=[0,0,0,0,0,0,0,0]}},Hd=class{};function fi(t){return t!=null}function ae(t,e){t&&t.push(e)}function jd(t,e,i,r=ne()){const s=t||0,n=e||0,a=i||0;return s!==0&&Wc(r,r,-s/180*Math.PI),n!==0&&Aa(r,r,n/180*Math.PI),a!==0&&kc(r,r,a/180*Math.PI),r}function ht(t,e,i,r,s){const n=t.minSize,a=t.maxSize;if(t.useSymbolValue){const l=r.symbolSize[i];return e.minSize[i]=l,e.maxSize[i]=l,e.offset[i]=e.minSize[i],e.factor[i]=0,e.type[i]=1,!0}if(fi(t.field))return fi(t.stops)?t.stops.length===2&&Lt(t.stops[0].size)&&Lt(t.stops[1].size)?(Gn(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,e,i),e.type[i]=1,!0):(ae(s,"Could not convert size info: stops only supported with 2 elements"),!1):Lt(n)&&Lt(a)&&fi(t.minDataValue)&&fi(t.maxDataValue)?(Gn(n,a,t.minDataValue,t.maxDataValue,e,i),e.type[i]=1,!0):t.valueUnit==="unknown"?(ae(s,"Could not convert size info: proportional size not supported"),!1):xn[t.valueUnit]!=null?(e.minSize[i]=-1/0,e.maxSize[i]=1/0,e.offset[i]=0,e.factor[i]=1/xn[t.valueUnit],e.type[i]=1,!0):(ae(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!fi(t.field)){if(t.stops?.[0]&&Lt(t.stops[0].size))return e.minSize[i]=t.stops[0].size,e.maxSize[i]=t.stops[0].size,e.offset[i]=e.minSize[i],e.factor[i]=0,e.type[i]=1,!0;if(Lt(n))return e.minSize[i]=n,e.maxSize[i]=n,e.offset[i]=n,e.factor[i]=0,e.type[i]=1,!0}return ae(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function Gn(t,e,i,r,s,n){const a=Math.abs(r-i)>0?(e-t)/(r-i):0;s.minSize[n]=a>0?t:e,s.maxSize[n]=a>0?e:t,s.offset[n]=t-i*a,s.factor[n]=a}function Gd(t,e,i,r){if(t.normalizationField||t.valueRepresentation)return ae(r,"Could not convert size info: unsupported property"),null;if(!au(t.field))return ae(r,"Could not convert size info: field is not a string"),null;if(e.size){if(t.field)if(e.size.field){if(t.field!==e.size.field)return ae(r,"Could not convert size info: multiple fields in use"),null}else e.size.field=t.field}else e.size=new Vd(t.field),Z(e.size.fallback,i.fallbackSize);let s;switch(t.axis){case"width":return s=ht(t,e.size,0,i,r),s?e:null;case"height":return s=ht(t,e.size,2,i,r),s?e:null;case"depth":return s=ht(t,e.size,1,i,r),s?e:null;case"width-and-depth":return s=ht(t,e.size,0,i,r),s&&ht(t,e.size,1,i,r),s?e:null;case null:case void 0:case"all":return s=ht(t,e.size,0,i,r),s=s&&ht(t,e.size,1,i,r),s=s&&ht(t,e.size,2,i,r),s?e:null;default:return ae(r,`Could not convert size info: unknown axis "${t.axis}""`),null}}function Ud(t,e,i){for(let s=0;s<3;++s){let n=e.unitInMeters;t.type[s]===1&&(n*=e.modelSize[s],t.type[s]=2),t.minSize[s]=t.minSize[s]/n,t.maxSize[s]=t.maxSize[s]/n,t.offset[s]=t.offset[s]/n,t.factor[s]=t.factor[s]/n}let r;if(t.type[0]!==0)r=0;else if(t.type[1]!==0)r=1;else{if(t.type[2]===0)return ae(i,"No size axis contains a valid size or scale"),!1;r=2}for(let s=0;s<3;++s)t.type[s]===0&&(t.minSize[s]=t.minSize[r],t.maxSize[s]=t.maxSize[r],t.offset[s]=t.offset[r],t.factor[s]=t.factor[r],t.type[s]=t.type[r]);return!0}function Un(t,e,i){t[4*e]=i.r/255,t[4*e+1]=i.g/255,t[4*e+2]=i.b/255,t[4*e+3]=i.a}function Wd(t,e,i,r){if(t.normalizationField)return ae(r,"Could not convert color info: unsupported property"),null;if(Fs(t.field)){if(!t.stops)return ae(r,"Could not convert color info: missing stops or colors"),null;{if(t.stops.length>8)return ae(r,"Could not convert color info: too many color stops"),null;e.color=new jn(t.field);const s=t.stops;for(let n=0;n<8;++n){const a=s[Math.min(n,s.length-1)];e.color.values[n]=a.value,Un(e.color.colors,n,a.color)}qt(e.color.fallback,i.fallbackColor)}}else{if(!(t.stops&&t.stops.length>=0))return ae(r,"Could not convert color info: no field and no colors/stops"),null;{const s=t.stops&&t.stops.length>=0&&t.stops[0].color;e.color=new jn(null);for(let n=0;n<8;n++)e.color.values[n]=1/0,Un(e.color.colors,n,s);qt(e.color.fallback,i.fallbackColor)}}return e}function kd(t,e,i,r){if(t.normalizationField)return ae(r,"Could not convert opacity info: unsupported property"),null;if(Fs(t.field)){if(!t.stops)return ae(r,"Could not convert opacity info: missing stops or opacities"),null;{if(t.stops.length>8)return ae(r,"Could not convert opacity info: too many opacity stops"),null;e.opacity=new Bd(t.field,i.fallbackColor[3]);const s=t.stops;for(let n=0;n<8;++n){const a=s[Math.min(n,s.length-1)];e.opacity.values[n]=a.value,e.opacity.opacityValues[n]=a.opacity}}}else{if(!(t.stops&&t.stops.length>=0))return ae(r,"Could not convert opacity info: no field and no opacities/stops"),null;{const s=t.stops&&t.stops.length>=0?t.stops[0].opacity:0;e.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0],fallback:i.fallbackColor[3]};for(let n=0;n<8;n++)e.opacity.values[n]=1/0,e.opacity.opacityValues[n]=s}}return e}function ts(t,e,i){const r=i===2&&t.rotationType==="arithmetic";e.offset[i]=r?90:0,e.factor[i]=r?-1:1,e.type[i]=1}function qd(t,e,i){if(!Fs(t.field))return ae(i,"Could not convert rotation info: field is not a string"),null;if(e.rotation){if(t.field)if(e.rotation.field){if(t.field!==e.rotation.field)return ae(i,"Could not convert rotation info: multiple fields in use"),null}else e.rotation.field=t.field}else e.rotation={field:t.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(t.axis){case"tilt":return ts(t,e.rotation,0),e;case"roll":return ts(t,e.rotation,1),e;case null:case void 0:case"heading":return ts(t,e.rotation,2),e;default:return ae(i,`Could not convert rotation info: unknown axis "${t.axis}""`),null}}let T0=class{constructor({supports:e,modelSize:i,symbolSize:r,unitInMeters:s,anchor:n,scale:a,rotation:l,fallbackColor:o,fallbackSize:c}){this.supports=e,this.modelSize=i??Li(),this.symbolSize=r??Li(),this.unitInMeters=s??1,this.anchor=n??$i(),this.scale=a??Li(),this.rotation=l??$i(),this.fallbackColor=o??Yc(),this.fallbackSize=c??Li()}};function wo(t,e,i){if(!t)return null;const r=t.reduce((s,n)=>{if(!s)return s;if(n.valueExpression)return ae(i,"Could not convert visual variables: arcade expressions not supported"),null;switch(n.type){case"size":return e.supports.size?Gd(n,s,e,i):s;case"color":return e.supports.color?Wd(n,s,e,i):s;case"opacity":return e.supports.opacity?kd(n,s,e,i):null;case"rotation":return e.supports.rotation?qd(n,s,i):s;default:return null}},new Hd);return!(t.length>0&&r)||r.size||r.color||r.opacity||r.rotation?r?.size&&!Ud(r.size,e,i)?null:r:null}let Xd=class{constructor(e,i,r){this.visualVariables=e,this.materialParameters=i,this.requiresShaderTransformation=r}};function $0(t,e){if(!t||Vs()||zd.TESTS_DISABLE_FAST_UPDATES)return null;const i=wo(t.visualVariables,e);return i?new Xd(i,Mo(i,e),!!i.size):null}function C0(t,e,i){if(!e||!t)return!1;const r=t.visualVariables,s=wo(e.visualVariables,i);return!!s&&!!(qi(r.size,s.size,"size")&&qi(r.color,s.color,"color")&&qi(r.rotation,s.rotation,"rotation")&&qi(r.opacity,s.opacity,"opacity"))&&(t.visualVariables=s,t.materialParameters=Mo(s,i),t.requiresShaderTransformation=!!s.size,!0)}function qi(t,e,i){if(!!t!=!!e||t&&t.field!==e?.field)return!1;if(t&&i==="rotation"){const r=t,s=e;for(let n=0;n<3;n++)if(r.type[n]!==s.type[n]||r.offset[n]!==s.offset[n]||r.factor[n]!==s.factor[n])return!1}return!0}class To extends Ve{constructor(e){super(),this.vvSize=e?.size??null,this.vvColor=e?.color??null,this.vvOpacity=e?.opacity??null}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}function Mo(t,e){const i=new To(t);return i.vvSize&&(i.vvSymbolAnchor=e.anchor,Uc(wi),jd(e.rotation[2],e.rotation[0],e.rotation[1],wi),i.vvSymbolRotationMatrix=i.vvSymbolRotationMatrix||wt(),Ia(i.vvSymbolRotationMatrix,wi)),i}function E0(t,e,i){if(!t.vvSize)return i;ei(dt,i);const r=t.vvSymbolRotationMatrix;return jc(wi,r[0],r[1],r[2],0,r[3],r[4],r[5],0,r[6],r[7],r[8],0,0,0,0,1),Ei(dt,dt,wi),Yd(Wn,t,e),Gc(dt,dt,Wn),gr(dt,dt,t.vvSymbolAnchor),dt}function Yd(t,e,i){if(!e.vvSize)return U(t,1,1,1),t;if(Number.isNaN(i[0]))return Z(t,e.vvSize.fallback);for(let r=0;r<3;++r){const s=e.vvSize.offset[r]+i[0]*e.vvSize.factor[r];t[r]=Le(s,e.vvSize.minSize[r],e.vvSize.maxSize[r])}return t}function I0(t,e){const i=t==null?0:e.attributes[t];return typeof i=="number"&&isFinite(i)?i:NaN}const dt=ne(),Wn=g(),wi=ne();function Zd(t){t.vertex.code.add(h`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),t.vertex.code.add(h`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),t.vertex.code.add(h`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return size * clamp(mix(factor.x, 1.0, factor.y), factor.z, 1.0);
}`),t.vertex.code.add(h`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),t.vertex.code.add(h`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return size * clamp(mix(factor.x, 1.0, factor.y), factor.z, 1.0);
}`),t.vertex.code.add(h`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function A0(t){t.uniforms.add(new ue("screenSizePerspective",e=>So(e.screenSizePerspective,e.screenSizePerspectiveMinPixelReferenceSize)))}function Kd(t){t.uniforms.add(new ue("screenSizePerspectiveAlignment",e=>So(e.screenSizePerspectiveAlignment||e.screenSizePerspective,e.screenSizePerspectiveAlignment?null:e.screenSizePerspectiveMinPixelReferenceSize)))}function So(t,e){const i=e!=null&&t!=null?Math.min(t.minPixelSize/e,1):0;return t?U(kn,t.divisor,t.offset,i):U(kn,0,0,0)}const kn=g();let bt=class extends ie{constructor(e,i,r){super(e,"float",0,(s,n)=>s.setUniform1f(e,i(n),r))}},Jd=class extends ie{constructor(e,i,r){super(e,"mat4",2,(s,n,a)=>s.setUniformMatrix4fv(e,i(n,a),r))}};function Ai(t,e){e.instancedDoublePrecision?t.constants.add("cameraPosition","vec3",ot):t.uniforms.add(new ze("cameraPosition",(i,r)=>U($o,r.camera.viewInverseTransposeMatrix[3]-i.origin[0],r.camera.viewInverseTransposeMatrix[7]-i.origin[1],r.camera.viewInverseTransposeMatrix[11]-i.origin[2])))}function Xt(t,e){if(!e.instancedDoublePrecision)return void t.uniforms.add(new nr("proj",r=>r.camera.projectionMatrix),new Jd("view",(r,s)=>gr(qn,s.camera.viewMatrix,r.origin)),new ze("localOrigin",r=>r.origin));const i=({camera:r})=>U($o,r.viewInverseTransposeMatrix[3],r.viewInverseTransposeMatrix[7],r.viewInverseTransposeMatrix[11]);t.uniforms.add(new nr("proj",r=>r.camera.projectionMatrix),new nr("view",r=>gr(qn,r.camera.viewMatrix,i(r))),new Dt("localOrigin",r=>i(r)))}const qn=ne(),$o=g();function Qd(t){t.uniforms.add(new nr("viewNormal",e=>e.camera.viewInverseTransposeMatrix))}function O0(t){t.uniforms.add(new bt("pixelRatio",e=>e.camera.pixelRatio/e.overlayStretch))}let Pr=class extends ie{constructor(e,i,r){super(e,"vec4",1,(s,n,a)=>s.setUniform4fv(e,i(n,a),r))}},D0=class{constructor(e){this.screenLength=su(e.screenLength),this.minWorldLength=e.minWorldLength??0,this.maxWorldLength=e.maxWorldLength??1/0}};function Co(t,e){const i=t.vertex;e.hasVerticalOffset?(tf(i),e.hasScreenSizePerspective&&(t.include(Zd),Kd(i),Ai(t.vertex,e)),i.code.add(h`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${e.spherical?h`vec3 worldNormal = normalize(worldPos + localOrigin);`:h`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${e.hasScreenSizePerspective?h`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:h`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):i.code.add(h`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const ef=at();function tf(t){t.uniforms.add(new Pr("verticalOffset",(e,i)=>{const{minWorldLength:r,maxWorldLength:s,screenLength:n}=e.verticalOffset,a=Math.tan(.5*i.camera.fovY)/(.5*i.camera.fullViewport[3]),l=i.camera.pixelRatio||1;return $e(ef,n*l,a,r,s)}))}let Pe=class extends ie{constructor(e,i,r){super(e,"vec4",0,(s,n)=>s.setUniform4fv(e,i(n),r))}},rf=class{constructor(e){this._material=e.material,this._techniques=e.techniques,this._output=e.output}dispose(){}get _stippleTextures(){return this._techniques.context?.stippleTextures}get _markerTextures(){return this._techniques.context?.markerTextures}getTechnique(e,i){return this._techniques.get(e,this._material.getConfiguration(this._output,i))}ensureResources(e){return 2}},sf=class extends rf{constructor(e){super(e),this._numLoading=0,this._disposed=!1,this._textures=e.textures,this.updateTexture(e.textureId),this._acquire(e.normalTextureId,i=>this._textureNormal=i),this._acquire(e.emissiveTextureId,i=>this._textureEmissive=i),this._acquire(e.occlusionTextureId,i=>this._textureOcclusion=i),this._acquire(e.metallicRoughnessTextureId,i=>this._textureMetallicRoughness=i)}dispose(){super.dispose(),this._texture=Ct(this._texture),this._textureNormal=Ct(this._textureNormal),this._textureEmissive=Ct(this._textureEmissive),this._textureOcclusion=Ct(this._textureOcclusion),this._textureMetallicRoughness=Ct(this._textureMetallicRoughness),this._disposed=!0}ensureResources(e){return this._numLoading===0?2:1}get textureBindParameters(){return new af(this._texture?.glTexture??null,this._textureNormal?.glTexture??null,this._textureEmissive?.glTexture??null,this._textureOcclusion?.glTexture??null,this._textureMetallicRoughness?.glTexture??null)}updateTexture(e){this._texture!=null&&e===this._texture.id||(this._texture=Ct(this._texture),this._acquire(e,i=>this._texture=i))}_acquire(e,i){if(e==null)return void i(null);const r=this._textures.acquire(e);if(Vl(r))return++this._numLoading,void r.then(s=>{if(this._disposed)return Ct(s),void i(null);i(s)}).finally(()=>--this._numLoading);i(r)}},nf=class extends Ve{constructor(e=null){super(),this.textureEmissive=e}},af=class extends nf{constructor(e,i,r,s,n,a,l){super(r),this.texture=e,this.textureNormal=i,this.textureOcclusion=s,this.textureMetallicRoughness=n,this.scale=a,this.normalTextureTransformMatrix=l}},of=class extends yd{constructor(){super(...arguments),this.instancedDoublePrecision=!1,this.hasModelTransformation=!1}},Yt=class extends of{constructor(){super(...arguments),this.output=0,this.oitPass=0,this.hasSlicePlane=!1,this.hasHighlightMixTexture=!1,this.bindType=1,this.instanced=!1,this.writeDepth=!0}};f([L({count:11})],Yt.prototype,"output",void 0),f([L({count:3})],Yt.prototype,"oitPass",void 0),f([L()],Yt.prototype,"hasSlicePlane",void 0),f([L()],Yt.prototype,"hasHighlightMixTexture",void 0);function lf(t,e,i,r,s,n){let a=i.screenLength*t.pixelRatio;s!=null&&(Yn.update(r,e,s,n),a=Yn.apply(a));const l=a*Math.tan(.5*t.fovY)/(.5*t.fullHeight);return Le(l*e,i.minWorldLength,i.maxWorldLength)}const cf=Bl();function Xn(t,e){let i=!1;for(const r in e){const s=e[r];s!==void 0&&(Array.isArray(s)?Array.isArray(t[r])&&cf(s,t[r])||(t[r]=s.slice(),i=!0):t[r]!==s&&(i=!0,t[r]=s))}return i}const Ti={multiply:1,ignore:2,replace:3,tint:4},Yn=new $s;let uf=class{constructor(e,i){this.id=Cr(),this.supportsEdges=!1,this._renderPriority=0,this._parameters=new i,Xn(this._parameters,e),this.validateParameters(this._parameters)}get parameters(){return this._parameters}update(e){return!1}setParameters(e,i=!0){Xn(this._parameters,e)&&(this.validateParameters(this._parameters),i&&this._parametersChanged())}validateParameters(e){}shouldRender(e){return this.visible&&this.isVisibleForOutput(e.output)&&(!this.parameters.isDecoration||e.bind.decorations)&&(this.parameters.renderOccluded&e.renderOccludedMask)!==0}isVisibleForOutput(e){return!0}get renderPriority(){return this._renderPriority}set renderPriority(e){e!==this._renderPriority&&(this._renderPriority=e,this._parametersChanged())}_parametersChanged(){this.repository?.materialChanged(this)}get renderOccludedFlags(){return this.visible?this.parameters.renderOccluded:0}get hasEmissions(){return!1}getConfiguration(e,i,r=new Yt){return r.output=e,r.hasHighlightMixTexture=e===9&&i.highlightMixTexture!=null,r}},W0=class extends Ve{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1}};function q0(t,e,i,r=1){const{data:s,indices:n}=t,a=e.typedBuffer,l=e.typedBufferStride,o=n.length;if(i*=l,r===1)for(let c=0;c<o;++c)a[i]=s[n[c]],i+=l;else for(let c=0;c<o;++c){const u=s[n[c]];for(let d=0;d<r;d++)a[i]=u,i+=l}}function is(t,e,i){const{data:r,indices:s}=t,n=e.typedBuffer,a=e.typedBufferStride,l=s.length;i*=a;for(let o=0;o<l;++o){const c=2*s[o];n[i]=r[c],n[i+1]=r[c+1],i+=a}}function Hs(t,e,i,r=1){const{data:s,indices:n}=t,a=e.typedBuffer,l=e.typedBufferStride,o=n.length;if(i*=l,r===1)for(let c=0;c<o;++c){const u=3*n[c];a[i]=s[u],a[i+1]=s[u+1],a[i+2]=s[u+2],i+=l}else for(let c=0;c<o;++c){const u=3*n[c];for(let d=0;d<r;++d)a[i]=s[u],a[i+1]=s[u+1],a[i+2]=s[u+2],i+=l}}function Eo(t,e,i,r=1){const{data:s,indices:n}=t,a=e.typedBuffer,l=e.typedBufferStride,o=n.length;if(i*=l,r===1)for(let c=0;c<o;++c){const u=4*n[c];a[i]=s[u],a[i+1]=s[u+1],a[i+2]=s[u+2],a[i+3]=s[u+3],i+=l}else for(let c=0;c<o;++c){const u=4*n[c];for(let d=0;d<r;++d)a[i]=s[u],a[i+1]=s[u+1],a[i+2]=s[u+2],a[i+3]=s[u+3],i+=l}}function X0(t,e,i){const r=t.typedBuffer,s=t.typedBufferStride;e*=s;for(let n=0;n<i;++n)r[e]=0,r[e+1]=0,r[e+2]=0,r[e+3]=0,e+=s}function hf(t,e,i,r,s=1){if(!e)return void Hs(t,i,r,s);const{data:n,indices:a}=t,l=i.typedBuffer,o=i.typedBufferStride,c=a.length,u=e[0],d=e[1],m=e[2],v=e[4],p=e[5],_=e[6],b=e[8],y=e[9],M=e[10],w=e[12],S=e[13],I=e[14];r*=o;let P=0,F=0,$=0;const C=Fa(e)?O=>{P=n[O]+w,F=n[O+1]+S,$=n[O+2]+I}:O=>{const T=n[O],E=n[O+1],R=n[O+2];P=u*T+v*E+b*R+w,F=d*T+p*E+y*R+S,$=m*T+_*E+M*R+I};if(s===1)for(let O=0;O<c;++O)C(3*a[O]),l[r]=P,l[r+1]=F,l[r+2]=$,r+=o;else for(let O=0;O<c;++O){C(3*a[O]);for(let T=0;T<s;++T)l[r]=P,l[r+1]=F,l[r+2]=$,r+=o}}function df(t,e,i,r,s=1){if(!e)return void Hs(t,i,r,s);const{data:n,indices:a}=t,l=e,o=i.typedBuffer,c=i.typedBufferStride,u=a.length,d=l[0],m=l[1],v=l[2],p=l[4],_=l[5],b=l[6],y=l[8],M=l[9],w=l[10],S=!Ra(l),I=1e-6,P=1-I;r*=c;let F=0,$=0,C=0;const O=Fa(l)?T=>{F=n[T],$=n[T+1],C=n[T+2]}:T=>{const E=n[T],R=n[T+1],D=n[T+2];F=d*E+p*R+y*D,$=m*E+_*R+M*D,C=v*E+b*R+w*D};if(s===1)if(S)for(let T=0;T<u;++T){O(3*a[T]);const E=F*F+$*$+C*C;if(E<P&&E>I){const R=1/Math.sqrt(E);o[r]=F*R,o[r+1]=$*R,o[r+2]=C*R}else o[r]=F,o[r+1]=$,o[r+2]=C;r+=c}else for(let T=0;T<u;++T)O(3*a[T]),o[r]=F,o[r+1]=$,o[r+2]=C,r+=c;else for(let T=0;T<u;++T){if(O(3*a[T]),S){const E=F*F+$*$+C*C;if(E<P&&E>I){const R=1/Math.sqrt(E);F*=R,$*=R,C*=R}}for(let E=0;E<s;++E)o[r]=F,o[r+1]=$,o[r+2]=C,r+=c}}function ff(t,e,i,r,s=1){if(!e)return void Eo(t,i,r,s);const{data:n,indices:a}=t,l=e,o=i.typedBuffer,c=i.typedBufferStride,u=a.length,d=l[0],m=l[1],v=l[2],p=l[4],_=l[5],b=l[6],y=l[8],M=l[9],w=l[10],S=!Ra(l),I=1e-6,P=1-I;if(r*=c,s===1)for(let F=0;F<u;++F){const $=4*a[F],C=n[$],O=n[$+1],T=n[$+2],E=n[$+3];let R=d*C+p*O+y*T,D=m*C+_*O+M*T,N=v*C+b*O+w*T;if(S){const V=R*R+D*D+N*N;if(V<P&&V>I){const j=1/Math.sqrt(V);R*=j,D*=j,N*=j}}o[r]=R,o[r+1]=D,o[r+2]=N,o[r+3]=E,r+=c}else for(let F=0;F<u;++F){const $=4*a[F],C=n[$],O=n[$+1],T=n[$+2],E=n[$+3];let R=d*C+p*O+y*T,D=m*C+_*O+M*T,N=v*C+b*O+w*T;if(S){const V=R*R+D*D+N*N;if(V<P&&V>I){const j=1/Math.sqrt(V);R*=j,D*=j,N*=j}}for(let V=0;V<s;++V)o[r]=R,o[r+1]=D,o[r+2]=N,o[r+3]=E,r+=c}}function pf(t,e,i,r,s=1){const{data:n,indices:a}=t,l=i.typedBuffer,o=i.typedBufferStride,c=a.length;if(r*=o,e===n.length&&e===4){l[r]=n[0],l[r+1]=n[1],l[r+2]=n[2],l[r+3]=n[3];const u=new Uint32Array(i.typedBuffer.buffer,i.start),d=o/4,m=u[r/=4];r+=d;const v=c*s;for(let p=1;p<v;++p)u[r]=m,r+=d;return}if(s!==1)if(e!==4)for(let u=0;u<c;++u){const d=3*a[u];for(let m=0;m<s;++m)l[r]=n[d],l[r+1]=n[d+1],l[r+2]=n[d+2],l[r+3]=255,r+=o}else for(let u=0;u<c;++u){const d=4*a[u];for(let m=0;m<s;++m)l[r]=n[d],l[r+1]=n[d+1],l[r+2]=n[d+2],l[r+3]=n[d+3],r+=o}else{if(e===4){for(let u=0;u<c;++u){const d=4*a[u];l[r]=n[d],l[r+1]=n[d+1],l[r+2]=n[d+2],l[r+3]=n[d+3],r+=o}return}for(let u=0;u<c;++u){const d=3*a[u];l[r]=n[d],l[r+1]=n[d+1],l[r+2]=n[d+2],l[r+3]=255,r+=o}}}function mf(t,e,i){const{data:r,indices:s}=t,n=e.typedBuffer,a=e.typedBufferStride,l=s.length,o=r[0];i*=a;for(let c=0;c<l;++c)n[i]=o,i+=a}function Y0(t,e,i,r){ce(It,t,e);const s=Math.max(Math.sqrt(te(It)),1e-4);q(It,It,1/s),i[r++]=It[0],i[r++]=It[1],i[r++]=It[2],i[r++]=s}const It=g();function gf(t,e,i,r,s=1){const n=e.typedBuffer,a=e.typedBufferStride;if(r*=a,s===1)for(let l=0;l<i;++l)n[r]=t[0],n[r+1]=t[1],n[r+2]=t[2],n[r+3]=t[3],r+=a;else for(let l=0;l<i;++l)for(let o=0;o<s;++o)n[r]=t[0],n[r+1]=t[1],n[r+2]=t[2],n[r+3]=t[3],r+=a}function vf(t,e,i,r,s,n,a){let l={numItems:0,numVerticesPerItem:0};for(const o of i.fields.keys()){const c=t.get(o),u=c?.indices;if(c&&u)o==="position"&&(l={numItems:1,numVerticesPerItem:u.length}),_f(o,c,r,s,n,a);else if(o==="olidColor"&&e!=null){const d=t.get("position")?.indices;if(d){const m=d.length;gf(e,n.getField(o,ri),m,a)}}}return l}function _f(t,e,i,r,s,n){switch(t){case"position":{W(e.size===3);const a=s.getField(t,er);W(!!a,`No buffer view for ${t}`),hf(e,i,a,n);break}case"normal":{W(e.size===3);const a=s.getField(t,er);W(!!a,`No buffer view for ${t}`),df(e,r,a,n);break}case"normalCompressed":case"profileRight":case"profileUp":{W(e.size===2);const a=s.getField(t,un);W(!!a,`No buffer view for ${t}`),is(e,a,n);break}case"uv0":{W(e.size===2);const a=s.getField(t,Kl)??s.getField(t,Jl);W(!!a,`No buffer view for ${t}`),is(e,a,n);break}case"uvi":{W(e.size===2);const a=s.getField(t,un);W(!!a,`No buffer view for ${t}`),is(e,a,n);break}case"color":case"symbolColor":{const a=s.getField(t,ri);W(!!a,`No buffer view for ${t}`),W(e.size===3||e.size===4),pf(e,e.size,a,n);break}case"colorFeatureAttribute":case"opacityFeatureAttribute":case"sizeFeatureAttribute":{const a=s.getField(t,cn)??s.getField(t,cn);W(!!a,`No buffer view for ${t}`),W(e.size===1),mf(e,a,n);break}case"tangent":{W(e.size===4);const a=s.getField(t,hr);W(!!a,`No buffer view for ${t}`),ff(e,i,a,n);break}case"profileVertexAndNormal":{W(e.size===4);const a=s.getField(t,Zl)??s.getField(t,hr);W(!!a,`No buffer view for ${t}`),Eo(e,a,n);break}case"profileAuxData":{W(e.size===3);const a=s.getField(t,Yl)??s.getField(t,er);W(!!a,`No buffer view for ${t}`),Hs(e,a,n);break}}}let Z0=class extends Ve{constructor(e){super(),this.slicePlaneLocalOrigin=e}};function J0(t,e){Ao(t,e,new ue("slicePlaneOrigin",(i,r)=>js(e,i,r)),new ue("slicePlaneBasis1",(i,r)=>ni(e,i,r,r.slicePlane?.basis1)),new ue("slicePlaneBasis2",(i,r)=>ni(e,i,r,r.slicePlane?.basis2)))}function Zt(t,e){Ao(t,e,new ze("slicePlaneOrigin",(i,r)=>js(e,i,r)),new ze("slicePlaneBasis1",(i,r)=>ni(e,i,r,r.slicePlane?.basis1)),new ze("slicePlaneBasis2",(i,r)=>ni(e,i,r,r.slicePlane?.basis2)))}function Q0(t,e){Io(t,e,new ze("slicePlaneOrigin",(i,r)=>js(e,i,r)),new ze("slicePlaneBasis1",(i,r)=>ni(e,i,r,r.slicePlane?.basis1)),new ze("slicePlaneBasis2",(i,r)=>ni(e,i,r,r.slicePlane?.basis2)))}const xf=h`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
bool rejectBySlice(vec3 pos) {
return sliceByPlane(pos);
}`;function Io(t,e,...i){e.hasSlicePlane?(t.uniforms.add(...i),t.code.add(xf)):t.code.add("bool rejectBySlice(vec3 pos) { return false; }")}function Ao(t,e,...i){Io(t,e,...i),e.hasSlicePlane?t.code.add(`
    void discardBySlice(vec3 pos) {
      if (sliceByPlane(pos)) {
        discard;
      }
    }

    vec4 applySliceOutline(vec4 color, vec3 pos) {
      SliceFactors factors = calculateSliceFactors(pos);

      factors.front /= 2.0 * fwidth(factors.front);
      factors.side0 /= 2.0 * fwidth(factors.side0);
      factors.side1 /= 2.0 * fwidth(factors.side1);
      factors.side2 /= 2.0 * fwidth(factors.side2);
      factors.side3 /= 2.0 * fwidth(factors.side3);

      // return after calling fwidth, to avoid aliasing caused by discontinuities in the input to fwidth
      if (sliceByFactors(factors)) {
        return color;
      }

      float outlineFactor = (1.0 - step(0.5, factors.front))
        * (1.0 - step(0.5, factors.side0))
        * (1.0 - step(0.5, factors.side1))
        * (1.0 - step(0.5, factors.side2))
        * (1.0 - step(0.5, factors.side3));

      return mix(color, vec4(vec3(0.0), color.a), outlineFactor * 0.3);
    }

    vec4 applySlice(vec4 color, vec3 pos) {
      return sliceEnabled() ? applySliceOutline(color, pos) : color;
    }
  `):t.code.add(h`void discardBySlice(vec3 pos) { }
vec4 applySlice(vec4 color, vec3 pos) { return color; }`)}function Fo(t,e,i){return t.instancedDoublePrecision?U(bf,i.camera.viewInverseTransposeMatrix[3],i.camera.viewInverseTransposeMatrix[7],i.camera.viewInverseTransposeMatrix[11]):e.slicePlaneLocalOrigin}function Ro(t,e){return t!=null?ce(xr,e.origin,t):e.origin}function Oo(t,e,i){return t.hasSliceTranslatedView?e!=null?gr(yf,i.camera.viewMatrix,e):i.camera.viewMatrix:null}function js(t,e,i){if(i.slicePlane==null)return ot;const r=Fo(t,e,i),s=Ro(r,i.slicePlane),n=Oo(t,r,i);return n!=null?Fe(xr,s,n):s}function ni(t,e,i,r){if(r==null||i.slicePlane==null)return ot;const s=Fo(t,e,i),n=Ro(s,i.slicePlane),a=Oo(t,s,i);return a!=null?(pe(pi,r,n),Fe(xr,n,a),Fe(pi,pi,a),ce(pi,pi,xr)):r}const bf=g(),xr=g(),pi=g(),yf=ne();function wf(t,e){if(e.output!==10)return t.vertex.code.add(h`void forwardObjectAndLayerIdColor() {}`),void t.fragment.code.add(h`void outputObjectAndLayerIdColor() {}`);const i=e.instanced;t.varyings.add("objectAndLayerIdColorVarying","vec4");const r=i?"instanceOlidColor":"olidColor";t.attributes.add(r,"vec4"),t.vertex.code.add(h`
    void forwardObjectAndLayerIdColor() {
      objectAndLayerIdColorVarying = ${r} * 0.003921568627451;
    }`),t.fragment.code.add(h`void outputObjectAndLayerIdColor() {
fragColor = objectAndLayerIdColorVarying;
}`)}let Tf=class extends ie{constructor(e,i){super(e,"bool",0,(r,s)=>r.setUniform1b(e,i(s)))}},Dr=class extends ie{constructor(e,i,r){super(e,"vec2",0,(s,n)=>s.setUniform2fv(e,i(n),r))}};function Gs(t){t.uniforms.add(new Dr("zProjectionMap",e=>Mf(e.camera))),t.code.add(h`float linearizeDepth(float depth) {
float depthNdc = depth * 2.0 - 1.0;
float c1 = zProjectionMap[0];
float c2 = zProjectionMap[1];
return -(c1 / (depthNdc + c2 + 1e-7));
}`),t.code.add(h`float delinearizeDepth(float linearDepth) {
float c1 = zProjectionMap[0];
float c2 = zProjectionMap[1];
float depthNdc = (-c1/linearDepth) - c2 - 1e-7;
float depthNonlinear01 = (depthNdc + 1.0 ) / 2.0;
return depthNonlinear01;
}`),t.code.add(h`float depthFromTexture(sampler2D depthTexture, vec2 uv) {
ivec2 iuv = ivec2(uv * vec2(textureSize(depthTexture, 0)));
float depth = texelFetch(depthTexture, iuv, 0).r;
return depth;
}`),t.code.add(h`float linearDepthFromTexture(sampler2D depthTexture, vec2 uv) {
return linearizeDepth(depthFromTexture(depthTexture, uv));
}`)}function Mf(t){const e=t.projectionMatrix;return Pt(Sf,e[14],e[10])}const Sf=Pi();let Us=class extends ie{constructor(e,i){super(e,"sampler2D",0,(r,s)=>r.bindTexture(e,i(s)))}};function Po(t,{occlusionPass:e,terrainDepthTest:i,cullAboveTerrain:r}){const{vertex:s,fragment:n,varyings:a}=t;if(!i)return s.code.add("void forwardViewPosDepth(vec3 pos) {}"),void n.code.add(`${e?"bool":"void"} discardByTerrainDepth() { ${G(e,"return false;")}}`);a.add("viewPosDepth","float",{invariant:!0}),s.code.add(`void forwardViewPosDepth(vec3 pos) {
    viewPosDepth = pos.z;
  }`),n.include(Gs),n.uniforms.add(new Us("terrainDepthTexture",l=>l.terrainDepth?.attachment)).code.add(h`
    ${e?"bool":"void"} discardByTerrainDepth() {
      float depth = texelFetch(terrainDepthTexture, ivec2(gl_FragCoord.xy), 0).r;
      float linearDepth = linearizeDepth(depth);
      ${e?"return viewPosDepth < linearDepth && depth < 1.0;":`if(viewPosDepth ${r?">":"<="} linearDepth) discard;`}
    }`)}function $f(t){const{fragment:e}=t;e.code.add(h`uint readChannelBits(uint channel, int highlightLevel) {
int llc = (highlightLevel & 3) << 1;
return (channel >> llc) & 3u;
}
uint readChannel(uvec2 texel, int highlightLevel) {
int lic = (highlightLevel >> 2) & 1;
return texel[lic];
}
uint readLevelBits(uvec2 texel, int highlightLevel) {
return readChannelBits(readChannel(texel, highlightLevel), highlightLevel);
}`)}let Cf=class extends ie{constructor(e,i){super(e,"ivec2",0,(r,s)=>r.setUniform2iv(e,i(s)))}},Do=class extends ie{constructor(e,i){super(e,"int",0,(r,s)=>r.setUniform1i(e,i(s)))}},Ef=class extends ie{constructor(e,i){super(e,"usampler2D",0,(r,s)=>r.bindTexture(e,i(s)))}};function zo(t,e){const{fragment:i}=t,{output:r,draped:s,hasHighlightMixTexture:n}=e;r===9?(i.uniforms.add(new Do("highlightLevel",a=>a.highlightLevel??0),new Cf("highlightMixOrigin",a=>a.highlightMixOrigin)),t.outputs.add("fragHighlight","uvec2",0),t.include($f),n?i.uniforms.add(new Ef("highlightMixTexture",a=>a.highlightMixTexture)).code.add(h`uvec2 getAccumulatedHighlight() {
return texelFetch(highlightMixTexture, ivec2(gl_FragCoord.xy) - highlightMixOrigin, 0).rg;
}
void outputHighlight(bool occluded) {
if (highlightLevel == 0) {
uint bits = occluded ? 3u : 1u;
fragHighlight = uvec2(bits, 0);
} else {
int ll = (highlightLevel & 3) << 1;
int li = (highlightLevel >> 2) & 3;
uint bits;
if (occluded) {
bits = 3u << ll;
} else {
bits = 1u << ll;
}
uvec2 combinedHighlight = getAccumulatedHighlight();
combinedHighlight[li] |= bits;
fragHighlight = combinedHighlight;
}
}`):i.code.add(h`void outputHighlight(bool occluded) {
uint bits = occluded ? 3u : 1u;
fragHighlight = uvec2(bits, 0);
}`),s?i.code.add(h`bool isHighlightOccluded() {
return false;
}`):i.uniforms.add(new Us("depthTexture",a=>a.mainDepth)).code.add(h`bool isHighlightOccluded() {
float sceneDepth = texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x;
return gl_FragCoord.z > sceneDepth + 5e-7;
}`),i.code.add(h`void calculateOcclusionAndOutputHighlight() {
outputHighlight(isHighlightOccluded());
}`)):i.code.add(h`void calculateOcclusionAndOutputHighlight() {}`)}function Tt(t){t.code.add(h`struct MaskedColor {
vec4 color;
bvec4 mask;
};`)}function No(t){t.include(Tt),t.code.add(h`
    MaskedColor createMaskedFromUInt8NaNColor(vec4 color) {
      return MaskedColor(color * ${h.float(1/254)}, equal(color, vec4(255)));
    }
  `)}function Ws(t){t.include(Tt),t.code.add(h`vec4 maskedColorSelectOrOne(MaskedColor color) {
return vec4(
color.mask.r ? 1.0 : color.color.r,
color.mask.g ? 1.0 : color.color.g,
color.mask.b ? 1.0 : color.color.b,
color.mask.a ? 1.0 : color.color.a
);
}
MaskedColor multiplyMaskedColors(MaskedColor color1, MaskedColor color2) {
vec4 masked1 = maskedColorSelectOrOne(color1);
vec4 masked2 = maskedColorSelectOrOne(color2);
return MaskedColor(masked1 * masked2, bvec4(ivec4(color1.mask) & ivec4(color2.mask)));
}`)}function ks(t){t.include(Tt),t.code.add(h`MaskedColor createMaskedFromNaNColor(vec4 color) {
return MaskedColor(color, isnan(color));
}`)}let If=class extends ie{constructor(e,i,r,s){super(e,"vec4",1,(n,a,l)=>n.setUniform4fv(e,i(a,l),s),r)}},Af=class extends ie{constructor(e,i,r,s){super(e,"float",1,(n,a,l)=>n.setUniform1fv(e,i(a,l),s),r)}},l_=class extends To{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1}};const rs=8;function Mi(t,e){const{vertex:i,attributes:r}=t;e.hasVVInstancing&&(e.hasVVSize||e.hasVVColor)&&r.add("instanceFeatureAttribute","vec4"),e.hasVVSize?(i.uniforms.add(new ue("vvSizeMinSize",s=>s.vvSize.minSize)),i.uniforms.add(new ue("vvSizeMaxSize",s=>s.vvSize.maxSize)),i.uniforms.add(new ue("vvSizeOffset",s=>s.vvSize.offset)),i.uniforms.add(new ue("vvSizeFactor",s=>s.vvSize.factor)),i.uniforms.add(new ue("vvSizeFallback",s=>s.vvSize.fallback)),i.uniforms.add(new Ye("vvSymbolRotationMatrix",s=>s.vvSymbolRotationMatrix)),i.uniforms.add(new ue("vvSymbolAnchor",s=>s.vvSymbolAnchor)),i.code.add(h`vec3 vvScale(vec4 _featureAttribute) {
if (isnan(_featureAttribute.x)) {
return vvSizeFallback;
}
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`),i.code.add(h`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 scale = max(vvScale(_featureAttribute), eps);
        return vec4(vvSymbolRotationMatrix * _normal / scale, 1.0);
      }

      ${e.hasVVInstancing?h`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }`:""}
    `)):i.code.add(h`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`),t.vertex.include(Tt),e.hasVVColor?(i.constants.add("vvColorNumber","int",rs),i.uniforms.add(new Af("vvColorValues",s=>s.vvColor.values,rs),new If("vvColorColors",s=>s.vvColor.colors,rs),new Pr("vvColorFallback",s=>s.vvColor.fallback,{supportsNaN:!0})),e.hasVVInstancing&&(t.vertex.include(Ws),t.vertex.include(ks)),i.code.add(h`
      vec4 interpolateVVColor(float value) {
        if (isnan(value)) {
          return vvColorFallback;
        }

        if (value <= vvColorValues[0]) {
          return vvColorColors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (vvColorValues[i] >= value) {
            float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
            return mix(vvColorColors[i-1], vvColorColors[i], f);
          }
        }
        return vvColorColors[vvColorNumber - 1];
      }

      vec4 vvGetColor(vec4 featureAttribute) {
        return interpolateVVColor(featureAttribute.y);
      }

      ${e.hasVVInstancing?h`
            vec4 vvColor() {
              return vvGetColor(instanceFeatureAttribute);
            }

            MaskedColor applyVVColor(MaskedColor color) {
              return multiplyMaskedColors(color, createMaskedFromNaNColor(vvColor()));
            }
            `:h`
            vec4 vvColor() {
              return vec4(1.0);
            }

            MaskedColor applyVVColor(MaskedColor color) {
              return color;
            }
            `}
    `)):i.code.add(h`vec4 vvColor() {
return vec4(1.0);
}
MaskedColor applyVVColor(MaskedColor color) {
return color;
}`)}function Lo(t){t.code.add(h`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)}const oi=1/255.5,Ff=zs(1,0,1,771);function Rf(t,e=!1){switch(t){case 0:return e?no:Wh;case 1:return Ff;case 2:case 3:return null}}function Of(t){if(t.draped)return null;switch(t.oitPass){case 0:case 2:return t.writeDepth?Yh:null;case 1:case 3:return null}}const Pf=5e5,Df={factor:-1,units:-2};function zf({oitPass:t,enableOffset:e}){return e&&t===1?Df:null}function Nf(t,e=513){return t===0||t===2?e:515}function Lf(t,e){const i=Sa(e);return t===1?i?{buffers:[Gr,Ur,Mc]}:{buffers:[Gr,Ur]}:i?{buffers:[Gr,Ur]}:null}function Vf(t){if(t.length<Si)return Array.from(t);if(Array.isArray(t))return Float64Array.from(t);if(!("BYTES_PER_ELEMENT"in t))return Array.from(t);switch(t.BYTES_PER_ELEMENT){case 1:return Uint8Array.from(t);case 2:return Hl(t)?Ql().from(t):ma(t)?Uint16Array.from(t):Int16Array.from(t);case 4:return Float32Array.from(t);default:return Float64Array.from(t)}}let Bf=class Vo{get center(){return ve(this._data[0],this._data[1],this._data[2])}get radius(){return this._data[3]}get bbMin(){return ve(this._data[4],this._data[5],this._data[6])}get bbMax(){return ve(this._data[7],this._data[8],this._data[9])}constructor(e,i,r){this.primitiveIndices=e,this._numIndexPerPrimitive=i,this.position=r,this._data=[.1,0,0,0,0,0,0,0,0,0],this._children=void 0,W(e.length>=1),W(r.size===3||r.size===4);const{data:s,size:n,indices:a}=r;W(a.length%this._numIndexPerPrimitive===0),W(a.length>=e.length*this._numIndexPerPrimitive);const l=e.length;let o=n*a[this._numIndexPerPrimitive*e[0]];At.clear(),At.push(o);const c=ve(s[o],s[o+1],s[o+2]),u=bi(c);for(let p=0;p<l;++p){const _=this._numIndexPerPrimitive*e[p];for(let b=0;b<this._numIndexPerPrimitive;++b){o=n*a[_+b],At.push(o);let y=s[o];c[0]=Math.min(y,c[0]),u[0]=Math.max(y,u[0]),y=s[o+1],c[1]=Math.min(y,c[1]),u[1]=Math.max(y,u[1]),y=s[o+2],c[2]=Math.min(y,c[2]),u[2]=Math.max(y,u[2])}}for(let p=0;p<3;++p)this._data[4+p]=c[p],this._data[7+p]=u[p];const d=lr(g(),this.bbMin,this.bbMax,.5);let m=.5*Math.max(Math.max(u[0]-c[0],u[1]-c[1]),u[2]-c[2]),v=m*m;for(let p=0;p<At.length;++p){o=At.at(p);const _=s[o]-d[0],b=s[o+1]-d[1],y=s[o+2]-d[2],M=_*_+b*b+y*y;if(M<=v)continue;const w=Math.sqrt(M),S=.5*(w-m);m+=S,v=m*m;const I=S/w;d[0]+=_*I,d[1]+=b*I,d[2]+=y*I}this._data[3]=m;for(let p=0;p<3;++p)this._data[0+p]=d[p];At.clear()}getChildren(){if(this._children||Es(this.bbMin,this.bbMax)<=1)return this._children;const e=lr(g(),this.bbMin,this.bbMax,.5),i=this.primitiveIndices.length,r=new Uint8Array(i),s=new Array(8);for(let u=0;u<8;++u)s[u]=0;const{data:n,size:a,indices:l}=this.position;for(let u=0;u<i;++u){let d=0;const m=this._numIndexPerPrimitive*this.primitiveIndices[u];let v=a*l[m],p=n[v],_=n[v+1],b=n[v+2];for(let y=1;y<this._numIndexPerPrimitive;++y){v=a*l[m+y];const M=n[v],w=n[v+1],S=n[v+2];M<p&&(p=M),w<_&&(_=w),S<b&&(b=S)}p<e[0]&&(d|=1),_<e[1]&&(d|=2),b<e[2]&&(d|=4),r[u]=d,++s[d]}let o=0;for(let u=0;u<8;++u)s[u]>0&&++o;if(o<2)return;const c=new Array(8);for(let u=0;u<8;++u)c[u]=s[u]>0?new Uint32Array(s[u]):void 0;for(let u=0;u<8;++u)s[u]=0;for(let u=0;u<i;++u){const d=r[u];c[d][s[d]++]=this.primitiveIndices[u]}this._children=new Array;for(let u=0;u<8;++u)c[u]!==void 0&&this._children.push(new Vo(c[u],this._numIndexPerPrimitive,this.position));return this._children}static prune(){At.prune()}};const At=new jl({deallocator:null});let Hf=class{constructor(e){this.id=Cr(),this._attributes=new Map;for(const[i,r]of e)this._attributes.set(i,{...r,indices:Al(r.indices)})}get attributes(){return this._attributes}};function jf(t){return t?{p0:bi(t.p0),p1:bi(t.p1),p2:bi(t.p2)}:{p0:g(),p1:g(),p2:g()}}function h_(t,e,i){const r=e[0]-t[0],s=e[1]-t[1],n=i[0]-t[0],a=i[1]-t[1];return .5*Math.abs(r*a-s*n)}function Gf(t,e,i){return ce(ss,e,t),ce(Zn,i,t),.5*te(Ae(ss,ss,Zn))}new ya(Ma);new ya(()=>jf());const ss=g(),Zn=g();function Uf(t,e){if(!t)return!1;const{size:i,data:r,indices:s}=t;U(e,0,0,0),U(Ie,0,0,0);let n=0,a=0;for(let l=0;l<s.length-2;l+=3){const o=s[l]*i,c=s[l+1]*i,u=s[l+2]*i;U(le,r[o],r[o+1],r[o+2]),U(st,r[c],r[c+1],r[c+2]),U(Xi,r[u],r[u+1],r[u+2]);const d=Gf(le,st,Xi);d?(pe(le,le,st),pe(le,le,Xi),q(le,le,1/3*d),pe(e,e,le),n+=d):(pe(Ie,Ie,le),pe(Ie,Ie,st),pe(Ie,Ie,Xi),a+=3)}return(a!==0||n!==0)&&(n!==0?(q(e,e,1/n),!0):a!==0&&(q(e,Ie,1/a),!0))}function Wf(t,e){if(!t)return!1;const{size:i,data:r,indices:s}=t;U(e,0,0,0);let n=-1,a=0;for(let l=0;l<s.length;l++){const o=s[l]*i;n!==o&&(e[0]+=r[o],e[1]+=r[o+1],e[2]+=r[o+2],a++),n=o}return a>1&&q(e,e,1/a),a>0}function kf(t,e,i){if(!t)return!1;U(i,0,0,0),U(Ie,0,0,0);let r=0,s=0;const{size:n,data:a,indices:l}=t,o=l.length-1,c=o+(e?2:0);for(let u=0;u<c;u+=2){const d=u<o?u+1:0,m=l[u<o?u:o]*n,v=l[d]*n;le[0]=a[m],le[1]=a[m+1],le[2]=a[m+2],st[0]=a[v],st[1]=a[v+1],st[2]=a[v+2],q(le,pe(le,le,st),.5);const p=El(le,st);p>0?(pe(i,i,q(le,le,p)),r+=p):r===0&&(pe(Ie,Ie,le),s++)}return r!==0?(q(i,i,1/r),!0):s!==0&&(q(i,Ie,1/s),!0)}const le=g(),st=g(),Xi=g(),Ie=g();let Bo=class{constructor(){this.uid=Cr()}},qf=class extends Bo{constructor(e){super(),this.highlightName=e,this.channel=0}},p_=class extends Bo{constructor(){super(...arguments),this.channel=1}},g_=class Ho extends Hf{constructor(e,i,r=null,s=0,n=null,a=-1,l){super(i),this.material=e,this.mapPositions=r,this.type=s,this.olidColor=n,this.edgeIndicesLength=a,this.baseGeometry=l,this._highlights=null,this._highlightOptionsCounts=null,this.visible=!0,this._boundingInfo=null;const o=this.positionAttribute;o!=null&&this.edgeIndicesLength<0&&(this.edgeIndicesLength=o.indices.length)}instantiate(e={}){const i=new Ho(e.material||this.material,[],this.mapPositions,this.type,this.olidColor,this.edgeIndicesLength,this.baseGeometry);return this._attributes.forEach((r,s)=>{r.exclusive=!1,i._attributes.set(s,r)}),i._boundingInfo=this._boundingInfo,i.transformation=e.transformation||this.transformation,i}getMutableAttribute(e){let i=this._attributes.get(e);return i&&!i.exclusive&&(i={...i,exclusive:!0,data:Vf(i.data)},this._attributes.set(e,i)),i}setAttributeData(e,i){const r=this._attributes.get(e);r?this._attributes.set(e,{...r,exclusive:!0,data:i}):Ii()&&console.warn(`Setting undefined attribute ${e} data`)}get positionAttribute(){return this.attributes.get("position")??this.baseGeometry?.attributes.get("position")}get indexCount(){return this._attributes.values().next().value?.indices?.length??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return this._boundingInfo??=this._calculateBoundingInfo(),this._boundingInfo}computeAttachmentOrigin(e){return!!(this.type===0?this._computeAttachmentOriginTriangles(e):this.type===2?this._computeAttachmentOriginLines(e):this._computeAttachmentOriginPoints(e))&&(this._transformation!=null&&Fe(e,e,this._transformation),!0)}_computeAttachmentOriginTriangles(e){const i=this.positionAttribute;return Uf(i,e)}_computeAttachmentOriginLines(e){const i=this.positionAttribute;return kf(i,Xf(this.material.parameters,i),e)}_computeAttachmentOriginPoints(e){const i=this.positionAttribute;return Wf(i,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.positionAttribute;if(!e||e.indices.length===0)return null;const i=this.type===0?3:1;W(e.indices.length%i===0,"Indexing error: "+e.indices.length+" not divisible by "+i);const r=Fl(e.indices.length/i);return new Bf(r,i,e)}get transformation(){return this._transformation??or}set transformation(e){this._transformation=e&&e!==or?Cl(e):null}get highlights(){return this._highlights||Yf}get hasHighlights(){return(this._highlightOptionsCounts?.size??0)>0}foreachHighlightOptions(e){this._highlightOptionsCounts?.forEach((i,r)=>e(r))}allocateIdAndHighlight(e){const i=new qf(e);return this.addHighlight(i)}addHighlight(e){this._ensureHighlights().add(e);const{highlightName:i}=e,r=(this._highlightOptionsCounts?.get(i)??0)+1;return this._ensureHighlightOptionsCounts().set(i,r),e}_ensureHighlights(){let e=this._highlights;return e||(e=new Set,this._highlights=e),e}_ensureHighlightOptionsCounts(){let e=this._highlightOptionsCounts;return e||(e=new Map,this._highlightOptionsCounts=e),e}removeHighlight(e){if(this._highlights?.delete(e)){const{highlightName:i}=e,r=this._highlightOptionsCounts?.get(i)??0;r<=1?this._highlightOptionsCounts?.delete(i):this._ensureHighlightOptionsCounts().set(i,r-1)}}};function Xf(t,e){return!(!("isClosed"in t)||!t.isClosed)&&e.indices.length>2}const Yf=new Set;function v_(t,e=!1){return t<=Si?e?new Array(t).fill(0):new Array(t):new Float32Array(t)}function __(t){return Array.isArray(t)?t.length<Si?t:new Float32Array(t):t.length<Si?Array.from(t):t}function x_(t){return(Array.isArray(t)?t.length:t.byteLength/8)<=Si?Array.from(t):new Float32Array(t)}function b_(t,e,i){return Array.isArray(t)?t.slice(e,e+i):t.subarray(e,e+i)}let Zf=class{constructor(e=0,i=!1,r=!0){this.tolerance=e,this.isVerticalRay=i,this.normalRequired=r}};const Yi=Cc();function Kf(t,e,i,r,s,n){if(!t.visible)return;const a=Xe(Uo,r,i),l=(u,d,m)=>n(u,m,d),{tolerance:o}=e,c=new Zf(o,!1,e.options.normalRequired);if(t.boundingInfo)W(t.type===0),jo(t.boundingInfo,i,a,o,s,c,l);else{const u=t.positionAttribute,d=u.indices;Go(i,a,0,d.length/3,d,u.data,u.stride,s,c,l)}}const Jf=g();function jo(t,e,i,r,s,n,a){if(t==null)return;const l=ap(i,Jf);if($c(Yi,t.bbMin),Ec(Yi,t.bbMax),s?.applyToAabb(Yi),op(Yi,e,l,r)){const{primitiveIndices:o,position:c}=t,u=o?o.length:c.indices.length/3;if(u>cp){const d=t.getChildren();if(d!==void 0){for(const m of d)jo(m,e,i,r,s,n,a);return}}tp(e,i,0,u,c.indices,c.data,c.stride,o,s,n,a)}}const vt=g();function w_(t,e,i,r,s,n,a,l,o){const{data:c,stride:u}=n;Go(t,Xe(Uo,e,t),i,r,s,c,u,a,l,o)}function T_(t,e,i,r){if(!i.visible)return;const s=(o,c,u)=>r(o,u,c),{boundingInfo:n}=i;if(n){const{bbMin:o,bbMax:c}=n;if(t<o[0]||t>c[0]||e<o[1]||e>c[1])return}const a=i.positionAttribute,l=a.indices;Qf(t,e,0,l.length/3,l,a,s)}function Qf(t,e,i,r,s,n,a){const{data:l,stride:o}=n;for(let c=i;c<r;++c){const u=3*c,d=o*s[u],m=o*s[u+1],v=o*s[u+2],p=l[d+0]-t,_=l[d+1]-e,b=l[m+0]-t,y=l[m+1]-e,M=l[v+0]-t,w=l[v+1]-e,S=M*y-w*b,I=p*w-_*M,P=b*_-y*p;(S<0||I<0||P<0)&&(S>0||I>0||P>0)||a(0,c,null)}}function M_(t,e,i,r,s,n,a,l,o,c=null,u=0){const d=t[0],m=t[1],v=t[2],p=e[0],_=e[1],b=e[2];for(let y=i;y<r;++y){const M=u+(c?c[y]:y),w=3*M,S=a*s[w],I=n[S],P=n[S+1],F=n[S+2],$=a*s[w+1],C=n[$],O=n[$+1],T=n[$+2],E=a*s[w+2],R=C-I,D=O-P,N=T-F,V=n[E]-I,j=n[E+1]-P,X=n[E+2]-F,oe=_*X-j*b,he=b*V-X*p,se=p*j-V*_,K=R*oe+D*he+N*se;if(Math.abs(K)<=Nr)continue;const de=d-I,fe=m-P,me=v-F,ee=de*oe+fe*he+me*se;if(K>0){if(ee<0||ee>K)continue}else if(ee>0||ee<K)continue;const Re=fe*N-D*me,Be=me*R-N*de,He=de*D-R*fe,xe=p*Re+_*Be+b*He;if(K>0){if(xe<0||ee+xe>K)continue}else if(xe>0||ee+xe<K)continue;const je=(V*Re+j*Be+X*He)/K;je>=0&&o(je,M,l?zr(R,D,N,V,j,X,vt):null)}}function ep(t,e,i,r,s,n,a,l){const o=t[0],c=t[1],u=t[2],d=e[0],m=e[1],v=e[2];for(let p=i;p<r;++p){const _=3*p,b=_+1,y=_+2,M=n*_,w=s[M],S=s[M+1],I=s[M+2],P=n*b,F=n*y,$=s[P]-w,C=s[P+1]-S,O=s[P+2]-I,T=s[F]-w,E=s[F+1]-S,R=s[F+2]-I,D=m*R-E*v,N=v*T-R*d,V=d*E-T*m,j=$*D+C*N+O*V;if(Math.abs(j)<=Nr)continue;const X=o-w,oe=c-S,he=u-I,se=X*D+oe*N+he*V;if(j>0){if(se<0||se>j)continue}else if(se>0||se<j)continue;const K=oe*O-C*he,de=he*$-O*X,fe=X*C-$*oe,me=d*K+m*de+v*fe;if(j>0){if(me<0||se+me>j)continue}else if(me>0||se+me<j)continue;const ee=(T*K+E*de+R*fe)/j;ee>=0&&l(ee,p,a?zr($,C,O,T,E,R,vt):null)}}function S_(t,e,i,r,s,n,a,l,o,c,u,d=null,m=0){const v=t[0],p=t[1],_=t[2],b=e[0],y=e[1],M=e[2];for(let w=i;w<r;++w){const S=m+(d?d[w]:w),I=3*S,P=a*s[I],F=n[P],$=n[P+1],C=n[P+2],O=a*s[I+1],T=n[O],E=n[O+1],R=n[O+2],D=a*s[I+2],N=n[D],V=n[D+1],j=n[D+2],X=C-o,oe=l/Math.sqrt(F*F+$*$+X*X),he=F+F*oe,se=$+$*oe,K=C+X*oe,de=R-o,fe=l/Math.sqrt(T*T+E*E+de*de),me=T+T*fe,ee=E+E*fe,Re=R+de*fe,Be=j-o,He=l/Math.sqrt(N*N+V*V+Be*Be),xe=me-he,je=ee-se,Mt=Re-K,St=N+N*He-he,Je=V+V*He-se,$t=j+Be*He-K,en=y*$t-Je*M,tn=M*St-$t*b,rn=b*Je-St*y,ct=xe*en+je*tn+Mt*rn;if(Math.abs(ct)<=Nr)continue;const Vr=v-he,Br=p-se,Hr=_-K,Nt=Vr*en+Br*tn+Hr*rn;if(ct>0){if(Nt<0||Nt>ct)continue}else if(Nt>0||Nt<ct)continue;const sn=Br*Mt-je*Hr,nn=Hr*xe-Mt*Vr,an=Vr*je-xe*Br,zi=b*sn+y*nn+M*an;if(ct>0){if(zi<0||Nt+zi>ct)continue}else if(zi>0||Nt+zi<ct)continue;const on=(St*sn+Je*nn+$t*an)/ct;on>=0&&u(on,S,c?zr(xe,je,Mt,St,Je,$t,vt):null)}}function tp(t,e,i,r,s,n,a,l,o,c,u){const d=t[0],m=t[1],v=t[2],p=e[0],_=e[1],b=e[2],{normalRequired:y}=c;for(let M=i;M<r;++M){const w=l[M],S=3*w,I=a*s[S];let P=n[I],F=n[I+1],$=n[I+2];const C=a*s[S+1];let O=n[C],T=n[C+1],E=n[C+2];const R=a*s[S+2];let D=n[R],N=n[R+1],V=n[R+2];o!=null&&([P,F,$]=o.applyToVertex(P,F,$,M),[O,T,E]=o.applyToVertex(O,T,E,M),[D,N,V]=o.applyToVertex(D,N,V,M));const j=O-P,X=T-F,oe=E-$,he=D-P,se=N-F,K=V-$,de=_*K-se*b,fe=b*he-K*p,me=p*se-he*_,ee=j*de+X*fe+oe*me;if(Math.abs(ee)<=Nr)continue;const Re=d-P,Be=m-F,He=v-$,xe=Re*de+Be*fe+He*me;if(ee>0){if(xe<0||xe>ee)continue}else if(xe>0||xe<ee)continue;const je=Be*oe-X*He,Mt=He*j-oe*Re,St=Re*X-j*Be,Je=p*je+_*Mt+b*St;if(ee>0){if(Je<0||xe+Je>ee)continue}else if(Je>0||xe+Je<ee)continue;const $t=(he*je+se*Mt+K*St)/ee;$t>=0&&u($t,w,y?zr(j,X,oe,he,se,K,vt):null)}}function Go(t,e,i,r,s,n,a,l,o,c){const u=e,d=up,m=Math.abs(u[0]),v=Math.abs(u[1]),p=Math.abs(u[2]),_=m>=v?m>=p?0:2:v>=p?1:2,b=_,y=u[b]<0?2:1,M=(_+y)%3,w=(_+(3-y))%3,S=u[M]/u[b],I=u[w]/u[b],P=1/u[b],F=ip,$=rp,C=sp,{normalRequired:O}=o;for(let T=i;T<r;++T){const E=3*T,R=a*s[E];U(d[0],n[R+0],n[R+1],n[R+2]);const D=a*s[E+1];U(d[1],n[D+0],n[D+1],n[D+2]);const N=a*s[E+2];U(d[2],n[N+0],n[N+1],n[N+2]),l&&(Z(d[0],l.applyToVertex(d[0][0],d[0][1],d[0][2],T)),Z(d[1],l.applyToVertex(d[1][0],d[1][1],d[1][2],T)),Z(d[2],l.applyToVertex(d[2][0],d[2][1],d[2][2],T))),Xe(F,d[0],t),Xe($,d[1],t),Xe(C,d[2],t);const V=F[M]-S*F[b],j=F[w]-I*F[b],X=$[M]-S*$[b],oe=$[w]-I*$[b],he=C[M]-S*C[b],se=C[w]-I*C[b],K=he*oe-se*X,de=V*se-j*he,fe=X*j-oe*V;if((K<0||de<0||fe<0)&&(K>0||de>0||fe>0))continue;const me=K+de+fe;if(me===0)continue;const ee=K*(P*F[b])+de*(P*$[b])+fe*(P*C[b]);if(ee*Math.sign(me)<0)continue;const Re=ee/me;Re>=0&&c(Re,T,O?np(d):null)}}const ip=g(),rp=g(),sp=g();function zr(t,e,i,r,s,n,a){return U(br,t,e,i),U(yr,r,s,n),Ae(a,br,yr),Te(a,a),a}function np(t){return Xe(br,t[1],t[0]),Xe(yr,t[2],t[0]),Ae(vt,br,yr),Te(vt,vt),vt}const br=g(),yr=g();function $_(t,e,i){return U(i,1/(e[0]-t[0]),1/(e[1]-t[1]),1/(e[2]-t[2]))}function ap(t,e){return U(e,1/t[0],1/t[1],1/t[2])}function op(t,e,i,r){return lp(t,e,i,r,1/0)}function lp(t,e,i,r,s){const n=(t[0]-r-e[0])*i[0],a=(t[3]+r-e[0])*i[0];let l=Math.min(n,a),o=Math.max(n,a);const c=(t[1]-r-e[1])*i[1],u=(t[4]+r-e[1])*i[1];if(o=Math.min(o,Math.max(c,u)),o<0||(l=Math.max(l,Math.min(c,u)),l>o))return!1;const d=(t[2]-r-e[2])*i[2],m=(t[5]+r-e[2])*i[2];return o=Math.min(o,Math.max(d,m)),!(o<0)&&(l=Math.max(l,Math.min(d,m)),!(l>o)&&l<s)}const cp=1e3,Nr=1e-7,Uo=g(),up=[g(),g(),g()];let hp=class{constructor(e){this.layout=e}elementCount(e){return e.get("position").indices.length}write(e,i,r,s,n,a){return vf(r,s,this.layout,e,i,n,a)}intersect(e,i,r,s,n,a,l){const o=this.layout.createView(e).getField("position",er);if(o==null)return;const c=Xe(dp,a,n),u=0,d=o.count/3,m=s.options.normalRequired,v=(p,_,b)=>l(p,b,_);ep(n,c,u,d,o.typedBuffer,o.typedBufferStride,m,v)}};const dp=g();function Lr(t,e){switch(t.fragment.code.add(h`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`),e.normalType){case 1:t.attributes.add("normalCompressed","vec2"),t.vertex.code.add(h`vec3 decompressNormal(vec2 normal) {
float z = 1.0 - abs(normal.x) - abs(normal.y);
return vec3(normal + sign(normal) * min(z, 0.0), z);
}
vec3 normalModel() {
return decompressNormal(normalCompressed);
}`);break;case 0:t.attributes.add("normal","vec3"),t.vertex.code.add(h`vec3 normalModel() {
return normal;
}`);break;default:Is(e.normalType);case 2:case 3:}}function Wo({code:t,uniforms:e},i){e.add(new bt("dpDummy",()=>1)),t.add(h`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 hiD = hiA + hiB;
vec3 loD = loA + loB;
return  dpDummy * hiD + loD;
}`)}let ko=class extends ie{constructor(e,i,r){super(e,"mat3",2,(s,n,a)=>s.setUniformMatrix3fv(e,i(n,a),r))}},qo=class extends ie{constructor(e,i,r){super(e,"mat4",1,(s,n,a)=>s.setUniformMatrix4fv(e,i(n,a),r))}};function fp(t,e){const{attributes:i,vertex:r,varyings:s,fragment:n}=t;r.include(Wo,e),i.add("position","vec3"),s.add("vPositionWorldCameraRelative","vec3"),s.add("vPosition_view","vec3",{invariant:!0}),r.uniforms.add(new ue("transformWorldFromViewTH",a=>a.transformWorldFromViewTH),new ue("transformWorldFromViewTL",a=>a.transformWorldFromViewTL),new Ye("transformViewFromCameraRelativeRS",a=>a.transformViewFromCameraRelativeRS),new qo("transformProjFromView",a=>a.transformProjFromView),new ko("transformWorldFromModelRS",a=>a.transformWorldFromModelRS),new ze("transformWorldFromModelTH",a=>a.transformWorldFromModelTH),new ze("transformWorldFromModelTL",a=>a.transformWorldFromModelTL)),r.code.add(h`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * position;
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`),r.code.add(h`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${e.spherical?h`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)`:h`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `),n.uniforms.add(new ue("transformWorldFromViewTL",a=>a.transformWorldFromViewTL)),r.code.add(h`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`),n.code.add(h`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`)}let pp=class extends Ve{constructor(){super(...arguments),this.transformWorldFromViewTH=g(),this.transformWorldFromViewTL=g(),this.transformViewFromCameraRelativeRS=wt(),this.transformProjFromView=ne()}},mp=class extends Ve{constructor(){super(...arguments),this.transformWorldFromModelRS=wt(),this.transformWorldFromModelTH=g(),this.transformWorldFromModelTL=g()}};function Xo(t,e){switch(e.normalType){case 0:case 1:t.include(Lr,e),t.varyings.add("vNormalWorld","vec3"),t.varyings.add("vNormalView","vec3"),t.vertex.uniforms.add(new ko("transformNormalGlobalFromModel",i=>i.transformNormalGlobalFromModel),new Ye("transformNormalViewFromGlobal",i=>i.transformNormalViewFromGlobal)).code.add(h`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);break;case 2:t.vertex.code.add(h`void forwardNormal() {}`);break;default:Is(e.normalType);case 3:}}let gp=class extends pp{constructor(){super(...arguments),this.transformNormalViewFromGlobal=wt()}},vp=class extends mp{constructor(){super(...arguments),this.transformNormalGlobalFromModel=wt(),this.toMapSpace=at()}};const P_={func:513},D_={func:519},_p={mask:255},z_={mask:0},N_=t=>({function:{func:517,ref:t,mask:t},operation:{fail:7680,zFail:7680,zPass:7680}}),L_=t=>({function:{func:519,ref:t,mask:t},operation:{fail:7680,zFail:7680,zPass:7681}}),xp={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:0}},bp={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7681}},V_={function:{func:514,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}},B_={function:{func:517,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}};let yp=class{constructor(e,i,r){this.elementSize=i.stride,this._buffer=new Od(e,ms(i,1)),this.resize(r)}destroy(){this._buffer.dispose()}get capacity(){return this._capacity}get array(){return this._array}get buffer(){return this._buffer}get usedMemory(){return this._array.byteLength+this._buffer.usedMemory}copyRange(e,i,r,s=0){const n=new Uint8Array(this.array,e*this.elementSize,(i-e)*this.elementSize);new Uint8Array(r.array,s*this.elementSize).set(n)}transferAll(){this._buffer.setData(this._array)}transferRange(e,i){const r=e*this.elementSize,s=i*this.elementSize;this._buffer.setSubData(new Uint8Array(this._array),r,r,s)}resize(e){const i=e*this.elementSize,r=new ArrayBuffer(i);this._array&&(e>=this._capacity?new Uint8Array(r).set(new Uint8Array(this._array)):new Uint8Array(r).set(new Uint8Array(this._array).subarray(0,e*this.elementSize))),this._array=r,this._buffer.setSize(i),this._capacity=e}},Kn=class{constructor(e){this.localTransform=e.localTransform,this.globalTransform=e.globalTransform,this.modelOrigin=e.modelOrigin,this.model=e.instanceModel,this.modelNormal=e.instanceModelNormal,this.modelScaleFactors=e.modelScaleFactors,this.boundingSphere=e.boundingSphere,this.featureAttribute=e.getField("instanceFeatureAttribute",hr),this.color=e.getField("instanceColor",ri),this.olidColor=e.getField("instanceOlidColor",ri),this.state=e.getField("state",hn),this.lodLevel=e.getField("lodLevel",hn)}},mi=class extends Mr{constructor(e,i){super(e),this.events=new Pa,this._capacity=0,this._size=0,this._next=0,this._highlightOptionsMap=new Map,this._highlightOptionsMapPrev=new Map,this._layout=Mp(i),this._capacity=wr,this._buffer=this._layout.createBuffer(this._capacity),this._view=new Kn(this._buffer)}get capacity(){return this._capacity}get size(){return this._size}get view(){return this._view}addInstance(){this._size+1>this._capacity&&this._grow();const e=this._findSlot();return this._view.state.set(e,1),this._size++,this.events.emit("instances-changed"),e}removeInstance(e){const i=this._view.state;W(e>=0&&e<this._capacity&&!!(1&i.get(e)),"invalid instance handle"),this._getStateFlag(e,18)?this._setStateFlags(e,32):this.freeInstance(e),this.events.emit("instances-changed")}freeInstance(e){const i=this._view.state;W(e>=0&&e<this._capacity&&!!(1&i.get(e)),"invalid instance handle"),i.set(e,0),this._size--}setLocalTransform(e,i,r=!0){this._view.localTransform.setMat(e,i),r&&this.updateModelTransform(e)}getLocalTransform(e,i){this._view.localTransform.getMat(e,i)}setGlobalTransform(e,i,r=!0){this._view.globalTransform.setMat(e,i),r&&this.updateModelTransform(e)}getGlobalTransform(e,i){this._view.globalTransform.getMat(e,i)}updateModelTransform(e){const i=this._view,r=Me,s=Oe;i.localTransform.getMat(e,Jn),i.globalTransform.getMat(e,ns);const n=Ei(ns,ns,Jn);U(r,n[12],n[13],n[14]),i.modelOrigin.setVec(e,r),Ia(s,n),i.model.setMat(e,s);const a=tu(Me,n);a.sort(),i.modelScaleFactors.set(e,0,a[1]),i.modelScaleFactors.set(e,1,a[2]),Oc(s,s),Pc(s,s),i.modelNormal.setMat(e,s),this._setStateFlags(e,64),this.events.emit("instance-transform-changed",{index:e})}getModelTransform(e,i){const r=this._view;r.model.getMat(e,Oe),r.modelOrigin.getVec(e,Me),i[0]=Oe[0],i[1]=Oe[1],i[2]=Oe[2],i[3]=0,i[4]=Oe[3],i[5]=Oe[4],i[6]=Oe[5],i[7]=0,i[8]=Oe[6],i[9]=Oe[7],i[10]=Oe[8],i[11]=0,i[12]=Me[0],i[13]=Me[1],i[14]=Me[2],i[15]=1}applyShaderTransformation(e,i){this.shaderTransformation!=null&&this.shaderTransformation.applyTransform(this,e,i)}getCombinedModelTransform(e,i){return this.getModelTransform(e,i),this.shaderTransformation!=null&&this.shaderTransformation.applyTransform(this,e,i),i}getCombinedLocalTransform(e,i){this._view.localTransform.getMat(e,i),this.shaderTransformation!=null&&this.shaderTransformation.applyTransform(this,e,i)}getCombinedMaxScaleFactor(e){let i=this._view.modelScaleFactors.get(e,1);return this.shaderTransformation!=null&&(this.shaderTransformation.scaleFactor(Me,this,e),i*=Math.max(Me[0],Me[1],Me[2])),i}getCombinedMedianScaleFactor(e){let i=this._view.modelScaleFactors.get(e,0);return this.shaderTransformation!=null&&(this.shaderTransformation.scaleFactor(Me,this,e),i*=wp(Me[0],Me[1],Me[2])),i}getModel(e,i){this._view.model.getMat(e,i)}setFeatureAttribute(e,i){this._view.featureAttribute?.setVec(e,i)}getFeatureAttribute(e,i){this._view.featureAttribute?.getVec(e,i)}setColor(e,i){this._view.color?.setVec(e,i)}setObjectAndLayerIdColor(e,i){this._view.olidColor?.setVec(e,i)}setVisible(e,i){i!==this.getVisible(e)&&(this._setStateFlag(e,4,i),this.events.emit("instance-visibility-changed",{index:e}))}getVisible(e){return this._getStateFlag(e,4)}setHighlight(e,i){const{_highlightOptionsMap:r}=this,s=r.get(e);i?i!==s&&(r.set(e,i),this._setStateFlag(e,8,!0),this.events.emit("instance-highlight-changed")):s&&(r.delete(e),this._setStateFlag(e,8,!1),this.events.emit("instance-highlight-changed"))}get highlightOptionsMap(){return this._highlightOptionsMap}getHighlightStateFlag(e){return this._getStateFlag(e,8)}geHighlightOptionsPrev(e){const i=this._highlightOptionsMapPrev.get(e)??null;return this._highlightOptionsMapPrev.delete(e),i}getHighlightName(e){const i=this.highlightOptionsMap.get(e)??null;return i?this._highlightOptionsMapPrev.set(e,i):this._highlightOptionsMapPrev.delete(e),i}getState(e){return this._view.state.get(e)}getLodLevel(e){return this._view.lodLevel.get(e)}countFlags(e){let i=0;for(let r=0;r<this._capacity;++r)this.getState(r)&e&&++i;return i}_setStateFlags(e,i){const r=this._view.state;i=r.get(e)|i,r.set(e,i)}_clearStateFlags(e,i){const r=this._view.state;i=r.get(e)&~i,r.set(e,i)}_setStateFlag(e,i,r){r?this._setStateFlags(e,i):this._clearStateFlags(e,i)}_getStateFlag(e,i){return!!(this._view.state.get(e)&i)}_grow(){this._capacity=Math.max(wr,Math.floor(this._capacity*ga)),this._buffer=this._layout.createBuffer(this._capacity).copyFrom(this._buffer),this._view=new Kn(this._buffer)}_findSlot(){const e=this._view.state;let i=this._next;for(;1&e.get(i);)i=i+1===this._capacity?0:i+1;return this._next=i+1===this._capacity?0:i+1,i}};function wp(t,e,i){return Math.max(Math.min(t,e),Math.min(Math.max(t,e),i))}f([x({constructOnly:!0})],mi.prototype,"shaderTransformation",void 0),f([x()],mi.prototype,"_size",void 0),f([x({readOnly:!0})],mi.prototype,"size",null),mi=f([zt("esri.views.3d.webgl-engine.lib.lodRendering.InstanceData")],mi);const Tp=As().mat4f64("localTransform").mat4f64("globalTransform").vec4f64("boundingSphere").vec3f64("modelOrigin").mat3f("instanceModel").mat3f("instanceModelNormal").vec2f("modelScaleFactors");function Mp(t){return Yo(Tp.clone(),t).u8("state").u8("lodLevel")}function Yo(t,e){return e.instancedFeatureAttribute&&t.vec4f("instanceFeatureAttribute"),e.instancedColor&&t.vec4u8("instanceColor"),Vs()&&t.vec4u8("instanceOlidColor"),t}const Me=g(),Oe=wt(),Jn=ne(),ns=ne(),wr=64;let Sp=class{constructor(e){this.model=e.instanceModel,this.modelNormal=e.instanceModelNormal,this.modelOriginHi=e.instanceModelOriginHi,this.modelOriginLo=e.instanceModelOriginLo,this.featureAttribute=e.getField("instanceFeatureAttribute",hr),this.color=e.getField("instanceColor",ri),this.olidColor=e.getField("instanceOlidColor",ri)}},W_=class{constructor(e,i){this._rctx=e,this._layout=i,this._headIndex=0,this._tailIndex=0,this._firstIndex=null,this._captureFirstIndex=!0,this._updating=!1,this._prevHeadIndex=0,this._resized=!1,this._capacity=1}destroy(){this._buffer&&this._buffer.destroy()}get buffer(){return this._buffer.buffer}get view(){return this._view}get capacity(){return this._capacity}get size(){const e=this._headIndex,i=this._tailIndex;return e>=i?e-i:e+this._capacity-i}get isEmpty(){return this._headIndex===this._tailIndex}get isFull(){return this._tailIndex===(this._headIndex+1)%this._capacity}get headIndex(){return this._headIndex}get tailIndex(){return this._tailIndex}get firstIndex(){return this._firstIndex}get usedMemory(){return this._buffer?.usedMemory??0}reset(){this._headIndex=0,this._tailIndex=0,this._firstIndex=null}startUpdateCycle(){this._captureFirstIndex=!0}beginUpdate(){W(!this._updating,"already updating"),this._updating=!0,this._prevHeadIndex=this._headIndex}endUpdate(){W(this._updating,"not updating"),this.size<Gl*this.capacity&&this._shrink(),this._resized?(this._buffer.transferAll(),this._resized=!1):this._transferRange(this._prevHeadIndex,this._headIndex),this._updating=!1}allocateHead(){W(this._updating,"not updating"),this.isFull&&this._grow();const e=this.headIndex;return this._captureFirstIndex&&(this._firstIndex=e,this._captureFirstIndex=!1),this._incrementHead(),W(this._headIndex!==this._tailIndex,"invalid pointers"),e}freeTail(){W(this._updating,"not updating"),W(this.size>0,"invalid size");const e=this._tailIndex===this._firstIndex;this._incrementTail(),e&&(this._firstIndex=this._tailIndex)}_grow(){const e=Math.max(wr,Math.floor(this._capacity*ga));this._resize(e)}_shrink(){const e=Math.max(wr,Math.floor(this._capacity*Ul));this._resize(e)}_resize(e){if(W(this._updating,"not updating"),e===this._capacity)return;const i=new yp(this._rctx,this._layout,e);if(this._buffer){this._firstIndex&&(this._firstIndex=(this._firstIndex+this._capacity-this._tailIndex)%this._capacity);const r=this.size,s=this._compactInstances(i);W(s===r,"invalid compaction"),this._buffer.destroy(),this._tailIndex=0,this._headIndex=s,this._prevHeadIndex=0}this._resized=!0,this._capacity=e,this._buffer=i,this._view=new Sp(this._layout.createView(this._buffer.array))}_compactInstances(e){const i=this._headIndex,r=this._tailIndex;return r<i?(this._buffer.copyRange(r,i,e),i-r):r>i?(this._buffer.copyRange(r,this._capacity,e),i>0&&this._buffer.copyRange(0,i,e,this._capacity-r),i+(this._capacity-r)):0}_incrementHead(e=1){this._headIndex=(this._headIndex+e)%this._capacity}_incrementTail(e=1){this._tailIndex=(this._tailIndex+e)%this._capacity}_transferRange(e,i){e<i?this._buffer.transferRange(e,i):e>i&&(i>0&&this._buffer.transferRange(0,i),this._buffer.transferRange(e,this._capacity))}};const $p=As().vec3f("instanceModelOriginHi").vec3f("instanceModelOriginLo").mat3f("instanceModel").mat3f("instanceModelNormal");function Cp(t){return Yo($p.clone(),t)}function q_({normalTexture:t,metallicRoughnessTexture:e,metallicFactor:i,roughnessFactor:r,emissiveTexture:s,emissiveFactor:n,occlusionTexture:a}){return t==null&&e==null&&s==null&&(n==null||We(n,ot))&&a==null&&(r==null||r===1)&&(i==null||i===1)}function X_({normalTexture:t,metallicRoughnessTexture:e,metallicFactor:i,roughnessFactor:r,emissiveTexture:s,emissiveFactor:n,occlusionTexture:a}){return t==null&&e==null&&s==null&&(n==null||We(n,ot))&&a==null&&(r==null||r===1)&&(i==null||i===1||i===0)}const Ep=Ci(1,1,.5),Y_=Ci(0,.6,.2),Z_=Ci(0,1,.2);function Zo(t){t.vertex.code.add(h`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`)}function Ip(t){t.varyings.add("linearDepth","float",{invariant:!0})}function Ko(t,e){Ip(t),t.vertex.code.add(h`
    void forwardLinearDepth(float _linearDepth) { ${G(e,"linearDepth = _linearDepth;")} }
  `)}function Jo(t){t.vertex.uniforms.add(new Dr("nearFar",e=>e.camera.nearFar))}function Qo(t){t.vertex.code.add(h`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function K_(t,e){const{vertex:i}=t,r=tr(e.output);r&&(t.include(fp,e),Ko(t,!0),Jo(t),Qo(t)),i.code.add(h`
    void forwardLinearDepthToWriteShadowMap() {
      ${G(r,"forwardLinearDepth(calculateLinearDepth(nearFar, vPosition_view.z));")}
    }
  `)}function Kt(t){Qo(t),t.vertex.code.add(h`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),t.vertex.code.add(h`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function el(t,e){e.instancedColor?(t.attributes.add("instanceColor","vec4"),t.vertex.include(Tt),t.vertex.include(No),t.vertex.include(Ws),t.vertex.code.add(h`
      MaskedColor applyInstanceColor(MaskedColor color) {
        return multiplyMaskedColors( color, createMaskedFromUInt8NaNColor(${"instanceColor"}));
      }
    `)):t.vertex.code.add(h`MaskedColor applyInstanceColor(MaskedColor color) {
return color;
}`)}function J_(t,e,i){for(let r=0;r<i;++r)e[2*r]=t[r],e[2*r+1]=t[r]-e[2*r]}function Ap(t,e){const i=t.length;for(let r=0;r<i;++r)Jt[0]=t[r],e[r]=Jt[0];return e}function Fp(t,e){const i=t.length;for(let r=0;r<i;++r)Jt[0]=t[r],Jt[1]=t[r]-Jt[0],e[r]=Jt[1];return e}const Jt=new Float32Array(2),Qn=wt();function tl(t,e){const{hasModelTransformation:i,instancedDoublePrecision:r,instanced:s,output:n,hasVertexTangents:a}=e;i&&(t.vertex.uniforms.add(new qo("model",o=>o.modelTransformation??or)),t.vertex.uniforms.add(new Ye("normalLocalOriginFromModel",o=>(Dc(Qn,o.modelTransformation??or),Qn)))),s&&r&&(t.attributes.add("instanceModelOriginHi","vec3"),t.attributes.add("instanceModelOriginLo","vec3"),t.attributes.add("instanceModel","mat3"),t.attributes.add("instanceModelNormal","mat3"));const l=t.vertex;r&&(l.include(Wo,e),l.uniforms.add(new Dt("viewOriginHi",o=>Ap(U(Zi,o.camera.viewInverseTransposeMatrix[3],o.camera.viewInverseTransposeMatrix[7],o.camera.viewInverseTransposeMatrix[11]),Zi)),new Dt("viewOriginLo",o=>Fp(U(Zi,o.camera.viewInverseTransposeMatrix[3],o.camera.viewInverseTransposeMatrix[7],o.camera.viewInverseTransposeMatrix[11]),Zi)))),l.code.add(h`
    vec3 getVertexInLocalOriginSpace() {
      return ${i?r?"(model * vec4(instanceModel * localPosition().xyz, 1.0)).xyz":"(model * localPosition()).xyz":r?"instanceModel * localPosition().xyz":"localPosition().xyz"};
    }

    vec3 subtractOrigin(vec3 _pos) {
      ${r?h`
          // Issue: (should be resolved now with invariant position) https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/56280
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -instanceModelOriginHi, -instanceModelOriginLo);
          return _pos - originDelta;`:"return vpos;"}
    }
    `),l.code.add(h`
    vec3 dpNormal(vec4 _normal) {
      return normalize(${i?r?"normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz)":"normalLocalOriginFromModel * _normal.xyz":r?"instanceModelNormal * _normal.xyz":"_normal.xyz"});
    }
    `),n===3&&(Qd(l),l.code.add(h`
    vec3 dpNormalView(vec4 _normal) {
      return normalize((viewNormal * ${i?r?"vec4(normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz), 1.0)":"vec4(normalLocalOriginFromModel * _normal.xyz, 1.0)":r?"vec4(instanceModelNormal * _normal.xyz, 1.0)":"_normal"}).xyz);
    }
    `)),a&&l.code.add(h`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i?r?"return vec4(normalLocalOriginFromModel * (instanceModelNormal * _tangent.xyz), _tangent.w);":"return vec4(normalLocalOriginFromModel * _tangent.xyz, _tangent.w);":r?"return vec4(instanceModelNormal * _tangent.xyz, _tangent.w);":"return _tangent;"}
    }`)}const Zi=g();let Rp=class extends ie{constructor(e,i){super(e,"int",1,(r,s,n)=>r.setUniform1i(e,i(s,n)))}};function il(t,e){t.varyings.add("colorMixMode","int"),t.varyings.add("opacityMixMode","int"),t.vertex.uniforms.add(new Rp("symbolColorMixMode",i=>Ti[i.colorMixMode])),e.hasSymbolColors?(t.vertex.include(Tt),t.vertex.include(No),t.vertex.include(Ws),t.attributes.add("symbolColor","vec4"),t.vertex.code.add(h`
    MaskedColor applySymbolColor(MaskedColor color) {
      return multiplyMaskedColors(color, createMaskedFromUInt8NaNColor(${"symbolColor"}));
    }
  `)):t.vertex.code.add(h`MaskedColor applySymbolColor(MaskedColor color) {
return color;
}`),t.vertex.code.add(h`
    void forwardColorMixMode(bvec4 mask) {
      colorMixMode = mask.r ? ${h.int(Ti.ignore)} : symbolColorMixMode;
      opacityMixMode = mask.a ? ${h.int(Ti.ignore)} : symbolColorMixMode;
    }
  `)}function rl(t,e){e.hasVertexColors?(t.attributes.add("color","vec4"),t.varyings.add("vColor","vec4"),t.vertex.code.add(h`void forwardVertexColor() { vColor = color; }`),t.vertex.code.add(h`
      void forwardNormalizedVertexColor() { vColor = color * ${h.float(1/255)}; }
    `)):t.vertex.code.add(h`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}function Op(t,e){switch(e.output){case 4:case 5:case 6:case 7:t.fragment.code.add(h`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
return depth + SLOPE_SCALE * m + BIAS;
}
void outputDepth(float _linearDepth){
float fragDepth = _calculateFragDepth(_linearDepth);
gl_FragDepth = fragDepth;
}`);break;case 8:t.fragment.code.add(h`void outputDepth(float _linearDepth){
gl_FragDepth = _linearDepth;
}`)}}function Qt(t,e){sl(t,e,new xt("textureAlphaCutoff",i=>i.textureAlphaCutoff))}function ex(t,e){sl(t,e,new xc("textureAlphaCutoff",i=>i.textureAlphaCutoff))}function sl(t,e,i){const r=t.fragment,s=e.alphaDiscardMode,n=s===0;s!==2&&s!==3||r.uniforms.add(i),r.code.add(h`
    void discardOrAdjustAlpha(inout vec4 color) {
      ${s===1?"color.a = 1.0;":`if (color.a < ${n?h.float(oi):"textureAlphaCutoff"}) {
              discard;
             } ${G(s===2,"else { color.a = 1.0; }")}`}
    }
  `)}function nl(t,e){const{vertex:i,fragment:r,varyings:s}=t,{hasColorTexture:n,alphaDiscardMode:a}=e,l=n&&a!==1,{output:o,normalType:c,hasColorTextureTransform:u}=e;switch(o){case 2:Xt(i,e),t.include(Kt),r.include(Zt,e),t.include(kt,e),l&&r.uniforms.add(new Ee("tex",d=>d.texture)),i.main.add(h`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`),t.include(Qt,e),r.main.add(h`
        discardBySlice(vpos);
        ${G(l,h`vec4 texColor = texture(tex, ${u?"colorUV":"vuv0"});
                discardOrAdjustAlpha(texColor);`)}`);break;case 4:case 5:case 6:case 7:case 10:Xt(i,e),t.include(Kt),t.include(kt,e),t.include(Mi,e),t.include(Op,e),r.include(Zt,e),t.include(wf,e),Jo(t),s.add("depth","float",{invariant:!0}),l&&r.uniforms.add(new Ee("tex",d=>d.texture)),i.main.add(h`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();`),t.include(Qt,e),r.main.add(h`
        discardBySlice(vpos);
        ${G(l,h`vec4 texColor = texture(tex, ${u?"colorUV":"vuv0"});
               discardOrAdjustAlpha(texColor);`)}
        ${o===10?h`outputObjectAndLayerIdColor();`:h`outputDepth(depth);`}`);break;case 3:{Xt(i,e),t.include(Kt),t.include(Lr,e),t.include(Xo,e),t.include(kt,e),t.include(Mi,e),l&&r.uniforms.add(new Ee("tex",m=>m.texture)),c===2&&s.add("vPositionView","vec3",{invariant:!0});const d=c===0||c===1;i.main.add(h`
        vpos = getVertexInLocalOriginSpace();
        ${d?h`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));`:h`vPositionView = (view * vec4(vpos, 1.0)).xyz;`}
        vpos = subtractOrigin(vpos);
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, vpos);
        forwardTextureCoordinates();`),r.include(Zt,e),t.include(Qt,e),r.main.add(h`
        discardBySlice(vpos);
        ${G(l,h`vec4 texColor = texture(tex, ${u?"colorUV":"vuv0"});
                discardOrAdjustAlpha(texColor);`)}

        ${c===2?h`vec3 normal = screenDerivativeNormal(vPositionView);`:h`vec3 normal = normalize(vNormalWorld);
                    if (gl_FrontFacing == false){
                      normal = -normal;
                    }`}
        fragColor = vec4(0.5 + 0.5 * normal, 1.0);`);break}case 9:Xt(i,e),t.include(Kt),t.include(kt,e),t.include(Mi,e),l&&r.uniforms.add(new Ee("tex",d=>d.texture)),i.main.add(h`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`),r.include(Zt,e),t.include(Qt,e),t.include(zo,e),r.main.add(h`
        discardBySlice(vpos);
        ${G(l,h`vec4 texColor = texture(tex, ${u?"colorUV":"vuv0"});
                discardOrAdjustAlpha(texColor);`)}
        calculateOcclusionAndOutputHighlight();`)}}function Pp(t,e){const i=t.fragment,{hasVertexTangents:r,doubleSidedMode:s,hasNormalTexture:n,textureCoordinateType:a,bindType:l,hasNormalTextureTransform:o}=e;r?(t.attributes.add("tangent","vec4"),t.varyings.add("vTangent","vec4"),s===2?i.code.add(h`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`):i.code.add(h`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)):i.code.add(h`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`),n&&a!==0&&(t.include($a,e),i.uniforms.add(l===1?new Ee("normalTexture",c=>c.textureNormal):new dr("normalTexture",c=>c.textureNormal)),o&&(i.uniforms.add(new to("scale",c=>c.scale??ou)),i.uniforms.add(new Ye("normalTextureTransformMatrix",c=>c.normalTextureTransformMatrix??ai))),i.code.add(h`vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
vec3 rawNormal = textureLookup(normalTexture, uv).rgb * 2.0 - 1.0;`),o&&i.code.add(h`mat3 normalRotation = mat3(normalTextureTransformMatrix[0][0]/scale[0], normalTextureTransformMatrix[0][1]/scale[1], 0.0,
normalTextureTransformMatrix[1][0]/scale[0], normalTextureTransformMatrix[1][1]/scale[1], 0.0,
0.0, 0.0, 0.0 );
rawNormal.xy = (normalRotation * vec3(rawNormal.x, rawNormal.y, 1.0)).xy;`),i.code.add(h`return tangentSpace * rawNormal;
}`))}const Dp=3e5,ea=5e5;let zp=class extends ie{constructor(e,i,r){super(e,"vec2",2,(s,n,a,l)=>s.setUniform2fv(e,i(n,a,l),r))}};const as=4;function Np(){const t=new Ir,e=t.fragment;t.include(eo);const i=(as+1)/2,r=1/(2*i*i);return e.include(Gs),e.uniforms.add(new Ee("depthMap",s=>s.depthTexture),new dr("tex",s=>s.colorTexture),new zp("blurSize",s=>s.blurSize),new xt("projScale",(s,n)=>{const a=n.camera.distance;return a>5e4?Math.max(0,s.projScale-(a-5e4)):s.projScale})),e.code.add(h`
    void blurFunction(vec2 uv, float r, float center_d, float sharpness, inout float wTotal, inout float bTotal) {
      float c = texture(tex, uv).r;
      float d = linearDepthFromTexture(depthMap, uv);

      float ddiff = d - center_d;

      float w = exp(-r * r * ${h.float(r)} - ddiff * ddiff * sharpness);
      wTotal += w;
      bTotal += w * c;
    }
  `),t.outputs.add("fragBlur","float"),e.main.add(h`
    float b = 0.0;
    float w_total = 0.0;

    float center_d = linearDepthFromTexture(depthMap, uv);

    float sharpness = -0.05 * projScale / center_d;
    for (int r = -${h.int(as)}; r <= ${h.int(as)}; ++r) {
      float rf = float(r);
      vec2 uvOffset = uv + rf * blurSize;
      blurFunction(uvOffset, rf, center_d, sharpness, w_total, b);
    }
    fragBlur = b / w_total;`),t}const Lp=Object.freeze(Object.defineProperty({__proto__:null,build:Np},Symbol.toStringTag,{value:"Module"}));let ta=class extends Ns{constructor(e,i){super(e,i,new Ar(Lp,()=>Oi(()=>import("./RealisticTree.glsl-IWCjmMLr.js").then(r=>r.ao),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]))),go)}initializePipeline(){return Or({colorWrite:Rr})}};const Vp="eXKEvZaUc66cjIKElE1jlJ6MjJ6Ufkl+jn2fcXp5jBx7c6KEflSGiXuXeW6OWs+tfqZ2Yot2Y7Zzfo2BhniEj3xoiXuXj4eGZpqEaHKDWjSMe7palFlzc3BziYOGlFVzg6Zzg7CUY5JrjFF7eYJ4jIKEcyyEonSXe7qUfqZ7j3xofqZ2c4R5lFZ5Y0WUbppoe1l2cIh2ezyUho+BcHN2cG6DbpqJhqp2e1GcezhrdldzjFGUcyxjc3aRjDyEc1h7Sl17c6aMjH92pb6Mjpd4dnqBjMOEhqZleIOBYzB7gYx+fnqGjJuEkWlwnCx7fGl+c4hjfGyRe5qMlNOMfnqGhIWHc6OMi4GDc6aMfqZuc6aMzqJzlKZ+lJ6Me3qRfoFue0WUhoR5UraEa6qMkXiPjMOMlJOGe7JrUqKMjK6MeYRzdod+Sl17boiPc6qEeYBlcIh2c1WEe7GDiWCDa0WMjEmMdod+Y0WcdntzhmN8WjyMjKJjiXtzgYxYaGd+a89zlEV7e2GJfnd+lF1rcK5zc4p5cHuBhL6EcXp5eYB7fnh8iX6HjIKEeaxuiYOGc66RfG2Ja5hzjlGMjEmMe9OEgXuPfHyGhPeEdl6JY02McGuMfnqGhFiMa3WJfnx2l4hwcG1uhmN8c0WMc39og1GBbrCEjE2EZY+JcIh2cIuGhIWHe0mEhIVrc09+gY5+eYBlnCyMhGCDl3drfmmMgX15aGd+gYx+fnuRfnhzY1SMsluJfnd+hm98WtNrcIuGh4SEj0qPdkqOjFF7jNNjdnqBgaqUjMt7boeBhnZ4jDR7c5pze4GGjEFrhLqMjHyMc0mUhKZze4WEa117kWlwbpqJjHZ2eX2Bc09zeId+e0V7WlF7jHJ2l72BfId8l3eBgXyBe897jGl7c66cgW+Xc76EjKNbgaSEjGx4fId8jFFjgZB8cG6DhlFziZhrcIh2fH6HgUqBgXiPY8dahGFzjEmMhEFre2dxhoBzc5SGfleGe6alc7aUeYBlhKqUdlp+cH5za4OEczxza0Gcc4J2jHZ5iXuXjH2Jh5yRjH2JcFx+hImBjH+MpddCl3dreZeJjIt8ZW18bm1zjoSEeIOBlF9oh3N7hlqBY4+UeYFwhLJjeYFwaGd+gUqBYxiEYot2fqZ2ondzhL6EYyiEY02Ea0VjgZB8doaGjHxoc66cjEGEiXuXiXWMiZhreHx8frGMe75rY02Ec5pzfnhzlEp4a3VzjM+EhFFza3mUY7Zza1V5e2iMfGyRcziEhDyEkXZ2Y4OBnCx7g5t2eyBjgV6EhEFrcIh2dod+c4Z+nJ5zjm15jEmUeYxijJp7nL6clIpjhoR5WrZraGd+fnuRa6pzlIiMg6ZzfHx5foh+eX1ufnB5eX1ufnB5aJt7UqKMjIh+e3aBfm5lbYSBhGFze6J4c39oc0mUc4Z+e0V7fKFVe0WEdoaGY02Ec4Z+Y02EZYWBfH6HgU1+gY5+hIWUgW+XjJ57ebWRhFVScHuBfJ6PhBx7WqJzlM+Ujpd4gHZziX6HjHmEgZN+lJt5boiPe2GJgX+GjIGJgHZzeaxufnB5hF2JtdN7jJ57hp57hK6ElFVzg6ZzbmiEbndzhIWHe3uJfoFue3qRhJd2j3xoc65zlE1jc3p8lE1jhniEgXJ7e657vZaUc3qBh52BhIF4aHKDa9drgY5+c52GWqZzbpqJe8tjnM+UhIeMfo2BfGl+hG1zSmmMjKJjZVaGgX15c1lze0mEp4OHa3mUhIWHhDyclJ6MeYOJkXiPc0VzhFiMlKaEboSJa5Jze41re3qRhn+HZYWBe0mEc4p5fnORbox5lEp4hGFjhGGEjJuEc1WEhLZjeHeGa7KlfHx2hLaMeX1ugY5+hIWHhKGPjMN7c1WEho1zhoBzZYx7fnhzlJt5exyUhFFziXtzfmmMa6qMYyiEiXxweV12kZSMeWqXSl17fnhzxmmMrVGEe1mcc4p5eHeGjK6MgY5+doaGa6pzlGV7g1qBh4KHkXiPeW6OaKqafqZ2eXZ5e1V7jGd7boSJc3BzhJd2e0mcYot2h1RoY8dahK6EQmWEWjx7e1l2lL6UgXyBdnR4eU9zc0VreX1umqaBhld7fo2Bc6KEc5Z+hDyEcIeBWtNrfHyGe5qMhMuMe5qMhEGEbVVupcNzg3aHhIF4boeBe0mEdlptc39ofFl5Y8uUlJOGiYt2UmGEcyxjjGx4jFF7a657ZYWBnElzhp57iXtrgZN+tfOEhIOBjE2HgU1+e8tjjKNbiWCDhE15gUqBgYN7fnqGc66ce9d7iYSBj0qPcG6DnGGcT3eGa6qMZY+JlIiMl4hwc3aRdnqBlGV7eHJ2hLZjfnuRhDyEeX6MSk17g6Z+c6aUjHmEhIF4gXyBc76EZW18fGl+fkl+jCxrhoVwhDyUhIqGlL2DlI6EhJd2tdN7eYORhEGMa2Faa6pzc3Bzc4R5lIRznM+UY9eMhDycc5Z+c4p5c4iGY117pb6MgXuPrbJafnx2eYOJeXZ5e657hDyEcziElKZjfoB5eHeGj4WRhGGEe6KGeX1utTStc76EhFGJnCyMa5hzfH6HnNeceYB7hmN8gYuMhIVrczSMgYF8h3N7c5pza5hzjJqEYIRdgYuMlL2DeYRzhGGEeX1uhLaEc4iGeZ1zdl6JhrVteX6Me2iMfm5lWqJzSpqEa6pzdnmchHx2c6OMhNdrhoR5g3aHczxzeW52gV6Ejm15frGMc0Vzc4Z+l3drfniJe+9rWq5rlF1rhGGEhoVwe9OEfoh+e7pac09+c3qBY0lrhDycdnp2lJ6MiYOGhGCDc3aRlL2DlJt5doaGdnp2gYF8gWeOjF2Uc4R5c5Z+jEmMe7KEc4mEeYJ4dmyBe0mcgXiPbqJ7eYB7fmGGiYSJjICGlF1reZ2PnElzbpqJfH6Hc39oe4WEc5eJhK6EhqyJc3qBgZB8c09+hEmEaHKDhFGJc5SGiXWMUpaEa89zc6OMnCyMiXtrho+Be5qMc7KEjJ57dmN+hKGPjICGbmiEe7prdod+hGCDdnmchBx7eX6MkXZ2hGGEa657hm98jFFjY5JreYOJgY2EjHZ2a295Y3FajJ6Mc1J+YzB7e4WBjF2Uc4R5eV12gYxzg1qBeId+c9OUc5pzjFFjgY5+hFiMlIaPhoR5lIpjjIKBlNdSe7KEeX2BfrGMhIqGc65zjE2UhK6EklZ+QmWEeziMWqZza3VzdnR4foh+gYF8n3iJiZhrnKp7gYF8eId+lJ6Me1lrcIuGjKJjhmN8c66MjFF7a6prjJ6UnJ5zezyUfruRWlF7nI5zfHyGe657h4SEe8tjhBx7jFFjc09+c39ojICMeZeJeXt+YzRzjHZ2c0WEcIeBeXZ5onSXkVR+gYJ+eYFwdldzgYF7eX2BjJ6UiXuXlE1jh4SEe1mchLJjc4Z+hqZ7eXZ5bm1zlL6Ue5p7iWeGhKqUY5pzjKJjcIeBe8t7gXyBYIRdlEp4a3mGnK6EfmmMZpqEfFl5gYxzjKZuhGFjhoKGhHx2fnx2eXuMe3aBiWeGvbKMe6KGa5hzYzB7gZOBlGV7hmN8hqZlYot2Y117a6pzc6KEfId8foB5rctrfneJfJ6PcHN2hFiMc5pzjH92c0VzgY2EcElzdmCBlFVzg1GBc65zY4OBboeBcHiBeYJ4ewxzfHx5lIRzlEmEnLKEbk1zfJ6PhmN8eYBljBiEnMOEiXxwezyUcIeBe76EdsKEeX2BdnR4jGWUrXWMjGd7fkl+j4WRlEGMa5Jzho+BhDyEfnqMeXt+g3aHlE1jczClhNN7ZW18eHx8hGFjZW18iXWMjKJjhH57gYuMcIuGWjyMe4ZtjJuExmmMj4WRdntzi4GDhFFzYIRdnGGcjJp7Y0F7e4WEkbCGiX57fnSHa657a6prhBCMe3Z+SmmMjH92eHJ2hK6EY1FzexhrvbKMnI5za4OEfnd+eXuMhImBe897hLaMjN+EfG+BeIOBhF1+eZeJi4GDkXZ2eXKEgZ6Ejpd4c2GHa1V5e5KUfqZuhCx7jKp7lLZrg11+hHx2hFWUoot2nI5zgbh5mo9zvZaUe3qRbqKMfqZ2kbCGhFiM";let Bp=class extends Ve{constructor(){super(...arguments),this.projScale=1}},Hp=class extends Bp{constructor(){super(...arguments),this.intensity=1}},jp=class extends Ve{},Gp=class extends jp{constructor(){super(...arguments),this.blurSize=Pi()}};function Up(t){t.fragment.uniforms.add(new Pe("projInfo",e=>Wp(e.camera))),t.fragment.uniforms.add(new Dr("zScale",e=>kp(e.camera))),t.fragment.code.add(h`vec3 reconstructPosition(vec2 fragCoord, float depth) {
return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);
}`)}function Wp(t){const e=t.projectionMatrix;return e[11]===0?$e(ia,2/(t.fullWidth*e[0]),2/(t.fullHeight*e[5]),(1+e[12])/e[0],(1+e[13])/e[5]):$e(ia,-2/(t.fullWidth*e[0]),-2/(t.fullHeight*e[5]),(1-e[8])/e[0],(1-e[9])/e[5])}const ia=at();function kp(t){return t.projectionMatrix[11]===0?Pt(ra,0,1):Pt(ra,1,0)}const ra=Pi(),sa=16;function qp(){const t=new Ir,e=t.fragment;return t.include(eo),t.include(Up),e.include(Gs),e.uniforms.add(new bt("radius",i=>qs(i.camera))).code.add(h`vec3 sphere[16] = vec3[16](
vec3(0.186937, 0.0, 0.0),
vec3(0.700542, 0.0, 0.0),
vec3(-0.864858, -0.481795, -0.111713),
vec3(-0.624773, 0.102853, -0.730153),
vec3(-0.387172, 0.260319, 0.007229),
vec3(-0.222367, -0.642631, -0.707697),
vec3(-0.01336, -0.014956, 0.169662),
vec3(0.122575, 0.1544, -0.456944),
vec3(-0.177141, 0.85997, -0.42346),
vec3(-0.131631, 0.814545, 0.524355),
vec3(-0.779469, 0.007991, 0.624833),
vec3(0.308092, 0.209288,0.35969),
vec3(0.359331, -0.184533, -0.377458),
vec3(0.192633, -0.482999, -0.065284),
vec3(0.233538, 0.293706, -0.055139),
vec3(0.417709, -0.386701, 0.442449)
);
float fallOffFunction(float vv, float vn, float bias) {
float f = max(radius * radius - vv, 0.0);
return f * f * f * max(vn - bias, 0.0);
}`),e.code.add(h`float aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {
vec3 v = Q - C;
float vv = dot(v, v);
float vn = dot(normalize(v), n_C);
return fallOffFunction(vv, vn, 0.1);
}`),t.outputs.add("fragOcclusion","float"),e.uniforms.add(new Ee("normalMap",i=>i.normalTexture),new Ee("depthMap",i=>i.depthTexture),new xt("projScale",i=>i.projScale),new Ee("rnm",i=>i.noiseTexture),new to("rnmScale",(i,r)=>Pt(na,r.camera.fullWidth/i.noiseTexture.descriptor.width,r.camera.fullHeight/i.noiseTexture.descriptor.height)),new xt("intensity",i=>i.intensity),new Dr("screenSize",i=>Pt(na,i.camera.fullWidth,i.camera.fullHeight))).main.add(h`
    float depth = depthFromTexture(depthMap, uv);

    // Early out if depth is out of range, such as in the sky
    if (depth >= 1.0 || depth <= 0.0) {
      fragOcclusion = 1.0;
      return;
    }

    // get the normal of current fragment
    ivec2 iuv = ivec2(uv * vec2(textureSize(normalMap, 0)));
    vec4 norm4 = texelFetch(normalMap, iuv, 0);
    if(norm4.a != 1.0) {
      fragOcclusion = 1.0;
      return;
    }
    vec3 norm = normalize(norm4.xyz * 2.0 - 1.0);

    float currentPixelDepth = linearizeDepth(depth);
    vec3 currentPixelPos = reconstructPosition(gl_FragCoord.xy, currentPixelDepth);

    float sum = 0.0;
    vec3 tapPixelPos;

    vec3 fres = normalize(2.0 * texture(rnm, uv * rnmScale).xyz - 1.0);

    // note: the factor 2.0 should not be necessary, but makes ssao much nicer.
    // bug or deviation from CE somewhere else?
    float ps = projScale / (2.0 * currentPixelPos.z * zScale.x + zScale.y);

    for(int i = 0; i < ${h.int(sa)}; ++i) {
      vec2 unitOffset = reflect(sphere[i], fres).xy;
      vec2 offset = vec2(-unitOffset * radius * ps);

      // don't use current or very nearby samples
      if( abs(offset.x) < 2.0 || abs(offset.y) < 2.0){
        continue;
      }

      vec2 tc = vec2(gl_FragCoord.xy + offset);
      if (tc.x < 0.0 || tc.y < 0.0 || tc.x > screenSize.x || tc.y > screenSize.y) continue;
      vec2 tcTap = tc / screenSize;
      float occluderFragmentDepth = linearDepthFromTexture(depthMap, tcTap);

      tapPixelPos = reconstructPosition(tc, occluderFragmentDepth);

      sum += aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);
    }

    // output the result
    float A = max(1.0 - sum * intensity / float(${h.int(sa)}), 0.0);

    // Anti-tone map to reduce contrast and drag dark region farther: (x^0.2 + 1.2 * x^4) / 2.2
    A = (pow(A, 0.2) + 1.2 * A * A * A * A) / 2.2;

    fragOcclusion = A;
  `),t}function qs(t){return Math.max(10,20*t.computeScreenPixelSizeAtDist(Math.abs(4*t.relativeElevation)))}const na=Pi(),Xp=Object.freeze(Object.defineProperty({__proto__:null,build:qp,getRadius:qs},Symbol.toStringTag,{value:"Module"}));let aa=class extends Ns{constructor(e,i){super(e,i,new Ar(Xp,()=>Oi(()=>import("./RealisticTree.glsl-IWCjmMLr.js").then(r=>r.ap),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]))),go)}initializePipeline(){return Or({colorWrite:Rr})}};const _i=2;let gi=class extends Rt{constructor(e){super(e),this.consumes={required:["normals"]},this.produces=zn.SSAO,this.isEnabled=()=>!1,this._enableTime=Ni(0),this._passParameters=new Hp,this._drawParameters=new Gp}initialize(){const e=Uint8Array.from(atob(Vp),r=>r.charCodeAt(0)),i=new Ls(32);i.wrapMode=33071,i.pixelFormat=6407,i.wrapMode=10497,i.hasMipmap=!0,this._passParameters.noiseTexture=new ti(this.renderingContext,i,e),this.techniques.precompile(aa),this.techniques.precompile(ta),this.addHandles(Oa(()=>this.isEnabled(),()=>this._enableTime=Ni(0)))}destroy(){this._passParameters.noiseTexture=cr(this._passParameters.noiseTexture)}render(e){const i=e.find(({name:P})=>P==="normals"),r=i?.getTexture(),s=i?.getTexture(Sc);if(!r||!s)return;const n=this.techniques.get(aa),a=this.techniques.get(ta);if(!n.compiled||!a.compiled)return this._enableTime=Ni(performance.now()),void this.requestRender(1);this._enableTime===0&&(this._enableTime=Ni(performance.now()));const l=this.renderingContext,o=this.view.qualitySettings.fadeDuration,c=this.bindParameters,u=c.camera,d=u.relativeElevation,m=Le((ea-d)/(ea-Dp),0,1),v=o>0?Math.min(o,performance.now()-this._enableTime)/o:1,p=v*m;this._passParameters.normalTexture=r,this._passParameters.depthTexture=s,this._passParameters.projScale=1/u.computeScreenPixelSizeAtDist(1),this._passParameters.intensity=4*Yp/qs(u)**6*p;const _=u.fullViewport[2],b=u.fullViewport[3],y=this.fboCache.acquire(_,b,"ssao input",2);l.bindFramebuffer(y.fbo),l.setViewport(0,0,_,b),l.bindTechnique(n,c,this._passParameters,this._drawParameters),l.screen.draw();const M=Math.round(_/_i),w=Math.round(b/_i),S=this.fboCache.acquire(M,w,"ssao blur",0);l.bindFramebuffer(S.fbo),this._drawParameters.colorTexture=y.getTexture(),Pt(this._drawParameters.blurSize,0,_i/b),l.bindTechnique(a,c,this._passParameters,this._drawParameters),l.setViewport(0,0,M,w),l.screen.draw(),y.release();const I=this.fboCache.acquire(M,w,zn.SSAO,0);return l.bindFramebuffer(I.fbo),l.setViewport(0,0,_,b),l.setClearColor(1,1,1,0),l.clear(16384),this._drawParameters.colorTexture=S.getTexture(),Pt(this._drawParameters.blurSize,_i/_,0),l.bindTechnique(a,c,this._passParameters,this._drawParameters),l.setViewport(0,0,M,w),l.screen.draw(),l.setViewport4fv(u.fullViewport),S.release(),v<1&&this.requestRender(2),I}};f([x()],gi.prototype,"consumes",void 0),f([x()],gi.prototype,"produces",void 0),f([x({constructOnly:!0})],gi.prototype,"isEnabled",void 0),gi=f([zt("esri.views.3d.webgl-engine.effects.ssao.SSAO")],gi);const Yp=.5;function Xs(t,e){e.receiveAmbientOcclusion?(t.uniforms.add(new Us("ssaoTex",i=>i.ssao?.getTexture())),t.constants.add("blurSizePixelsInverse","float",1/_i),t.code.add(h`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).r;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)):t.code.add(h`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`)}function Zp(t,e){const i=t.fragment,r=e.lightingSphericalHarmonicsOrder!==void 0?e.lightingSphericalHarmonicsOrder:2;r===0?(i.uniforms.add(new Dt("lightingAmbientSH0",({lighting:s})=>U(oa,s.sh.r[0],s.sh.g[0],s.sh.b[0]))),i.code.add(h`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)):r===1?(i.uniforms.add(new Pe("lightingAmbientSH_R",({lighting:s})=>$e(it,s.sh.r[0],s.sh.r[1],s.sh.r[2],s.sh.r[3])),new Pe("lightingAmbientSH_G",({lighting:s})=>$e(it,s.sh.g[0],s.sh.g[1],s.sh.g[2],s.sh.g[3])),new Pe("lightingAmbientSH_B",({lighting:s})=>$e(it,s.sh.b[0],s.sh.b[1],s.sh.b[2],s.sh.b[3]))),i.code.add(h`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)):r===2&&(i.uniforms.add(new Dt("lightingAmbientSH0",({lighting:s})=>U(oa,s.sh.r[0],s.sh.g[0],s.sh.b[0])),new Pe("lightingAmbientSH_R1",({lighting:s})=>$e(it,s.sh.r[1],s.sh.r[2],s.sh.r[3],s.sh.r[4])),new Pe("lightingAmbientSH_G1",({lighting:s})=>$e(it,s.sh.g[1],s.sh.g[2],s.sh.g[3],s.sh.g[4])),new Pe("lightingAmbientSH_B1",({lighting:s})=>$e(it,s.sh.b[1],s.sh.b[2],s.sh.b[3],s.sh.b[4])),new Pe("lightingAmbientSH_R2",({lighting:s})=>$e(it,s.sh.r[5],s.sh.r[6],s.sh.r[7],s.sh.r[8])),new Pe("lightingAmbientSH_G2",({lighting:s})=>$e(it,s.sh.g[5],s.sh.g[6],s.sh.g[7],s.sh.g[8])),new Pe("lightingAmbientSH_B2",({lighting:s})=>$e(it,s.sh.b[5],s.sh.b[6],s.sh.b[7],s.sh.b[8]))),i.code.add(h`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`),e.pbrMode!==1&&e.pbrMode!==2||i.code.add(h`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`))}const oa=g(),it=at();function Tr(t){t.uniforms.add(new Dt("mainLightDirection",e=>e.lighting.mainLight.direction))}function Fi(t){t.uniforms.add(new Dt("mainLightIntensity",e=>e.lighting.mainLight.intensity))}function Kp(t){Tr(t.fragment),Fi(t.fragment),t.fragment.code.add(h`vec3 applyShading(vec3 shadingNormal, float shadow) {
float dotVal = clamp(dot(shadingNormal, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadow) * dotVal);
}`)}function Jp(t){t.code.add(h`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG) {
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`),t.code.add(h`float integratedRadiance(float cosTheta2, float roughness) {
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`),t.code.add(h`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness) {
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`)}function Ys(t){const e=3.141592653589793,i=.3183098861837907;t.constants.add("PI","float",e),t.constants.add("LIGHT_NORMALIZATION","float",i),t.constants.add("INV_PI","float",i),t.constants.add("HALF_PI","float",1.570796326794897),t.constants.add("TWO_PI","float",6.28318530717958)}function Zs(t,e){t.include(Ys),e.pbrMode!==1&&e.pbrMode!==2&&e.pbrMode!==5&&e.pbrMode!==6||(t.code.add(h`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`),t.code.add(h`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)),e.pbrMode!==1&&e.pbrMode!==2||(t.include(Jp),t.code.add(h`struct PBRShadingInfo
{
float NdotV;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`),t.code.add(h`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`))}function cx(t,e){t.include(Ys),t.code.add(h`
  struct PBRShadingWater {
      float NdotL;   // cos angle between normal and light direction
      float NdotV;   // cos angle between normal and view direction
      float NdotH;   // cos angle between normal and half vector
      float VdotH;   // cos angle between view direction and half vector
      float LdotH;   // cos angle between light direction and half vector
      float VdotN;   // cos angle between view direction and normal vector
  };

  float dtrExponent = ${e.useCustomDTRExponentForWater?"2.2":"2.0"};
  `),t.code.add(h`vec3 fresnelReflection(float angle, vec3 f0, float f90) {
return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);
}`),t.code.add(h`float normalDistributionWater(float NdotH, float roughness) {
float r2 = roughness * roughness;
float NdotH2 = NdotH * NdotH;
float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;
return r2 / denom;
}`),t.code.add(h`float geometricOcclusionKelemen(float LoH) {
return 0.25 / (LoH * LoH);
}`),t.code.add(h`vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max) {
vec3  F = fresnelReflection(props.VdotH, F0, F0Max);
float dSun = normalDistributionWater(props.NdotH, roughness);
float V = geometricOcclusionKelemen(props.LdotH);
float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);
float strengthSunHaze  = 1.2;
float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze) * strengthSunHaze;
return ((dSun + dSunHaze) * V) * F;
}`)}function Qp(t,e,i){(i=i||t).length=t.length;for(let r=0;r<t.length;r++)i[r]=t[r]*e[r];return i}function os(t,e,i){(i=i||t).length=t.length;for(let r=0;r<t.length;r++)i[r]=t[r]*e;return i}function ii(t,e,i){(i=i||t).length=t.length;for(let r=0;r<t.length;r++)i[r]=t[r]+e[r];return i}function al(t){return(t+1)*(t+1)}function em(t){return Le(Math.floor(Math.sqrt(t)-1),0,2)}function ol(t,e,i){const r=t[0],s=t[1],n=t[2],a=i||[];return a.length=al(e),e>=0&&(a[0]=.28209479177),e>=1&&(a[1]=.4886025119*r,a[2]=.4886025119*n,a[3]=.4886025119*s),e>=2&&(a[4]=1.09254843059*r*s,a[5]=1.09254843059*s*n,a[6]=.31539156525*(3*n*n-1),a[7]=1.09254843059*r*n,a[8]=.54627421529*(r*r-s*s)),a}function tm(t,e){const i=al(t),r=e||{r:[],g:[],b:[]};r.r.length=r.g.length=r.b.length=i;for(let s=0;s<i;s++)r.r[s]=r.g[s]=r.b[s]=0;return r}function im(t,e){const i=em(e.r.length);for(const r of t)pa(Cs,r.direction),ol(Cs,i,nt),Qp(nt,ar),os(nt,r.intensity[0],jt),ii(e.r,jt),os(nt,r.intensity[1],jt),ii(e.g,jt),os(nt,r.intensity[2],jt),ii(e.b,jt);return e}function rm(t,e){ol(Cs,0,nt);for(const i of t)e.r[0]+=nt[0]*ar[0]*i.intensity[0]*4*Math.PI,e.g[0]+=nt[0]*ar[0]*i.intensity[1]*4*Math.PI,e.b[0]+=nt[0]*ar[0]*i.intensity[2]*4*Math.PI;return e}function sm(t,e,i,r){tm(e,r),U(i.intensity,0,0,0);let s=!1;const n=nm,a=am,l=om;n.length=0,a.length=0,l.length=0;for(const o of t)o instanceof Ss&&!s?(Z(i.direction,o.direction),Z(i.intensity,o.intensity),i.specularStrength=o.specularStrength,i.environmentStrength=o.environmentStrength,i.castShadows=o.castShadows,s=!0):o instanceof Ss||o instanceof Dd?n.push(o):o instanceof Pd?a.push(o):o instanceof yo&&l.push(o);im(n,r),rm(a,r);for(const o of l)ii(r.r,o.r),ii(r.g,o.g),ii(r.b,o.b)}const nm=[],am=[],om=[],nt=[0],jt=[0],Cs=g(),ar=[3.141593,2.094395,2.094395,2.094395,.785398,.785398,.785398,.785398,.785398];let la=class{constructor(){this.color=g(),this.intensity=1}},lm=class{constructor(){this.direction=g(),this.ambient=new la,this.diffuse=new la}};const ll=.4;let dx=class{constructor(){this._shOrder=2,this._legacy=new lm,this.globalFactor=.5,this.noonFactor=.5,this._sphericalHarmonics=new yo,this._mainLight=new Ss(g(),ve(1,0,0),!1)}get legacy(){return this._legacy}get sh(){return this._sphericalHarmonics}get mainLight(){return this._mainLight}set(e){sm(e,this._shOrder,this._mainLight,this._sphericalHarmonics),this.updateLegacy()}updateLegacy(){Z(this._legacy.direction,this._mainLight.direction);const e=1/Math.PI;this._legacy.ambient.color[0]=.282095*this._sphericalHarmonics.r[0]*e,this._legacy.ambient.color[1]=.282095*this._sphericalHarmonics.g[0]*e,this._legacy.ambient.color[2]=.282095*this._sphericalHarmonics.b[0]*e,q(this._legacy.diffuse.color,this._mainLight.intensity,e),Z(Ki,this._legacy.diffuse.color),q(Ki,Ki,ll*this.globalFactor),pe(this._legacy.ambient.color,this._legacy.ambient.color,Ki)}copyFrom(e){this._sphericalHarmonics.r=Array.from(e.sh.r),this._sphericalHarmonics.g=Array.from(e.sh.g),this._sphericalHarmonics.b=Array.from(e.sh.b),Z(this._mainLight.direction,e.mainLight.direction),Z(this._mainLight.intensity,e.mainLight.intensity),this._mainLight.castShadows=e.mainLight.castShadows,this._mainLight.specularStrength=e.mainLight.specularStrength,this._mainLight.environmentStrength=e.mainLight.environmentStrength,this.globalFactor=e.globalFactor,this.noonFactor=e.noonFactor}lerpLighting(e,i,r){if(lr(this._mainLight.intensity,e.mainLight.intensity,i.mainLight.intensity,r),this._mainLight.environmentStrength=ge(e.mainLight.environmentStrength,i.mainLight.environmentStrength,r),this._mainLight.specularStrength=ge(e.mainLight.specularStrength,i.mainLight.specularStrength,r),Z(this._mainLight.direction,i.mainLight.direction),this._mainLight.castShadows=i.mainLight.castShadows,this.globalFactor=ge(e.globalFactor,i.globalFactor,r),this.noonFactor=ge(e.noonFactor,i.noonFactor,r),e.sh.r.length===i.sh.r.length)for(let s=0;s<i.sh.r.length;s++)this._sphericalHarmonics.r[s]=ge(e.sh.r[s],i.sh.r[s],r),this._sphericalHarmonics.g[s]=ge(e.sh.g[s],i.sh.g[s],r),this._sphericalHarmonics.b[s]=ge(e.sh.b[s],i.sh.b[s],r);else for(let s=0;s<i.sh.r.length;s++)this._sphericalHarmonics.r[s]=i.sh.r[s],this._sphericalHarmonics.g[s]=i.sh.g[s],this._sphericalHarmonics.b[s]=i.sh.b[s];this.updateLegacy()}};const Ki=g();function cm(t){t.code.add(h`float mapChannel(float x, vec2 p) {
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`),t.code.add(h`vec3 blackLevelSoftCompression(vec3 color, float averageAmbientRadiance) {
vec2 p = vec2(0.02, 0.0075) * averageAmbientRadiance;
return vec3(mapChannel(color.x, p), mapChannel(color.y, p), mapChannel(color.z, p));
}`)}function um(t){t.code.add(h`vec3 tonemapACES(vec3 x) {
return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}`)}function Ks(t){t.constants.add("ambientBoostFactor","float",ll)}function Js(t){t.uniforms.add(new bt("lightingGlobalFactor",e=>e.lighting.globalFactor))}function cl(t,e){const i=t.fragment,{pbrMode:r,spherical:s,hasColorTexture:n}=e;i.include(Xs,e),r!==0&&i.include(Zs,e),t.include(Zp,e),i.include(Ys),i.include(um,e);const a=!(r===2&&!n);switch(a&&i.include(cm),i.code.add(h`
    const float GAMMA_SRGB = ${h.float(yu)};
    const float INV_GAMMA_SRGB = 0.4761904;
    ${G(r!==0,"const float GROUND_REFLECTANCE = 0.2;")}
  `),Ks(i),Js(i),Tr(i),i.code.add(h`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${s?h`normalize(vPosWorld)`:h`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `),Fi(i),i.code.add(h`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`),r){case 0:case 4:case 3:t.include(Kp),i.code.add(h`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {
vec3 mainLighting = applyShading(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);break;case 1:case 2:i.code.add(h`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight,
vec3 viewDir, vec3 groundNormal, vec3 mrr, float additionalAmbientIrradiance) {
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotNG = clamp(dot(normal, groundNormal), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, groundNormal), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),i.code.add(h`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),e.useFillLights?i.uniforms.add(new Tf("hasFillLights",l=>l.enableFillLights)):i.constants.add("hasFillLights","bool",!1),i.code.add(h`vec3 ambientDir = vec3(5.0 * groundNormal[1] - groundNormal[0] * groundNormal[2], - 5.0 * groundNormal[0] - groundNormal[2] * groundNormal[1], groundNormal[1] * groundNormal[1] + groundNormal[0] * groundNormal[0]);
ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
float NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
vec3 mainLightIrradianceComponent = NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),i.uniforms.add(new bt("lightingSpecularStrength",l=>l.lighting.mainLight.specularStrength),new bt("lightingEnvironmentStrength",l=>l.lighting.mainLight.environmentStrength)).code.add(h`vec3 horizonRingDir = inputs.RdotNG * groundNormal - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
float NdotH = clamp(dot(normal, h), 0.0, 1.0);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
float normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));
inputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE);`),i.code.add(h`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent;
        ${a?h`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:h`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);break;case 5:case 6:Tr(i),Fi(i),i.code.add(h`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`)}}function hm(t,e){const i=t.fragment;switch(i.code.add(h`struct ShadingNormalParameters {
vec3 normalView;
vec3 viewDirection;
} shadingParams;`),e.doubleSidedMode){case 0:i.code.add(h`vec3 shadingNormal(ShadingNormalParameters params) {
return normalize(params.normalView);
}`);break;case 1:i.code.add(h`vec3 shadingNormal(ShadingNormalParameters params) {
return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);
}`);break;case 2:i.code.add(h`vec3 shadingNormal(ShadingNormalParameters params) {
return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);
}`);break;default:Is(e.doubleSidedMode);case 3:}}function ul(t,e){const i=e.pbrMode,r=t.fragment;if(i!==2&&i!==0&&i!==1)return void r.code.add(h`void applyPBRFactors() {}`);if(i===0)return void r.code.add(h`void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);if(i===2)return void r.code.add(h`vec3 mrr = vec3(0.0, 0.6, 0.2);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);const{hasMetallicRoughnessTexture:s,hasMetallicRoughnessTextureTransform:n,hasOcclusionTexture:a,hasOcclusionTextureTransform:l,bindType:o}=e;(s||a)&&t.include($a,e),r.code.add(h`vec3 mrr;
float occlusion;`),s&&r.uniforms.add(o===1?new Ee("texMetallicRoughness",c=>c.textureMetallicRoughness):new dr("texMetallicRoughness",c=>c.textureMetallicRoughness)),a&&r.uniforms.add(o===1?new Ee("texOcclusion",c=>c.textureOcclusion):new dr("texOcclusion",c=>c.textureOcclusion)),r.uniforms.add(o===1?new ue("mrrFactors",c=>c.mrrFactors):new ze("mrrFactors",c=>c.mrrFactors)),r.code.add(h`
    ${G(s,h`void applyMetallicRoughness(vec2 uv) {
            vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
            mrr[0] *= metallicRoughness.b;
            mrr[1] *= metallicRoughness.g;
          }`)}

    ${G(a,"void applyOcclusion(vec2 uv) { occlusion *= textureLookup(texOcclusion, uv).r; }")}

    float getBakedOcclusion() {
      return ${a?"occlusion":"1.0"};
    }

    void applyPBRFactors() {
      mrr = mrrFactors;
      occlusion = 1.0;

      ${G(s,`applyMetallicRoughness(${n?"metallicRoughnessUV":"vuv0"});`)}
      ${G(a,`applyOcclusion(${l?"occlusionUV":"vuv0"});`)}
    }
  `)}function dm(t,e){const i=Ot(e.output)&&e.receiveShadows;i&&Ko(t,!0),t.vertex.code.add(h`
    void forwardLinearDepthToReadShadowMap() { ${G(i,"forwardLinearDepth(gl_Position.w);")} }
  `)}let fm=class extends ie{constructor(e,i,r,s){super(e,"mat4",2,(n,a,l,o)=>n.setUniformMatrices4fv(e,i(a,l,o),s),r)}},pm=class extends ie{constructor(e,i,r,s){super(e,"mat4",1,(n,a,l)=>n.setUniformMatrices4fv(e,i(a,l),s),r)}};function mm(t){t.fragment.uniforms.add(new pm("shadowMapMatrix",(e,i)=>i.shadowMap.getShadowMapMatrices(e.origin),4)),hl(t)}function gm(t){t.fragment.uniforms.add(new fm("shadowMapMatrix",(e,i)=>i.shadowMap.getShadowMapMatrices(e.origin),4)),hl(t)}function hl(t){const{fragment:e}=t;e.uniforms.add(new Pe("cascadeDistances",i=>i.shadowMap.cascadeDistances),new Do("numCascades",i=>i.shadowMap.numCascades)),e.code.add(h`const vec3 invalidShadowmapUVZ = vec3(0.0, 0.0, -1.0);
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
vec3 calculateUVZShadow(in vec3 _worldPos, in float _linearDepth, in ivec2 shadowMapSize) {
int i = _linearDepth < cascadeDistances[1] ? 0 : _linearDepth < cascadeDistances[2] ? 1 : _linearDepth < cascadeDistances[3] ? 2 : 3;
if (i >= numCascades) {
return invalidShadowmapUVZ;
}
mat4 shadowMatrix = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
vec3 lvpos = lightSpacePosition(_worldPos, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
return invalidShadowmapUVZ;
}
vec2 uvShadow = cascadeCoordinates(i, shadowMapSize, lvpos);
return vec3(uvShadow, lvpos.z);
}`)}function vm(t){t.fragment.code.add(h`float readShadowMapUVZ(vec3 uvzShadow, sampler2DShadow _shadowMap) {
return texture(_shadowMap, uvzShadow);
}`)}let _m=class extends ie{constructor(e,i){super(e,"sampler2DShadow",0,(r,s)=>r.bindTexture(e,i(s)))}},vx=class extends Ve{constructor(){super(...arguments),this.origin=g()}};function dl(t,e){e.receiveShadows&&t.include(mm),pl(t,e)}function fl(t,e){e.receiveShadows&&t.include(gm),pl(t,e)}function pl(t,e){t.fragment.uniforms.add(new bt("lightingGlobalFactor",s=>s.lighting.globalFactor));const{receiveShadows:i,spherical:r}=e;t.include(dm,e),i&&xm(t),t.fragment.code.add(h`
    float readShadow(float additionalAmbientScale, vec3 vpos) {
      return ${i?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))":G(r,"lightingGlobalFactor * (1.0 - additionalAmbientScale)","0.0")};
    }
  `)}function xm(t){t.include(vm),t.fragment.uniforms.add(new _m("shadowMap",({shadowMap:e})=>e.depthTexture)).code.add(h`float readShadowMap(const in vec3 _worldPos, float _linearDepth) {
vec3 uvzShadow = calculateUVZShadow(_worldPos, _linearDepth, textureSize(shadowMap,0));
if (uvzShadow.z < 0.0) {
return 0.0;
}
return readShadowMapUVZ(uvzShadow, shadowMap);
}`)}function bm(t,e){e.hasColorTextureTransform?(t.varyings.add("colorUV","vec2"),t.vertex.uniforms.add(new Ye("colorTextureTransformMatrix",i=>i.colorTextureTransformMatrix??ai)).code.add(h`void forwardColorUV(){
colorUV = (colorTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)):t.vertex.code.add(h`void forwardColorUV(){}`)}function ym(t,e){e.hasNormalTextureTransform&&e.textureCoordinateType!==0?(t.varyings.add("normalUV","vec2"),t.vertex.uniforms.add(new Ye("normalTextureTransformMatrix",i=>i.normalTextureTransformMatrix??ai)).code.add(h`void forwardNormalUV(){
normalUV = (normalTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)):t.vertex.code.add(h`void forwardNormalUV(){}`)}function wm(t,e){e.hasEmissionTextureTransform&&e.textureCoordinateType!==0?(t.varyings.add("emissiveUV","vec2"),t.vertex.uniforms.add(new Ye("emissiveTextureTransformMatrix",i=>i.emissiveTextureTransformMatrix??ai)).code.add(h`void forwardEmissiveUV(){
emissiveUV = (emissiveTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)):t.vertex.code.add(h`void forwardEmissiveUV(){}`)}function Tm(t,e){e.hasOcclusionTextureTransform&&e.textureCoordinateType!==0?(t.varyings.add("occlusionUV","vec2"),t.vertex.uniforms.add(new Ye("occlusionTextureTransformMatrix",i=>i.occlusionTextureTransformMatrix??ai)).code.add(h`void forwardOcclusionUV(){
occlusionUV = (occlusionTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)):t.vertex.code.add(h`void forwardOcclusionUV(){}`)}function Mm(t,e){e.hasMetallicRoughnessTextureTransform&&e.textureCoordinateType!==0?(t.varyings.add("metallicRoughnessUV","vec2"),t.vertex.uniforms.add(new Ye("metallicRoughnessTextureTransformMatrix",i=>i.metallicRoughnessTextureTransformMatrix??ai)).code.add(h`void forwardMetallicRoughnessUV(){
metallicRoughnessUV = (metallicRoughnessTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)):t.vertex.code.add(h`void forwardMetallicRoughnessUV(){}`)}function ml(t){t.include(Lo),t.code.add(h`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${h.int(1)}) {
        return allMixed;
      }
      if (mode == ${h.int(2)}) {
        return internalMixed;
      }
      if (mode == ${h.int(3)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${h.int(2)}) {
        return internalMixed;
      }
      if (mode == ${h.int(3)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `)}function gl(t,e){e.snowCover&&(t.uniforms.add(new bt("snowCover",i=>i.snowCover)).code.add(h`float getSnow(vec3 normal, vec3 groundNormal) {
return smoothstep(0.5, 0.55, dot(normal, groundNormal)) * snowCover;
}
float getRealisticTreeSnow(vec3 faceNormal, vec3 shadingNormal, vec3 groundNormal) {
float snow = min(1.0, smoothstep(0.5, 0.55, dot(faceNormal, groundNormal)) +
smoothstep(0.5, 0.55, dot(-faceNormal, groundNormal)) +
smoothstep(0.0, 0.1, dot(shadingNormal, groundNormal)));
return snow * snowCover;
}`),t.code.add(h`vec3 applySnowToMRR(vec3 mrr, float snow) {
return mix(mrr, vec3(0.0, 1.0, 0.04), snow);
}`))}function vl(t,e){t.include(zo,e),t.include(bc,e),t.fragment.include(Lo);const{output:i,oitPass:r,discardInvisibleFragments:s,snowCover:n}=e,a=i===10,l=Sa(i),o=Ot(i)&&r===1,c=Ot(i)&&r!==1;let u=0;(c||l||o)&&t.outputs.add("fragColor","vec4",u++),l&&t.outputs.add("fragEmission","vec4",u++),o&&t.outputs.add("fragAlpha","float",u++),t.fragment.code.add(h`
    void outputColorHighlightOID(vec4 finalColor, const in vec3 vWorldPosition, vec3 emissiveSymbolColor ${G(n,", float snow")}) {
      ${G(a,"finalColor.a = 1.0;")}

      ${G(s,`if (finalColor.a < ${h.float(oi)}) { discard; }`)}

      finalColor = applySlice(finalColor, vWorldPosition);
      ${G(o,h`fragColor = premultiplyAlpha(finalColor);
             fragAlpha = finalColor.a;`)}
      ${G(c,"fragColor = finalColor;")}
      ${G(l,`fragEmission = ${G(n,"mix(finalColor.a * getEmissions(emissiveSymbolColor), vec4(0.0), snow);","finalColor.a * getEmissions(emissiveSymbolColor);")}`)}
      calculateOcclusionAndOutputHighlight();
      ${G(a,"outputObjectAndLayerIdColor();")}
    }
  `)}function Sm(t){const e=new Ir,{attributes:i,vertex:r,fragment:s,varyings:n}=e,{output:a,normalType:l,offsetBackfaces:o,spherical:c,snowCover:u,pbrMode:d,textureAlphaPremultiplied:m,instancedDoublePrecision:v,hasVertexColors:p,hasVertexTangents:_,hasColorTexture:b,hasNormalTexture:y,hasNormalTextureTransform:M,hasColorTextureTransform:w}=t;if(Xt(r,t),i.add("position","vec3"),n.add("vpos","vec3",{invariant:!0}),e.include(Mi,t),e.include(tl,t),e.include(Co,t),e.include(bm,t),!Ot(a))return e.include(nl,t),e;e.include(ym,t),e.include(wm,t),e.include(Tm,t),e.include(Mm,t),Ai(r,t),e.include(Lr,t),e.include(Kt);const S=l===0||l===1;return S&&o&&e.include(Zo),e.include(Pp,t),e.include(Xo,t),e.include(el,t),n.add("vPositionLocal","vec3"),e.include(kt,t),e.include(il,t),e.include(rl,t),r.uniforms.add(new Pr("externalColor",I=>I.externalColor,{supportsNaN:!0})),n.add("vcolorExt","vec4"),e.include(Po,t),r.include(Tt),r.include(ks),e.include(v?dl:fl,t),r.main.add(h`
    forwardNormalizedVertexColor();

    MaskedColor maskedColor =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColor.color;
    forwardColorMixMode(maskedColor.mask);

    vpos = getVertexInLocalOriginSpace();
    vPositionLocal = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    ${G(S,"vNormalWorld = dpNormal(vvLocalNormal(normalModel()));")}
    vpos = addVerticalOffset(vpos, localOrigin);
    ${G(_,"vTangent = dpTransformVertexTangent(tangent);")}
    gl_Position = transformPosition(proj, view, vpos);
    ${G(S&&o,"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardColorUV();
    forwardNormalUV();
    forwardEmissiveUV();
    forwardOcclusionUV();
    forwardMetallicRoughnessUV();

    if (opacityMixMode != ${h.int(Ti.ignore)} && vcolorExt.a < ${h.float(oi)}) {
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
    }
    forwardLinearDepthToReadShadowMap();
  `),e.include(cl,t),s.include(Xs,t),e.include(Qt,t),s.include(Zt,t),e.include(vl,t),Ai(s,t),s.uniforms.add(r.uniforms.get("localOrigin"),new ue("ambient",I=>I.ambient),new ue("diffuse",I=>I.diffuse),new xt("opacity",I=>I.opacity),new xt("layerOpacity",I=>I.layerOpacity)),b&&s.uniforms.add(new Ee("tex",I=>I.texture)),e.include(ul,t),s.include(Zs,t),s.include(ml),e.include(hm,t),s.include(gl,t),Ks(s),Js(s),Fi(s),s.main.add(h`
    discardBySlice(vpos);
    discardByTerrainDepth();
    ${b?h`
            vec4 texColor = texture(tex, ${w?"colorUV":"vuv0"});
            ${G(m,"texColor.rgb /= texColor.a;")}
            discardOrAdjustAlpha(texColor);`:h`vec4 texColor = vec4(1.0);`}
    shadingParams.viewDirection = normalize(vpos - cameraPosition);
    ${l===2?h`vec3 normal = screenDerivativeNormal(vPositionLocal);`:h`shadingParams.normalView = vNormalWorld;
                vec3 normal = shadingNormal(shadingParams);`}
    applyPBRFactors();
    float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

    vec3 posWorld = vpos + localOrigin;

    float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
    float shadow = readShadow(additionalAmbientScale, vpos);

    vec3 matColor = max(ambient, diffuse);
    vec3 albedo = mixExternalColor(${G(p,"vColor.rgb *")} matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
    float opacity_ = layerOpacity * mixExternalOpacity(${G(p,"vColor.a * ")} opacity, texColor.a, vcolorExt.a, opacityMixMode);

    ${y?`mat3 tangentSpace = computeTangentSpace(${_?"normal":"normal, vpos, vuv0"});
            vec3 shadingNormal = computeTextureNormal(tangentSpace, ${M?"normalUV":"vuv0"});`:"vec3 shadingNormal = normal;"}
    vec3 normalGround = ${c?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

    ${G(u,h`
          float snow = getSnow(normal, normalGround);
          albedo = mix(albedo, vec3(1), snow);
          shadingNormal = mix(shadingNormal, normal, snow);
          ssao = mix(ssao, 1.0, snow);`)}

    vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

    ${d===1||d===2?h`
            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${G(u,"mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, additionalAmbientIrradiance);`:h`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
    vec4 finalColor = vec4(shadedColor, opacity_);
    outputColorHighlightOID(finalColor, vpos, albedo ${G(u,", snow")});
  `),e}const $m=Object.freeze(Object.defineProperty({__proto__:null,build:Sm},Symbol.toStringTag,{value:"Module"}));let Cm=class extends gp{constructor(){super(...arguments),this.isSchematic=!1,this.usePBR=!1,this.mrrFactors=Ep,this.hasVertexColors=!1,this.hasSymbolColors=!1,this.doubleSided=!1,this.doubleSidedType="normal",this.cullFace=2,this.instanced=!1,this.instancedFeatureAttribute=!1,this.instancedColor=!1,this.instanceColorEncodesAlphaIgnore=!1,this.emissiveStrength=0,this.emissiveSource=1,this.emissiveBaseColor=ot,this.instancedDoublePrecision=!1,this.normalType=0,this.receiveShadows=!0,this.receiveAmbientOcclusion=!0,this.castShadows=!0,this.ambient=Ci(.2,.2,.2),this.diffuse=Ci(.8,.8,.8),this.externalColor=ps(1,1,1,1),this.colorMixMode="multiply",this.opacity=1,this.layerOpacity=1,this.origin=g(),this.hasSlicePlane=!1,this.offsetTransparentBackfaces=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.modelTransformation=null,this.drivenOpacity=!1,this.writeDepth=!0,this.customDepthTest=0,this.textureAlphaMode=0,this.textureAlphaCutoff=oi,this.textureAlphaPremultiplied=!1,this.renderOccluded=1,this.isDecoration=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}},bx=class extends vp{constructor(){super(...arguments),this.origin=g(),this.slicePlaneLocalOrigin=this.origin}};class _l extends Ns{constructor(e,i,r=new Ar($m,()=>Oi(()=>import("./RealisticTree.glsl-IWCjmMLr.js").then(s=>s.aq),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66])))){const s=[ms(xl(i))];i.instanced&&i.instancedDoublePrecision&&s.push(ms(Cp(i))),super(e,i,r,bu(s))}_makePipeline(e,i){const{oitPass:r,output:s,transparent:n,cullFace:a,customDepthTest:l,hasOccludees:o}=e;return Or({blending:Ot(s)&&n?Rf(r):null,culling:Im(e)?Xh(a):null,depthTest:{func:Nf(r,Em(l))},depthWrite:Of(e),drawBuffers:vd(s,Lf(r,s)),colorWrite:Rr,stencilWrite:o?_p:null,stencilTest:o?i?bp:xp:null,polygonOffset:zf(e)})}initializePipeline(e){return this._occludeePipelineState=this._makePipeline(e,!0),this._makePipeline(e,!1)}getPipeline(e){return e?this._occludeePipelineState:super.getPipeline()}}function Em(t){switch(t){case 1:return 515;case 0:case 3:return 513;case 2:return 516}}function Im(t){return t.cullFace!==0||!t.hasSlicePlane&&!t.transparent&&!t.doubleSidedMode}function xl(t){const e=As().vec3f("position");return t.normalType===1?e.vec2i16("normalCompressed",{glNormalized:!0}):e.vec3f("normal"),t.hasVertexTangents&&e.vec4f("tangent"),t.hasTextures&&e.vec2f16("uv0"),t.hasVertexColors&&e.vec4u8("color"),t.hasSymbolColors&&e.vec4u8("symbolColor"),!t.instanced&&Vs()&&e.vec4u8("olidColor"),e}let H=class extends Yt{constructor(e){super(),this.spherical=e,this.alphaDiscardMode=1,this.doubleSidedMode=0,this.pbrMode=0,this.cullFace=0,this.normalType=0,this.customDepthTest=0,this.emissionSource=0,this.hasVertexColors=!1,this.hasSymbolColors=!1,this.hasVerticalOffset=!1,this.hasColorTexture=!1,this.hasMetallicRoughnessTexture=!1,this.hasOcclusionTexture=!1,this.hasNormalTexture=!1,this.hasScreenSizePerspective=!1,this.hasVertexTangents=!1,this.hasOccludees=!1,this.instanced=!1,this.instancedDoublePrecision=!1,this.hasModelTransformation=!1,this.offsetBackfaces=!1,this.hasVVSize=!1,this.hasVVColor=!1,this.receiveShadows=!1,this.receiveAmbientOcclusion=!1,this.textureAlphaPremultiplied=!1,this.instancedFeatureAttribute=!1,this.instancedColor=!1,this.writeDepth=!0,this.transparent=!1,this.enableOffset=!0,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.snowCover=!1,this.hasColorTextureTransform=!1,this.hasEmissionTextureTransform=!1,this.hasNormalTextureTransform=!1,this.hasOcclusionTextureTransform=!1,this.hasMetallicRoughnessTextureTransform=!1,this.occlusionPass=!1,this.useCustomDTRExponentForWater=!1,this.useFillLights=!0,this.draped=!1}get textureCoordinateType(){return this.hasTextures?1:0}get hasTextures(){return this.hasColorTexture||this.hasNormalTexture||this.hasMetallicRoughnessTexture||this.emissionSource===3||this.hasOcclusionTexture}get hasVVInstancing(){return this.instanced}get discardInvisibleFragments(){return this.transparent}};f([L({count:4})],H.prototype,"alphaDiscardMode",void 0),f([L({count:3})],H.prototype,"doubleSidedMode",void 0),f([L({count:7})],H.prototype,"pbrMode",void 0),f([L({count:3})],H.prototype,"cullFace",void 0),f([L({count:3})],H.prototype,"normalType",void 0),f([L({count:3})],H.prototype,"customDepthTest",void 0),f([L({count:8})],H.prototype,"emissionSource",void 0),f([L()],H.prototype,"hasVertexColors",void 0),f([L()],H.prototype,"hasSymbolColors",void 0),f([L()],H.prototype,"hasVerticalOffset",void 0),f([L()],H.prototype,"hasColorTexture",void 0),f([L()],H.prototype,"hasMetallicRoughnessTexture",void 0),f([L()],H.prototype,"hasOcclusionTexture",void 0),f([L()],H.prototype,"hasNormalTexture",void 0),f([L()],H.prototype,"hasScreenSizePerspective",void 0),f([L()],H.prototype,"hasVertexTangents",void 0),f([L()],H.prototype,"hasOccludees",void 0),f([L()],H.prototype,"instanced",void 0),f([L()],H.prototype,"instancedDoublePrecision",void 0),f([L()],H.prototype,"hasModelTransformation",void 0),f([L()],H.prototype,"offsetBackfaces",void 0),f([L()],H.prototype,"hasVVSize",void 0),f([L()],H.prototype,"hasVVColor",void 0),f([L()],H.prototype,"receiveShadows",void 0),f([L()],H.prototype,"receiveAmbientOcclusion",void 0),f([L()],H.prototype,"textureAlphaPremultiplied",void 0),f([L()],H.prototype,"instancedFeatureAttribute",void 0),f([L()],H.prototype,"instancedColor",void 0),f([L()],H.prototype,"writeDepth",void 0),f([L()],H.prototype,"transparent",void 0),f([L()],H.prototype,"enableOffset",void 0),f([L()],H.prototype,"terrainDepthTest",void 0),f([L()],H.prototype,"cullAboveTerrain",void 0),f([L()],H.prototype,"snowCover",void 0),f([L()],H.prototype,"hasColorTextureTransform",void 0),f([L()],H.prototype,"hasEmissionTextureTransform",void 0),f([L()],H.prototype,"hasNormalTextureTransform",void 0),f([L()],H.prototype,"hasOcclusionTextureTransform",void 0),f([L()],H.prototype,"hasMetallicRoughnessTextureTransform",void 0);function Am(t){const e=new Ir,{attributes:i,vertex:r,fragment:s,varyings:n}=e,{output:a,offsetBackfaces:l,pbrMode:o,snowCover:c,spherical:u}=t,d=o===1||o===2;if(Xt(r,t),i.add("position","vec3"),n.add("vpos","vec3",{invariant:!0}),e.include(Mi,t),e.include(tl,t),e.include(Co,t),e.include(Po,t),!Ot(a))return e.include(nl,t),e;Ai(e.vertex,t),e.include(Lr,t),e.include(Kt),l&&e.include(Zo),n.add("vNormalWorld","vec3"),n.add("localvpos","vec3",{invariant:!0}),e.include(kt,t),e.include(il,t),e.include(el,t),e.include(rl,t),r.include(Tt),r.include(ks),r.uniforms.add(new Pr("externalColor",p=>p.externalColor,{supportsNaN:!0})),n.add("vcolorExt","vec4"),e.include(t.instancedDoublePrecision?dl:fl,t),r.main.add(h`
    forwardNormalizedVertexColor();

    MaskedColor maskedColorExt =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColorExt.color;
    forwardColorMixMode(maskedColorExt.mask);

    bool alphaCut = opacityMixMode != ${h.int(Ti.ignore)} && vcolorExt.a < ${h.float(oi)};
    vpos = getVertexInLocalOriginSpace();

    localvpos = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
    vpos = addVerticalOffset(vpos, localOrigin);
    vec4 basePosition = transformPosition(proj, view, vpos);

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardLinearDepthToReadShadowMap();
    gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
    ${G(l,"offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);","basePosition;")}
  `);const{hasColorTexture:m,hasColorTextureTransform:v}=t;return e.include(cl,t),s.include(Xs,t),e.include(Qt,t),s.include(Zt,t),e.include(vl,t),Ai(s,t),Tr(s),Ks(s),Js(s),s.uniforms.add(r.uniforms.get("localOrigin"),r.uniforms.get("view"),new ue("ambient",p=>p.ambient),new ue("diffuse",p=>p.diffuse),new xt("opacity",p=>p.opacity),new xt("layerOpacity",p=>p.layerOpacity)),m&&s.uniforms.add(new Ee("tex",p=>p.texture)),e.include(ul,t),s.include(Zs,t),s.include(ml),s.include(gl,t),Fi(s),s.main.add(h`
      discardBySlice(vpos);
      discardByTerrainDepth();
      vec4 texColor = ${m?`texture(tex, ${v?"colorUV":"vuv0"})`:" vec4(1.0)"};
      ${G(m,`${G(t.textureAlphaPremultiplied,"texColor.rgb /= texColor.a;")}
        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = readShadow(additionalAmbientScale, vpos);
      vec3 matColor = max(ambient, diffuse);
      ${t.hasVertexColors?h`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, opacityMixMode);`:h`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, opacityMixMode);`}

      vec3 shadingNormal = normalize(vNormalWorld);
      vec3 groundNormal = ${u?"normalize(vpos + localOrigin)":"vec3(0.0, 0.0, 1.0)"};

      ${G(c,`vec3 faceNormal = screenDerivativeNormal(vpos);
         float snow = getRealisticTreeSnow(faceNormal, shadingNormal, groundNormal);
         albedo = mix(albedo, vec3(1), snow);`)}

      ${h`albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}

      ${d?h`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${G(c,"mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, groundNormal, mrr, additionalAmbientIrradiance);`:h`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos, albedo ${G(c,", 1.0")});`),e}const Fm=Object.freeze(Object.defineProperty({__proto__:null,build:Am},Symbol.toStringTag,{value:"Module"}));let Rm=class extends _l{constructor(e,i){super(e,i,new Ar(Fm,()=>Oi(()=>import("./RealisticTree.glsl-IWCjmMLr.js").then(r=>r.ar),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]))))}};class Mx extends uf{constructor(e,i){super(e,Pm),this.materialType="default",this.supportsEdges=!0,this.intersectDraped=void 0,this.produces=new Map([[2,r=>(jr(r)||tr(r))&&!this.transparent],[4,r=>(jr(r)||tr(r))&&this.transparent&&this.parameters.writeDepth],[8,r=>(jr(r)||tr(r))&&this.transparent&&!this.parameters.writeDepth]]),this._layout=xl(this.parameters),this._configuration=new H(i.spherical)}isVisibleForOutput(e){return e!==4&&e!==6&&e!==5||this.parameters.castShadows}get visible(){const{layerOpacity:e,colorMixMode:i,opacity:r,externalColor:s}=this.parameters;return e*(i==="replace"?1:r)*(i==="ignore"||isNaN(s[3])?1:s[3])>=oi}get _hasEmissiveBase(){return!!this.parameters.emissiveTextureId||!We(this.parameters.emissiveBaseColor,ot)}get hasEmissions(){return this.parameters.emissiveStrength>0&&(this.parameters.emissiveSource===0&&this._hasEmissiveBase||this.parameters.emissiveSource===1)}getConfiguration(e,i){const{parameters:r,_configuration:s}=this,{treeRendering:n,doubleSided:a,doubleSidedType:l}=r;return super.getConfiguration(e,i,this._configuration),s.hasNormalTexture=r.hasNormalTexture,s.hasColorTexture=r.hasColorTexture,s.hasMetallicRoughnessTexture=r.hasMetallicRoughnessTexture,s.hasOcclusionTexture=r.hasOcclusionTexture,s.hasVertexTangents=!n&&r.hasVertexTangents,s.instanced=r.instanced,s.instancedDoublePrecision=r.instancedDoublePrecision,s.hasVVColor=!!r.vvColor,s.hasVVSize=!!r.vvSize,s.hasVerticalOffset=r.verticalOffset!=null,s.hasScreenSizePerspective=r.screenSizePerspective!=null,s.hasSlicePlane=r.hasSlicePlane,s.alphaDiscardMode=r.textureAlphaMode,s.normalType=n?0:r.normalType,s.transparent=this.transparent,s.writeDepth=r.writeDepth,s.customDepthTest=r.customDepthTest??0,s.hasOccludees=i.hasOccludees,s.cullFace=r.hasSlicePlane?0:r.cullFace,s.cullAboveTerrain=i.cullAboveTerrain,s.hasModelTransformation=!n&&r.modelTransformation!=null,s.hasVertexColors=r.hasVertexColors,s.hasSymbolColors=r.hasSymbolColors,s.doubleSidedMode=n?2:a&&l==="normal"?1:a&&l==="winding-order"?2:0,s.instancedFeatureAttribute=r.instancedFeatureAttribute,s.instancedColor=r.instancedColor,Ot(e)?(s.terrainDepthTest=i.terrainDepthTest,s.receiveShadows=r.receiveShadows,s.receiveAmbientOcclusion=r.receiveAmbientOcclusion&&i.ssao!=null):(s.terrainDepthTest=!1,s.receiveShadows=s.receiveAmbientOcclusion=!1),s.textureAlphaPremultiplied=!!r.textureAlphaPremultiplied,s.pbrMode=r.usePBR?r.isSchematic?2:1:0,s.emissionSource=r.emissionSource,s.offsetBackfaces=!(!this.transparent||!r.offsetTransparentBackfaces),s.oitPass=i.oitPass,s.enableOffset=i.camera.relativeElevation<Pf,s.snowCover=i.snowCover>0,s.hasColorTextureTransform=!!r.colorTextureTransformMatrix,s.hasNormalTextureTransform=!!r.normalTextureTransformMatrix,s.hasEmissionTextureTransform=!!r.emissiveTextureTransformMatrix,s.hasOcclusionTextureTransform=!!r.occlusionTextureTransformMatrix,s.hasMetallicRoughnessTextureTransform=!!r.metallicRoughnessTextureTransformMatrix,s}intersect(e,i,r,s,n,a){if(this.parameters.verticalOffset!=null){const l=r.camera;U(cs,i[12],i[13],i[14]);let o=null;switch(r.viewingMode){case 1:o=Te(ca,cs);break;case 2:o=Z(ca,Lm)}let c=0;const u=ce(Vm,cs,l.eye),d=te(u),m=q(u,u,1/d);let v=null;this.parameters.screenSizePerspective&&(v=we(o,m)),c+=lf(l,d,this.parameters.verticalOffset,v??0,this.parameters.screenSizePerspective,null),q(o,o,c),Il(ls,o,r.transform.inverseRotation),s=ce(zm,s,ls),n=ce(Nm,n,ls)}Kf(e,r,s,n,ys(r.verticalOffset),a)}createGLMaterial(e){return new Om(e)}createBufferWriter(){return new hp(this._layout)}get transparent(){return Dm(this.parameters)}}let Om=class extends sf{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){this._material.setParameters({receiveShadows:e.shadowMap.enabled});const i=this._material.parameters;this.updateTexture(i.textureId);const r=e.camera.viewInverseTransposeMatrix;return U(i.origin,r[3],r[7],r[11]),this._material.setParameters(this.textureBindParameters),this.getTechnique(i.treeRendering?Rm:_l,e)}},Pm=class extends Cm{constructor(){super(...arguments),this.treeRendering=!1,this.hasVertexTangents=!1}get hasNormalTexture(){return!this.treeRendering&&!!this.normalTextureId}get hasColorTexture(){return!!this.textureId}get hasMetallicRoughnessTexture(){return!this.treeRendering&&!!this.metallicRoughnessTextureId}get hasOcclusionTexture(){return!this.treeRendering&&!!this.occlusionTextureId}get emissionSource(){return this.treeRendering?0:this.emissiveTextureId!=null&&this.emissiveSource===0?3:this.usePBR?this.emissiveSource===0?2:1:0}get hasTextures(){return this.hasColorTexture||this.hasNormalTexture||this.hasMetallicRoughnessTexture||this.emissionSource===3||this.hasOcclusionTexture}};function Dm(t){const{drivenOpacity:e,opacity:i,externalColor:r,layerOpacity:s,texture:n,textureId:a,textureAlphaMode:l,colorMixMode:o}=t,c=r[3];return e||i<1&&o!=="replace"||c<1&&o!=="ignore"||s<1||(n!=null||a!=null)&&l!==1&&l!==2&&o!=="replace"}const zm=g(),Nm=g(),Lm=ve(0,0,1),ca=g(),ls=g(),cs=g(),Vm=g(),_t=16;function ua(t,e){return e=Math.floor(e/_t)*_t,Math.min(Math.round(t/_t)*_t,e)}function Cx(t,e){return e=Math.floor(e/_t)*_t,Math.min(Math.ceil(t/_t)*_t,e)}function Bm(t,e){const[i,r]=Hm(t,e);return t.width===i&&t.height===r?t:bl(t,i,r)}function Hm({width:t,height:e},{maxPreferredTexturePixels:i,maxTextureSize:r}){const s=Math.max(t,e),n=t*e;if(s<=r&&n<=i)return[t,e];const a=Math.min(Math.sqrt(i/n),r/s);return[ua(Math.round(t*a),r),ua(Math.round(e*a),r)]}function bl(t,e,i){if(t instanceof ImageData)return bl(jm(t),e,i);const r=document.createElement("canvas");return r.width=e,r.height=i,r.getContext("2d").drawImage(t,0,0,r.width,r.height),r}function jm(t){const e=document.createElement("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");if(i==null)throw new Y("texture:context-failed","Failed to create 2d context from HTMLCanvasElement");return i.putImageData(t,0,0),e}async function Gm(t,e){const{data:i}=await du(t,{responseType:"image",...e});return i}function Um(){return ha??=(async()=>{const t=await Oi(()=>import("./basis_transcoder-DuG70Smz.js"),[]),e=await t.default({locateFile:i=>fu(`esri/libs/basisu/${i}`)});return e.initializeBasis(),e})(),ha}let ha,Ne=null,Ji=null;async function yl(){return Ji==null&&(Ji=Um(),Ne=await Ji),Ji}function Wm(t,e){if(Ne==null)return t.byteLength;const i=new Ne.BasisFile(new Uint8Array(t)),r=Tl(i)?wl(i.getNumLevels(0),i.getHasAlpha(),i.getImageWidth(0,0),i.getImageHeight(0,0),e):0;return i.close(),i.delete(),r}function km(t,e){if(Ne==null)return t.byteLength;const i=new Ne.KTX2File(new Uint8Array(t)),r=Ml(i)?wl(i.getLevels(),i.getHasAlpha(),i.getWidth(),i.getHeight(),e):0;return i.close(),i.delete(),r}function wl(t,e,i,r,s){const n=vo(e?Q.COMPRESSED_RGBA8_ETC2_EAC:Q.COMPRESSED_RGB8_ETC2),a=s&&t>1?(4**t-1)/(3*4**(t-1)):1;return Math.ceil(i*r*n*a)}function Tl(t){return t.getNumImages()>=1&&!t.isUASTC()}function Ml(t){return t.getFaces()>=1&&t.isETC1S()}async function qm(t,e,i){Ne==null&&(Ne=await yl());const r=new Ne.BasisFile(new Uint8Array(i));if(!Tl(r))return null;r.startTranscoding();const s=Sl(t,e,r.getNumLevels(0),r.getHasAlpha(),r.getImageWidth(0,0),r.getImageHeight(0,0),(n,a)=>r.getImageTranscodedSizeInBytes(0,n,a),(n,a,l)=>r.transcodeImage(l,0,n,a,0,0));return r.close(),r.delete(),s}async function Xm(t,e,i){Ne==null&&(Ne=await yl());const r=new Ne.KTX2File(new Uint8Array(i));if(!Ml(r))return null;r.startTranscoding();const s=Sl(t,e,r.getLevels(),r.getHasAlpha(),r.getWidth(),r.getHeight(),(n,a)=>r.getImageTranscodedSizeInBytes(n,0,0,a),(n,a,l)=>r.transcodeImage(l,n,0,0,a,0,-1,-1));return r.close(),r.delete(),s}function Sl(t,e,i,r,s,n,a,l){const{compressedTextureETC:o,compressedTextureS3TC:c}=t.capabilities,[u,d]=o?r?[1,Q.COMPRESSED_RGBA8_ETC2_EAC]:[0,Q.COMPRESSED_RGB8_ETC2]:c?r?[3,Q.COMPRESSED_RGBA_S3TC_DXT5_EXT]:[2,Q.COMPRESSED_RGB_S3TC_DXT1_EXT]:[13,6408],m=e.hasMipmap?i:Math.min(1,i),v=[];for(let p=0;p<m;p++)v.push(new Uint8Array(a(p,u))),l(p,u,v[p]);return e.internalFormat=d,e.hasMipmap=v.length>1,e.samplingMode=e.hasMipmap?9987:9729,e.width=s,e.height=n,new ti(t,e,{type:"compressed",levels:v})}const Qi=()=>yt.getLogger("esri.views.3d.webgl-engine.lib.DDSUtil"),Ym=542327876,Zm=131072,Km=4;function Qs(t){return t.charCodeAt(0)+(t.charCodeAt(1)<<8)+(t.charCodeAt(2)<<16)+(t.charCodeAt(3)<<24)}function Jm(t){return String.fromCharCode(255&t,t>>8&255,t>>16&255,t>>24&255)}const Qm=Qs("DXT1"),eg=Qs("DXT3"),tg=Qs("DXT5"),ig=31,rg=0,sg=1,ng=2,ag=3,og=4,lg=7,cg=20,ug=21;function hg(t,e,i){const r=dg(i,e.hasMipmap??!1);if(r==null)throw new Error("DDS texture data is null");const{textureData:s,internalFormat:n,width:a,height:l}=r;return e.samplingMode=s.levels.length>1?9987:9729,e.hasMipmap=s.levels.length>1,e.internalFormat=n,e.width=a,e.height=l,new ti(t,e,s)}function dg(t,e){const i=new Int32Array(t.buffer,t.byteOffset,ig);if(i[rg]!==Ym)return Qi().error("Invalid magic number in DDS header"),null;if(!(i[cg]&Km))return Qi().error("Unsupported format, must contain a FourCC code"),null;const r=i[ug];let s,n;switch(r){case Qm:s=8,n=Q.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case eg:s=16,n=Q.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case tg:s=16,n=Q.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;default:return Qi().error("Unsupported FourCC code:",Jm(r)),null}let a=1,l=i[og],o=i[ag];(3&l||3&o)&&(Qi().warn("Rounding up compressed texture size to nearest multiple of 4."),l=l+3&-4,o=o+3&-4);const c=l,u=o;let d,m;i[ng]&Zm&&e!==!1&&(a=Math.max(1,i[lg]));let v=t.byteOffset+i[sg]+4;const p=[];for(let _=0;_<a;++_)m=(l+3>>2)*(o+3>>2)*s,d=new Uint8Array(t.buffer,v,m),p.push(d),v+=m,l=Math.max(1,l>>1),o=Math.max(1,o>>1);return{textureData:{type:"compressed",levels:p},internalFormat:n,width:c,height:u}}let Ex=class{constructor(e,i){this._data=e,this.id=Cr(),this.events=new Pa,this._parameters={...pg,...i},this._startPreload(e)}dispose(){this.unload(),this._data=this.update=void 0}_startPreload(e){e instanceof HTMLVideoElement?(this.update=i=>this._update(e,i),this._startPreloadVideoElement(e)):e instanceof HTMLImageElement&&this._startPreloadImageElement(e)}_startPreloadVideoElement(e){if(!(yn(e.src)||e.preload==="auto"&&e.crossOrigin)&&(e.preload="auto",e.crossOrigin="anonymous",e.src=e.src,e.paused&&e.autoplay)){const i=[];wu(e,r=>i.push(r)).then(()=>{e.play()}).finally(()=>i.forEach(r=>r.remove()))}}_startPreloadImageElement(e){pu(e.src)||yn(e.src)||e.crossOrigin||(e.crossOrigin="anonymous",e.src=e.src)}_createDescriptor(e){const i=new Ls;return i.wrapMode=this._parameters.wrap??10497,i.flipped=!this._parameters.noUnpackFlip,i.samplingMode=this._parameters.mipmap?9987:9729,i.hasMipmap=!!this._parameters.mipmap,i.preMultiplyAlpha=!!this._parameters.preMultiplyAlpha,i.maxAnisotropy=this._parameters.maxAnisotropy??(this._parameters.mipmap?e.parameters.maxMaxAnisotropy:1),i.dataType=this._parameters.dataType??i.dataType,i.pixelFormat=this._parameters.pixelFormat??i.pixelFormat,i.internalFormat=this._parameters.internalFormat??i.internalFormat,i}get glTexture(){return this._glTexture??this._emptyTexture}get loaded(){return this._glTexture!=null}get usedMemory(){return this._glTexture?.usedMemory||fg(this._data,this._parameters)}load(e){if(this._loadingPromise)return this._loadingPromise;if(this._glTexture)return this._glTexture;const i=this._data;return i==null?(this._glTexture=new ti(e,this._createDescriptor(e),null),this._glTexture):(this._emptyTexture=e.emptyTexture,this._parameters.reloadable||(this._data=void 0),typeof i=="string"?this._loadFromURL(e,i):i instanceof Image?this._loadFromImageElement(e,i):i instanceof HTMLVideoElement?this._loadFromVideoElement(e,i):i instanceof ImageData||i instanceof HTMLCanvasElement?this._loadFromImage(e,i):xi(i)&&this._parameters.encoding==="image/vnd-ms.dds"?this._loadFromDDSData(e,i):vi(i)&&this._parameters.encoding==="image/vnd-ms.dds"?this._loadFromDDSData(e,new Uint8Array(i)):(vi(i)||xi(i))&&this._parameters.encoding==="image/ktx2"?this._loadFromKTX2(e,i):(vi(i)||xi(i))&&this._parameters.encoding==="image/x.basis"?this._loadFromBasis(e,i):vi(i)?this._loadFromPixelData(e,new Uint8Array(i)):Wl(i)?this._loadFromPixelData(e,i):null)}_update(e,i){return this._glTexture==null||e.readyState<HTMLMediaElement.HAVE_CURRENT_DATA||i===e.currentTime?i:(this._glTexture.setData(e),this._glTexture.descriptor.hasMipmap&&this._glTexture.generateMipmap(),this._parameters.updateCallback&&this._parameters.updateCallback(),e.currentTime)}_loadFromDDSData(e,i){return this._glTexture=hg(e,this._createDescriptor(e),i),this._emptyTexture=null,this._glTexture}_loadFromKTX2(e,i){return this._loadAsync(()=>Xm(e,this._createDescriptor(e),i).then(r=>(this._glTexture=r,r)))}_loadFromBasis(e,i){return this._loadAsync(()=>qm(e,this._createDescriptor(e),i).then(r=>(this._glTexture=r,r)))}_loadFromPixelData(e,i){W(this._parameters.width>0&&this._parameters.height>0);const r=this._createDescriptor(e);return r.pixelFormat!==6407&&r.pixelFormat!==6408||(r.compress=this._parameters.compressionOptions),r.width=this._parameters.width??0,r.height=this._parameters.height??0,this._glTexture=new ti(e,r,i),this._glTexture}_loadFromURL(e,i){return this._loadAsync(async r=>{const s=await Gm(i,{signal:r});return ur(r),this._loadFromImage(e,s)})}_loadFromImageElement(e,i){return i.complete?this._loadFromImage(e,i):this._loadAsync(async r=>{const s=await mu(i,i.src,!1,r);return ur(r),this._loadFromImage(e,s)})}_loadFromVideoElement(e,i){return i.readyState>=HTMLMediaElement.HAVE_CURRENT_DATA?this._loadFromImage(e,i):this._loadFromVideoElementAsync(e,i)}_loadFromVideoElementAsync(e,i){return this._loadAsync(r=>new Promise((s,n)=>{const a=()=>{i.removeEventListener("loadeddata",l),i.removeEventListener("error",o),Xl(c)},l=()=>{i.readyState>=HTMLMediaElement.HAVE_CURRENT_DATA&&(a(),s(this._loadFromImage(e,i)))},o=u=>{a(),n(u||new Y("texture:load-error","Failed to load video"))};i.addEventListener("loadeddata",l),i.addEventListener("error",o);const c=kl(r,()=>o(ql()))}))}_loadFromImage(e,i){let r=i;r instanceof HTMLVideoElement||(r=Bm(r,e.parameters));const s=$l(r);this._parameters.width=s.width,this._parameters.height=s.height;const n=this._createDescriptor(e);return n.width=s.width,n.height=s.height,n.compress=this._parameters.compressionOptions,this._glTexture=new ti(e,n,r),this._emptyTexture=null,this.events.emit("loaded"),this._glTexture}_loadAsync(e){const i=new AbortController;this._loadingController=i;const r=e(i.signal);this._loadingPromise=r;const s=()=>{this._loadingController===i&&(this._loadingController=null),this._loadingPromise===r&&(this._loadingPromise=null),this._emptyTexture=null};return r.then(s,s),r}unload(){if(this._glTexture=cr(this._glTexture),this._emptyTexture=null,this._loadingController!=null){const e=this._loadingController;this._loadingController=null,this._loadingPromise=null,e.abort()}this.events.emit("unloaded")}get parameters(){return this._parameters}};function fg(t,e){if(t==null)return 0;if(vi(t)||xi(t))return e.encoding==="image/ktx2"?km(t,!!e.mipmap):e.encoding==="image/x.basis"?Wm(t,!!e.mipmap):t.byteLength;const{width:i,height:r}=t instanceof Image||t instanceof ImageData||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement?$l(t):e,s=e.pixelFormat??6408,n=Sd(s);return(e.mipmap?4/3:1)*i*r*n||0}function $l(t){return t instanceof HTMLVideoElement?{width:t.videoWidth,height:t.videoHeight}:t}const pg={wrap:{s:10497,t:10497},mipmap:!0,noUnpackFlip:!1,preMultiplyAlpha:!1};export{vl as $,ti as A,xs as B,bx as C,Ti as D,p0 as E,mi as F,T0 as G,wo as H,X_ as I,yl as J,__ as K,ov as L,Ex as M,Vf as N,Pm as O,Mx as P,Dm as Q,e0 as R,Bf as S,Ve as T,op as U,Ir as V,Xt as W,Kt as X,Po as Y,Zt as Z,wf as _,zd as a,Rp as a$,Lo as a0,Ns as a1,Ar as a2,Or as a3,zf as a4,bp as a5,xp as a6,_p as a7,Rr as a8,Lf as a9,bt as aA,Qd as aB,Df as aC,vf as aD,hf as aE,Dr as aF,Pe as aG,O0 as aH,B_ as aI,D_ as aJ,Wh as aK,V_ as aL,z_ as aM,P_ as aN,Y0 as aO,ja as aP,no as aQ,of as aR,ua as aS,xo as aT,Up as aU,qo as aV,eo as aW,Gs as aX,Ys as aY,Us as aZ,pm as a_,Of as aa,Nf as ab,Xh as ac,Rf as ad,Yt as ae,L as af,Pf as ag,W0 as ah,rf as ai,hp as aj,q0 as ak,Z0 as al,Q0 as am,Jd as an,nr as ao,zp as ap,to as aq,zo as ar,vd as as,Yh as at,Pr as au,rl as av,Mi as aw,Vs as ax,l_ as ay,Ai as az,q_ as b,gl as b$,Af as b0,go as b1,Rt as b2,zn as b3,pp as b4,mp as b5,Ye as b6,Lr as b7,ko as b8,Wo as b9,Np as bA,qp as bB,qs as bC,Sm as bD,Am as bE,Op as bF,Yv as bG,Cm as bH,H as bI,_l as bJ,D0 as bK,$0 as bL,C0 as bM,I0 as bN,E0 as bO,b_ as bP,w_ as bQ,rs as bR,If as bS,fl as bT,Jo as bU,ul as bV,cl as bW,Xs as bX,hm as bY,Ks as bZ,Js as b_,zs as ba,_d as bb,Fh as bc,Ev as bd,Dt as be,yd as bf,Xn as bg,jv as bh,Hf as bi,Do as bj,Zd as bk,tf as bl,Kd as bm,Tf as bn,A0 as bo,d0 as bp,af as bq,Yd as br,lf as bs,df as bt,pf as bu,Eo as bv,X0 as bw,gf as bx,sf as by,x_ as bz,eh as c,L_ as c$,Fi as c0,qh as c1,Zp as c2,Tr as c3,Tu as c4,Qa as c5,Ah as c6,yv as c7,Mv as c8,Fr as c9,Kv as cA,xd as cB,Ed as cC,M_ as cD,cx as cE,um as cF,Dp as cG,ea as cH,vx as cI,Ip as cJ,N_ as cK,kh as cL,lv as cM,Yr as cN,vv as cO,gv as cP,mv as cQ,th as cR,S_ as cS,fp as cT,Xo as cU,ml as cV,ex as cW,J0 as cX,Pp as cY,dl as cZ,K_ as c_,Hv as ca,vo as cb,Td as cc,Ii as cd,Ss as ce,Pd as cf,Dd as cg,wv as ch,Lu as ci,uh as cj,dv as ck,_v as cl,Tv as cm,Vu as cn,J_ as co,p_ as cp,Cx as cq,g0 as cr,Sn as cs,$f as ct,Xv as cu,dx as cv,vp as cw,Hm as cx,lp as cy,Zv as cz,T_ as d,mm as d0,vm as d1,_m as d2,_o as d3,gp as d4,Gv as d5,An as d6,Ps as d7,Lv as d8,Bv as d9,Wv as da,ke as db,ro as dc,gi as dd,fv as de,Z_ as e,Ep as f,Va as g,Kf as h,Zf as i,$_ as j,is as k,oi as l,g_ as m,v_ as n,Y_ as o,qf as p,_f as q,Ls as r,uf as s,Gm as t,zu as u,h_ as v,cv as w,Od as x,Cp as y,W_ as z};
