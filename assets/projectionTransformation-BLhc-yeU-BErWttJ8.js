import{t as f,a as p,z as m,b as c,R as d,d as l,J as u,W as x}from"./ProjectionTransformation-PJc9H7Gq-Rbz84pUM.js";import"./Point2D-CMz7woHH-BVbGGL7p.js";import{Envelope2D as g}from"./Envelope2D-mFnl8dXR-MYac-bfa.js";import"./jsonMap-Bs3hmeCU-Cusd0Fmz.js";import"./Transformation2D-CrydmBdC-D4jE8w-_.js";import"./SimpleGeometryCursor-B92kdZ15-B1Z6elF7.js";import"./OperatorDefinitions-DP7_WWTp-DP7_WWTp.js";function k(e,r,t){let s,i;if(t?.geographicTransformation){if(t.geographicTransformation.steps?.length){const a=new f;a.setInputSpatialReference(e),a.setOutputSpatialReference(r);for(const n of t.geographicTransformation.steps){let o;o=n.wkid?p(n.wkid,n.isInverse):m(n.wkt,n.isInverse),a.add(o)}s=a.create()}else s=u();if(t.extendedParams){i=x();const{densificationStep:a}=t.extendedParams;a!=null&&(i.densificationStep=a)}}else if(t?.areaOfInterestExtent)return c(e,r,S(t.areaOfInterestExtent));return s?d(e,r,s,i):l(e,r)}function S(e){return g.construct(e.xmin,e.ymin,e.xmax,e.ymax)}export{k as createProjectionTransformation};
