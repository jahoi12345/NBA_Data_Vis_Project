import{b7 as R,o as G,u as J,ah as Q,aH as X,n as Z,bp as K,ag as z,d as Y,a8 as ee,_ as o,m as u,a as te}from"./jsonMap-Bs3hmeCU.js";import{l as P,f as ie,U as se,j as re}from"./reactiveUtils-SO2Ko3sy.js";import{a5 as ae,Q as ne,a8 as le}from"./Point-C1MrKtFQ.js";import{X as V}from"./projectionUtils-DgeaYumr.js";import{o as A,c as oe,B as ue,z as de,p as F,d as he}from"./aaBoundingRect-CirBGiM6.js";import{c as ce}from"./ElevationInfo-tmoMRTCD.js";import{u as $}from"./screenUtils-BitdhK1O.js";import{a as me,f as U,o as B,m as pe,s as O,b as ge}from"./loadUtils-Cq4a_Jkv.js";import{p as _e}from"./SubView3D-BgWeOqxP.js";import{B as fe,aG as H,h as ye,a5 as ve,a0 as Te,V as we,J as Se,aH as xe}from"./ShadowCastClear.glsl-L5KbQEJ_.js";import{o as be}from"./WorkerHandle-BN3A8gpv.js";import{u as Re}from"./Color-CERqXxxY.js";import{r as $e}from"./collectionUtils-0LMOubEE.js";import{H as Le,n as Me,G as Pe,E as Ae}from"./Texture-DX30_NqW.js";import{n as ke,E as Ve,f as Ee}from"./line-BljaEAV0.js";import{y as Ge}from"./elevationInfoUtils-M7_FbiD_.js";import{u as I}from"./memoryEstimations-Bd726a_p.js";import{f as q}from"./Scheduler-CNrsbccs.js";import{t as qe,a as Ce}from"./layerViewUtils-BTa15X3o.js";function De(i){const e=ze(Fe(i)),t=e,s=!0,r=Math.max(e/2,5),a=Math.round($(i.maxPathLength)/r)+1,n=10,{density:d}=i;return{smoothing:$(i.smoothing),interpolate:!0,velocityScale:i.flowRepresentation==="flow-from"?1:-1,verticesPerLine:a,minSpeedThreshold:.001,segmentLength:r,maxTurnAngle:1,collisions:s,lineCollisionWidth:t,lineSpacing:n,density:d,onlyForwardTracing:!0,wrapAround:!1}}function ze(i){return i.kind==="constant"?i.value[0]:i.values[i.values.length-1]}function Fe(i){if(!i.hasVisualVariables("size"))return{kind:"constant",value:[$(i.trailWidth)]};const e=i.getVisualVariablesForType("size")[0],t=[],s=[];let r;if(e.stops){for(const a of e.stops)t.push(a.value),s.push($(a.size));r=e.stops.length}else t.push(e.minDataValue,e.maxDataValue),s.push($(e.minSize),$(e.maxSize)),r=2;return{kind:"ramp",stops:t,values:s,count:r}}function Oe(i,e){let t=!0;return t=t&&i.collisions===e.collisions,t=t&&i.density===e.density,t=t&&i.interpolate===e.interpolate,t=t&&i.lineCollisionWidth===e.lineCollisionWidth,t=t&&i.lineSpacing===e.lineSpacing,t=t&&i.maxTurnAngle===e.maxTurnAngle,t=t&&i.minSpeedThreshold===e.minSpeedThreshold,t=t&&i.segmentLength===e.segmentLength,t=t&&i.smoothing===e.smoothing,t=t&&i.velocityScale===e.velocityScale,t=t&&i.verticesPerLine===e.verticesPerLine,t}function Ie(i,e,t,s){return i/=t.size[0],e=1-(e/=t.size[1]),i*=t.extent.xmax-t.extent.xmin,e*=t.extent.ymax-t.extent.ymin,i+=t.extent.xmin,e+=t.extent.ymin,i-=s.extent.xmin,e-=s.extent.ymin,i/=s.extent.xmax-s.extent.xmin,e=1-(e/=s.extent.ymax-s.extent.ymin),{x:i*=s.size[0],y:e*=s.size[1]}}function We(i,e,t,s){const r=[],a=t.time-e.time;if(i.length===0)return[];const n=me(i),d=n?U(i[0].hasMagnitude):1,c=n?({vertices:m},p)=>{const g=m,_=p*d;return{x:g[_],y:g[_+1],t:g[_+2],speed:0}}:({vertices:m},p)=>m[p];for(const m of i){const{stage:p,vertices:g}=m;if(p===2)continue;const _=g.length/d,f=c(m,0),S=f.t,L=(a*s-S)%(c(m,_-1).t-S)+S;let y,x=f.x,b=f.y,v=f.t;for(y=1;y<_&&v<L;y++){const T=c(m,y),M=Math.min(T.t,L)-v,h=T.t-v;x+=(T.x-x)*(M/h),b+=(T.y-b)*(M/h),v+=M}r.push(Ie(x,b,e,t))}return r}const Ue=.1,W=1,Be=1,Rt=1e3,He=!1,je=3,Ne=1,Je=1.5,k=501,Qe=256,Xe=3,Ze=2,Ke=2;class Ye extends be{constructor(e){super("FlowWorker","generateStreamlines",{generateStreamlines:t=>[t.flowData.data.buffer,t.flowData.mask.buffer],generateTiledStreamlines:t=>{const s=[];return t.flowDataTiles.forEach(r=>{r.type==="loaded"&&s.push(r.data.data.buffer,r.data.mask.buffer)}),s}},e,{strategy:"dedicated"})}generateStreamlines(e,t){return this.invokeMethod("generateStreamlines",e,t)}generateTiledStreamlines(e,t){return this.invokeMethod("generateTiledStreamlines",e,t)}}function et(i,e,{vertices:t,stage:s,hasMagnitude:r},a,n,d){const{spatialReference:c}=e.extent,m=[],p=U(r),g=e.flowExtentInfo.modelSize[0];let _=0;for(let h=0;h<t.length;h+=p){if(d&&h>0){const D=t[h]-t[h-p];D>g/2?_-=g:-D>g/2&&(_+=g)}const[w,C]=e.modelToMapSpace(t[h]+_,t[h+1],!1),N=d?[w,C,fe]:it(w,C,c,i,a);m.push(N)}const f=Math.floor(t.length/p),S=ke(f);for(let h=0;h<f;h++)S[h]=t[h*p+2];const{hasVVColor:L,hasVVOpacity:y,hasVVSize:x}=n.parameters;let b,v,T;if(r&&(L||y||x)){const h=Me(f);for(let w=0;w<f;w++)h[w]=t[w*p+3];L&&(b=[h]),y&&(v=[h]),x&&(T=[h])}const M=Ve([m],void 0,[{timeStamps:S,streamlineType:s}],b,v,T);return Ee(n,M[0])}function tt(i,e,t){if(i==null)return{};let s=null;if(i.visualVariables){const a=[],n=i.visualVariables,d=new Pe({supports:{size:!0,color:!0,rotation:!1,opacity:!0}});s=Le(n,d,a)}const r=s?.color?[1,1,1,1]:Re.toUnitRGBA(i.color);return r[3]*=e,{color:r,width:i.trailWidth,cap:0,animationSpeed:i.flowSpeed,trailLength:i.trailLength,animation:3,emissiveStrength:t,vvColor:s?.color,vvOpacity:s?.opacity,vvSize:s?.size}}function it(i,e,t,s,r){const{absoluteZ:a}=Ge(i,e,0,t,s,r),n=$e(i,e,a);return s.renderCoordsHelper.toRenderCoords(n,t,n),n}class j{constructor(e,t,s,r,a){this._query=e,this.streamlines=t,this._material=s,this.geometries=r,this._bytesPerFeature=a,this._startTime=0,this._endTime=1/0,this.usedMemory=null,this.startTime=this._query.time,this.computeMemory()}computeMemory(){const e=I(this.streamlines),t=I(this.geometries.map(r=>r.attributes)),s=this.streamlines.length*this._bytesPerFeature;this.usedMemory=e+t+s}get startTime(){return this._startTime}set startTime(e){this._query.time!==e&&(this._query=new B(this._query.extent,this._query.timeExtent,this._query.size,this._query.pixelRatio,R(e))),this._startTime=e,this.setMaterialParameters({startTime:e})}get endTime(){return this._endTime}set endTime(e){this._endTime=e,this.setMaterialParameters({endTime:e})}get query(){return this._query}hasFadedOut(e){return this.endTime+this._material.parameters.fadeOutTime<e}setMaterialParameters(e){this._material.setParameters(e)}get test(){return null}}class st extends j{constructor(e,t,s,r,a){super(e,t,s,r,H.LINE_ROUND.draped.bytesPerFeature),this._layerView=a,this._drapeRenderer=null,this.drapeSourceType=2,this.updatePolicy=0,this.renderGroup=0,this._frameTask=null,this._renderGeometries=[]}get _view(){return this._layerView.view}get layer(){return this._layerView.layer}get fullOpacity(){return this._layerView.fullOpacity}get attached(){return this._drapeRenderer!=null}get destroyed(){return this.attached}async attach(){const{geometries:e}=this;e!=null&&(this.detach(),this._frameTask=this._view.resourceController.scheduler.registerTask(q.FLOW_GENERATOR),await this._frameTask.scheduleGenerator(t=>this._addGeometryToOverlay(e,t)))}async*_addGeometryToOverlay(e,t){this._drapeRenderer=this._view.overlayManager.registerGeometryDrapeSource(this);for(let s=0;s<e.length;s+=k){const r=e.slice(s,s+k).map(a=>new ye(a));this._drapeRenderer.addGeometries(r,0),this._renderGeometries.push(...r),this._drapeRenderer.commitChanges(),t.madeProgress(),t.done&&(t=yield)}}detach(){this._frameTask=G(this._frameTask),this._drapeRenderer&&(this._drapeRenderer.removeGeometries(this._renderGeometries,2),this._drapeRenderer.commitChanges(),this._renderGeometries.length=0),this.attached&&this._view.overlayManager.unregisterDrapeSource(this),this._drapeRenderer=J(this._drapeRenderer)}}class rt extends j{constructor(e,t,s,r,a){super(e,t,s,r,H.LINE_ROUND.bytesPerFeature),this._view=a,this._objects3D=[],this._engineLayer=null,this._frameTask=null}get attached(){return this._engineLayer!=null}async attach(){const{geometries:e}=this;e!=null&&(this.detach(),this._frameTask=this._view.resourceController.scheduler.registerTask(q.FLOW_GENERATOR),await this._frameTask.scheduleGenerator(t=>this._addGeometryToLayer(e,t)))}detach(){this.attached&&(this._engineLayer?.removeMany(this._objects3D),this._objects3D.forEach(e=>e.dispose()),this._engineLayer?.commit(),this._objects3D=[],this._engineLayer=null,this._frameTask=G(this._frameTask))}async*_addGeometryToLayer(e,t){const{stage:s}=this._view,r=new ve(s,{pickable:!1,updatePolicy:1});for(let a=0;a<e.length;a+=k){const n=new Te({geometries:e.slice(a,a+k),castShadow:!1});r.add(n),this._objects3D.push(n),r.commit(),t.madeProgress(),t.done&&(t=yield)}this._engineLayer=r}}let l=class extends _e{constructor(i){super(i),this.type="flow",this.renderedTiles=null,this.requireLoad=!1,this.workerHandle=null,this.frameTask=null,this._averageLoadingTime=R(0),this._abortController=null,this._loadingState="ready-to-load",this._tilesUpdateIsWaiting=!1,this._debugAllowAutoLoading=!0,this.emissiveStrength=0,this._overrideMaterialParameters=null,this._overrideSimulationSettings=null,this._overrideTransitionEnabled=null,this._updateTask=null,this._debouncedTileUpdate=Q(async()=>{const{allTiles:e}=this.surface,t=this._getTileFilterFunction(),s=new Set;function*r(a){for(let n=0;n<e.length;++n){const d=e.at(n);t(d)&&s.add(d),a.madeProgress(),a.done&&(a=yield)}}await this.frameTask.scheduleGenerator(r),this.renderedTiles=s})}initialize(){const{surface:i,view:e}=this,{resourceController:t}=e;this.workerHandle=new Ye(we(t)),this.frameTask=t.scheduler.registerTask(q.FLOW_GENERATOR),this._updateTask=X({update:s=>this._update(s)}),this.addHandles([P(()=>this._simulationSettings,()=>this.triggerLoad(),{sync:!0,equals:(s,r)=>s==null&&r==null||s!=null&&r!=null&&Oe(s,r)}),P(()=>{const{elevationInfo:s}=this;return[this._clippingArea,this._visible,this._draped,this.view.state.contentPixelRatio,this.view.viewingMode,s?.mode,s?.offset,s?.unit,this._effectiveDensity]},()=>this.triggerLoad(),se),P(()=>this._materialParameters,s=>{this._resources?.setMaterialParameters(s),this._lastResources?.setMaterialParameters(s)}),i.on("tiles-changed",()=>{this.loadByTileTreesAllowed&&this._triggerTilesUpdate()}),e.enableFeatureTiles(),P(()=>[this._dataBounds,this._featureTilesBounds,this.loadAllTiles],()=>this._triggerTilesUpdate()),P(()=>this._flowRenderer,(s,r)=>{const a=r?.visualVariables??[],n=s?.visualVariables??[];n.length===a.length&&n.every((d,c)=>d.type===a[c].type)||this.clear()}),ie(()=>!e.featureTiles?.updating,()=>{this.loadByTileTreesAllowed&&this._triggerTilesUpdate()})]),this._triggerTilesUpdate()}destroy(){this._updateTask=G(this._updateTask),this.abort(),this.clear()}abort(){this._abortController=Z(this._abortController),this.requireLoad=!1}get _clippingArea(){const i=V(this.view.clippingArea,this.surface.spatialReference).geometry;return i==null?null:A(i)}get _dataBounds(){const i=V(this.layer.fullExtent,this.surface.spatialReference).geometry;return i==null?null:A(i)}get _draped(){return this.elevationInfo.mode==="on-the-ground"}get _ellipsoidRadius(){return ae(this.view.spatialReference).radius}get extent(){const{spatialReference:i}=this.surface;let e=this.renderedTiles;if(i==null||e==null)return null;const t=this.view.terrainLevel;if(t!=null){const r=new Set;e.forEach(a=>{Math.abs(t-a.level)<Xe&&r.add(a)}),e=r}const s=pe(e,this.spatialReferenceInfo);return s==null?null:(ue(s,this._clippingArea,s),oe(s,i))}get loadAllTiles(){const{position:i}=this.view.camera,e=i.z;return e==null?!1:e*ne(i.spatialReference)/this._ellipsoidRadius>=Je}get isDataGlobal(){const{extent:i,spatialReferenceInfo:e}=this;return i!=null&&O(i.xmin,i.xmax,e)}get loadByTileTreesAllowed(){return!this.loadAllTiles||!this.loadRequirementsMet}get _featureTilesBounds(){const i=this.view.featureTiles?.filterExtent,e=V(i,this.surface.spatialReference).geometry;return e==null?null:A(e)}get _flowRenderer(){const i=this.layer.renderer;return i?.type!=="flow"?null:i}get _materialParameters(){return{...tt(this._flowRenderer,this.layerView.fullOpacity,this.emissiveStrength),fadeInTime:Be,fadeOutTime:W,...this._overrideMaterialParameters,hasSlicePlane:this.layerView.slicePlaneEnabled,screenSizePerspective:!this._draped&&Ae(this.layer.screenSizePerspectiveEnabled)?this.view.screenSizePerspective.parameters:null}}get _opacity(){return this.layerView.fullOpacity}get _seamlessTransitionWaitingTime(){const{_averageLoadingTime:i}=this;return R(i===0?Ne:this._averageLoadingTime*je)}get _seamlessTransitionEnabled(){return this._overrideTransitionEnabled!=null?this._overrideTransitionEnabled:He}get _tracingResolution(){const{extent:i}=this;if(!i)return[0,0];const e=ge(i.xmin,i.xmax,this.spatialReferenceInfo?.valid)/(i.ymax-i.ymin),[t,s]=this.view.size;let r,a;t<s?(r=t,a=t/e):(r=s*e,a=s);const n=Qe,d=this.view.qualitySettings.flow3D.maxTracingResolution,c=Math.max(1,n/Math.min(r,a)),m=c*Math.min(1,d/Math.max(r*c,a*c));return[Math.round(r*m),Math.round(a*m)]}get _visible(){const i=this._flowRenderer?.color;return this.visibleAtCurrentScale&&this.layer.effectiveVisible&&this._opacity>0&&(i==null||i.a>0)}get _estimatedStreamlines(){const{extent:i,_simulationSettings:e,renderedTiles:t}=this;if(e==null||t==null)return 0;const s=this._tracingResolution[0]*this._tracingResolution[1]/e.lineSpacing**2*e.density,r=i==null?null:A(i);if(r==null)return 0;let a=0;for(const c of t)de(r,c.extent)&&(a+=F(c.extent));const n=F(r),d=n===0?0:a/n;return 2*Math.round(s*d)}get _effectiveDensity(){const{_estimatedStreamlines:i,_simulationSettings:e}=this,{qualitySettings:t,quality:s}=this.view;if(e==null)return 0;const r=t.flow3D.maxTotalNumberOfStreamlines,a=i>=r?r/i:1,n=e.density*a*s;return e.lineSpacing/Math.sqrt(n)<e.lineCollisionWidth?(e.lineSpacing/e.lineCollisionWidth)**2:n}get elevationInfo(){return this.layer.elevationInfo??at}startPositions(i){if(!this._seamlessTransitionEnabled)return[];const{_flowRenderer:e,_resources:t}=this;return e==null||t==null?[]:We(t.streamlines,t.query,i,e.flowSpeed)}get needsMagnitude(){return this._flowRenderer?.hasVisualVariables()??!1}get spatialReferenceInfo(){return le(this.surface.spatialReference)}get layer(){return this.layerView.layer}get loadingState(){return this._loadingState}get loadRequirementsMet(){return this.renderedTiles!=null&&this.renderedTiles.size>0}getUpdating(){return this.updatingHandles.updating||this.requireLoad||this._loadingState==="before-transition"}get updating(){return this.getUpdating()}get visibleAtCurrentScale(){return!Ce()||qe(this.layer.effectiveScaleRange,this.view.scale)}get _simulationSettings(){const{_flowRenderer:i,_overrideSimulationSettings:e}=this;if(i==null)return null;let t=De(i);return t.segmentLength=t.lineCollisionWidth/2,t.onlyForwardTracing=!1,t.density*=Ze,this.loadAllTiles&&this.isDataGlobal&&(t.density*=Ke),e!=null&&(t={...t,...e}),t}getSimulationSettings(i){const{_simulationSettings:e,spatialReferenceInfo:t}=this;if(e==null)return null;const s=this.view.viewingMode==="global"&&t!=null&&O(i.extent.xmin,i.extent.xmax,t);return{...e,wrapAround:s,density:this._effectiveDensity}}get surface(){return this.view.basemapTerrain}doRefresh(){this.triggerLoad()}clear(){this._resources?.detach(),this._resources=null,this._lastResources?.detach(),this._lastResources=null,this._loadingState="ready-to-load"}_update(i){const e=K(i.time);this._lastResources?.hasFadedOut(e)&&this._lastResources.detach();const t=this._nextStateForTransition(e);if(!this.requireLoad||this.updatingHandles.updating||t!=="ready-to-load"||!this.loadRequirementsMet)return void(this._loadingState=t);this._loadingState="loading";const s=async()=>{const r=performance.now(),a=this._seamlessTransitionEnabled&&this._resources!=null?R(e+this._seamlessTransitionWaitingTime):e;await this._load(a);const n=R((performance.now()-r)/1e3);this._updateAverageLoadingTime(n)};this.updatingHandles.addPromise(z(s())),this.requireLoad=!1}_updateAverageLoadingTime(i){const e=Ue;this._averageLoadingTime=R(e*i+(1-e)*this._averageLoadingTime)}triggerLoad(){this._debugAllowAutoLoading&&(this.requireLoad=!0)}async _load(i){const{extent:e,view:t}=this;if(!this._visible)return this.clear(),void(this._loadingState="ready-to-load");if(e==null)return void(this._loadingState="ready-to-load");const s=new B(e,this.layerView.timeExtent,this._tracingResolution,t.state.contentPixelRatio,i);this._abortController==null&&(this._abortController=new AbortController);const r=this._abortController,a=await this._loadStreamlines(s,r.signal);if(Y(r.signal),this._visible&&a!=null){this._lastResources?.detach(),this._lastResources=this._resources,this._resources=a;const n=performance.now()/1e3,d=n>i?n:i;this._lastResources!=null&&(this._lastResources.endTime=d),this._resources.startTime=d,await a.attach(),this._loadingState=this._seamlessTransitionEnabled?"before-transition":"transitioning"}else this._loadingState="ready-to-load"}async _loadStreamlines(i,e){const t=await this.fetchDataAndGenerateStreamlines(i,e);if(t==null)return null;const{geometries:s,material:r}=await this._createGeometry(i,t);return this._draped?new st(i,t,r,s,this.layerView):new rt(i,t,r,s,this.view)}async fetchDataAndGenerateStreamlines(i,e){return null}async _createGeometry(i,e){const t=new Se(this._materialParameters,this.view.state.isGlobal),s=new Array,{elevationInfo:r,_draped:a,view:n}=this;function*d(c){for(let m=0;m<e.length;++m)s.push(et(n,i,e[m],r,t,a)),c.madeProgress(),c.done&&(c=yield)}return await this.frameTask.scheduleGenerator(d),{geometries:s,material:t}}_triggerTilesUpdate(){if(this._tilesUpdateIsWaiting)return;this._tilesUpdateIsWaiting=!0;const i=async()=>{await re(()=>this.view.stationary),this._tilesUpdateIsWaiting=!1,await this._debouncedTileUpdate()};this.updatingHandles.addPromise(z(i()))}_getTileFilterFunction(){const{_dataBounds:i,view:e,_featureTilesBounds:t}=this;if(this.loadAllTiles)return n=>n.leaf&&E(i,n.extent);const s=n=>n.rendered&&n.visible&&E(i,n.extent),{featureTiles:r}=e;if(!r)return s;const a=r.tiles.filter(n=>n.measures.visible);return n=>s(n)&&E(t,n.extent)&&a.some(({lij:d})=>ee(d,n.lij)||xe(d,n.lij))}_nextStateForTransition(i){const{_resources:e}=this;if(this._flowRenderer==null||e==null||this._loadingState==="ready-to-load"||this._loadingState==="loading")return this._loadingState;const t=e.startTime;return i<t?"before-transition":i<t+W?"transitioning":"ready-to-load"}get usedMemory(){return(this._lastResources?.usedMemory??0)+(this._resources?.usedMemory??0)}get test(){}};o([u()],l.prototype,"type",void 0),o([u()],l.prototype,"renderedTiles",void 0),o([u()],l.prototype,"_resources",void 0),o([u()],l.prototype,"_lastResources",void 0),o([u()],l.prototype,"requireLoad",void 0),o([u()],l.prototype,"_averageLoadingTime",void 0),o([u()],l.prototype,"_loadingState",void 0),o([u()],l.prototype,"emissiveStrength",void 0),o([u()],l.prototype,"_clippingArea",null),o([u()],l.prototype,"_dataBounds",null),o([u()],l.prototype,"_draped",null),o([u()],l.prototype,"_ellipsoidRadius",null),o([u()],l.prototype,"extent",null),o([u()],l.prototype,"loadAllTiles",null),o([u()],l.prototype,"isDataGlobal",null),o([u()],l.prototype,"_featureTilesBounds",null),o([u()],l.prototype,"_flowRenderer",null),o([u()],l.prototype,"_materialParameters",null),o([u()],l.prototype,"_opacity",null),o([u()],l.prototype,"_seamlessTransitionWaitingTime",null),o([u()],l.prototype,"_seamlessTransitionEnabled",null),o([u()],l.prototype,"_tracingResolution",null),o([u()],l.prototype,"_visible",null),o([u()],l.prototype,"_estimatedStreamlines",null),o([u()],l.prototype,"_effectiveDensity",null),o([u()],l.prototype,"elevationInfo",null),o([u()],l.prototype,"needsMagnitude",null),o([u()],l.prototype,"spatialReferenceInfo",null),o([u()],l.prototype,"layer",null),o([u()],l.prototype,"loadingState",null),o([u()],l.prototype,"updating",null),o([u()],l.prototype,"visibleAtCurrentScale",null),o([u()],l.prototype,"_overrideMaterialParameters",void 0),o([u()],l.prototype,"_overrideSimulationSettings",void 0),o([u()],l.prototype,"_overrideTransitionEnabled",void 0),o([u()],l.prototype,"_simulationSettings",null),o([u()],l.prototype,"surface",null),l=o([te("esri.views.3d.layers.FlowSubView3D")],l);const at=new ce({mode:"on-the-ground"});function E(i,e){return i==null||e==null||he(i,e)}export{Rt as c,l as r};
