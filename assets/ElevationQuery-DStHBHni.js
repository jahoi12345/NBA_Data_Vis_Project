import{_ as ce}from"./asyncUtils-w6KfWU41.js";import{i as J,_ as y,a as b,bm as ue,m as R,s as v,D as K,aw as C,f as X}from"./jsonMap-Bs3hmeCU.js";import{aj as fe,b as S,f as he,F as _}from"./Point-B6yFWNoR.js";import{N as F,W as k}from"./projectionUtils-DIbtnzb-.js";import{z as Y,c as ee,i as pe,E as me,o as de}from"./aaBoundingRect-F1Nk1aID.js";import{e as O}from"./TileKey-BVNpatnV.js";import{m as M,y as ye}from"./Polyline-CiznIgZG.js";import{c as xe}from"./reactiveUtils-SO2Ko3sy.js";let I=class extends xe{queryElevation(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case"point":return ve(e,t,this);case"polyline":return we(e,t,this);case"multipoint":return ge(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;const n=e.spatialReference;if(n.equals(t))return e;const a=fe(e,t);return a||J.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),a}};function ve(i,e,t){return i.hasZ=!0,i.z=t.elevationAt(e.x,e.y),i}function we(i,e,t){d.spatialReference=e.spatialReference;const n=i.hasM&&!i.hasZ;for(let a=0;a<i.paths.length;a++){const o=i.paths[a],s=e.paths[a];for(let l=0;l<o.length;l++){const r=o[l],u=s[l];d.x=u[0],d.y=u[1],n&&(r[3]=r[2]),r[2]=t.elevationAt(d.x,d.y)}}return i.hasZ=!0,i}function ge(i,e,t){d.spatialReference=e.spatialReference;const n=i.hasM&&!i.hasZ;for(let a=0;a<i.points.length;a++){const o=i.points[a],s=e.points[a];d.x=s[0],d.y=s[1],n&&(o[3]=o[2]),o[2]=t.elevationAt(d.x,d.y)}return i.hasZ=!0,i}I=y([b("esri.layers.support.ElevationSampler")],I);const d=new S;class te{constructor(e,t){this.layer=e,this.parameters=t}}class Te extends te{constructor(e,t,n){super(e,n),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(t=>t.tile=null);else{const{tileInfo:t,tilemapCache:n}=this.layer,a=E(t,n)[e].level;this.geometry.coordinates.forEach(o=>o.tile=t.tileAt(a,o.x,o.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(const t of this.geometry.coordinates){const n=t.tile?.id;t.tile=n?e[n]:null}}getTilesToFetch(){return ue(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>e?.id&&!t),(e,t)=>e.tile?.id===t.tile?.id).map(({tile:e})=>e)}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}}class Re extends te{constructor(e,t,n,a){super(e,n),this.maskExtents=a,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.clone().intersection(e.fullExtent)}selectTilesAtLOD(e,t){const n=this._maximumLodForRequests(t),a=Math.min(n,e);a<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(a)}_maximumLodForRequests(e){const{tileInfo:t,tilemapCache:n}=this.layer,a=E(t,n);if(!e)return a.length-1;const o=this.extent;if(o==null)return-1;for(let s=a.length-1;s>=0;s--){const l=a[s],r=l.resolution*t.size[0],u=l.resolution*t.size[1];if(Math.ceil(o.width/r)*Math.ceil(o.height/u)<=e)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const t of this._candidateTiles){const n=t.id&&e[t.id];n&&(this._fetchedCandidates.add(t),this.elevationTiles.push(n))}}remapTiles(e){this._candidateTiles=B(this._candidateTiles.map(t=>e[t.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){const n=this._candidateTiles;this._candidateTiles=[],n.forEach(a=>{if(this._fetchedCandidates.has(a))return void t?.(a);let o=!1;e(a,()=>o=!0),o?t?.(a):this._candidateTiles.push(a)}),this._candidateTiles=B(this._candidateTiles,t)}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const t=this.extent;if(t==null)return;const{tileInfo:n,tilemapCache:a}=this.layer,o=E(n,a)[e],s=n.tileAt(o.level,t.xmin,t.ymin),l=s.extent,r=o.resolution*n.size[0],u=o.resolution*n.size[1],c=Math.ceil((t.xmax-l[0])/r),f=Math.ceil((t.ymax-l[1])/u);for(let m=0;m<f;m++)for(let h=0;h<c;h++){const w=new O(s.level,s.row-m,s.col+h);n.updateTileInfo(w),this._tileIsMasked(w)||this._candidateTiles.push(w)}}_tileIsMasked(e){return this.maskExtents?.some(t=>Y(t,e.extent))??!1}}function L(i){return i?.tileInfo!=null}function E(i,e){const t=i.lods;if(L(e)){const{effectiveMinLOD:n,effectiveMaxLOD:a}=e;return t.filter(o=>o.level>=n&&o.level<=a)}return t}function B(i,e){const t={},n=[];for(const o of i){const s=o.id;s&&!t[s]?(t[s]=o,n.push(o)):e?.(o)}const a=n.sort((o,s)=>o.level-s.level);return a.filter((o,s)=>{for(let l=0;l<s;l++){const r=a[l].extent;if(r&&Y(r,o.extent))return e?.(o),!1}return!0})}let Ee=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}};class ie{constructor(e,t=null){if(this.key=e,t!=null){const n=e.extent;this._samplerData=new Ee(t,n)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){return!!this._samplerData?.data.hasNoDataValues}sample(e,t){if(this._samplerData==null)return;const{safeWidth:n,data:a,dx:o,dy:s,y1:l,x0:r}=this._samplerData,{width:u,values:c,noDataValue:f}=a,m=H(s*(l-t),0,n),h=H(o*(e-r),0,n),w=Math.floor(m),G=Math.floor(h),q=w*u+G,N=q+u,z=c[q],V=c[N],P=c[q+1],W=c[N+1];if(z!==f&&V!==f&&P!==f&&W!==f){const U=h-G,Q=z+(P-z)*U;return Q+(V+(W-V)*U-Q)*(m-w)}}}function H(i,e,t){return i<e?e:i>t?t:i}class x{constructor(e){this.geometry=e,this.spatialReference=e.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const t=new x(this.geometry);return t.spatialReference=this.spatialReference,t.coordinates=e??this.coordinates.map(n=>n.clone()),t._exporter=this._exporter,t}async project(e,t){if(this.spatialReference.equals(e))return this.clone();await F([{source:this.spatialReference,dest:e}],{signal:t});const n=new M({spatialReference:this.spatialReference,points:this.coordinates.map(l=>[l.x,l.y])}),a=k(n,e);if(!a)return null;const o=this.coordinates.map((l,r)=>{const u=l.clone(),c=a.points[r];return u.x=c[0],u.y=c[1],u}),s=this.clone(o);return s.spatialReference=e,s}static fromGeometry(e){const t=new x(e);if(e instanceof x)return t.coordinates=e.coordinates.map(n=>n.clone()),t._exporter=(n,a)=>{const o=e.clone(n);return o.spatialReference=a,o},t;switch(e.type){case"point":{const n=e,{hasZ:a,hasM:o}=n;return t.coordinates=a&&o?[new p(n.x,n.y,n.z,n.m)]:a?[new p(n.x,n.y,n.z)]:o?[new p(n.x,n.y,null,n.m)]:[new p(n.x,n.y)],t._exporter=(s,l)=>e.hasM?new S(s[0].x,s[0].y,s[0].z,s[0].m,l):new S(s[0].x,s[0].y,s[0].z,l),t}case"multipoint":{const n=e,{hasZ:a,hasM:o}=n;return t.coordinates=a&&o?n.points.map(s=>new p(s[0],s[1],s[2],s[3])):a?n.points.map(s=>new p(s[0],s[1],s[2])):o?n.points.map(s=>new p(s[0],s[1],null,s[2])):n.points.map(s=>new p(s[0],s[1])),t._exporter=(s,l)=>e.hasM?new M({points:s.map(r=>[r.x,r.y,r.z??0,r.m??0]),hasZ:!0,hasM:!0,spatialReference:l}):new M({points:s.map(r=>[r.x,r.y,r.z??0]),spatialReference:l}),t}case"polyline":{const n=e,a=[],o=[],{hasZ:s,hasM:l}=e;let r=0;for(const u of n.paths)if(o.push([r,r+u.length]),r+=u.length,s&&l)for(const c of u)a.push(new p(c[0],c[1],c[2],c[3]));else if(s)for(const c of u)a.push(new p(c[0],c[1],c[2]));else if(l)for(const c of u)a.push(new p(c[0],c[1],null,c[2]));else for(const c of u)a.push(new p(c[0],c[1]));return t.coordinates=a,t._exporter=(u,c)=>{const f=e.hasM?u.map(h=>[h.x,h.y,h.z??0,h.m??0]):u.map(h=>[h.x,h.y,h.z??0]),m=o.map(h=>f.slice(h[0],h[1]));return new ye({paths:m,hasM:e.hasM,hasZ:!0,spatialReference:c})},t}}}}class p{constructor(e,t,n=null,a=null,o=null,s=null){this.x=e,this.y=t,this.z=n,this.m=a,this.tile=o,this.elevationTile=s}clone(){return new p(this.x,this.y,this.z,this.m)}}let T=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(i){const e=i.noDataValue,t="tiles"in i?i.tiles.map(a=>new g({tile:a,tileInfo:i.tileInfo,noDataValue:e})):i.samplers;super({noDataValue:e,samplers:t});const n=t[0];if(n){this.extent=n.extent.clone();const{min:a,max:o}=n.demResolution;this.demResolution={min:a,max:o};for(let s=1;s<t.length;s++){const l=t[s];this.extent.union(l.extent),this.demResolution.min=Math.min(this.demResolution.min,l.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,l.demResolution.max)}}else{const a="tileInfo"in i?i.tileInfo:null;this.extent=ee(pe(),a?.spatialReference??he.WGS84),this.demResolution={min:0,max:0}}}elevationAt(i,e){let t;for(const n of this.samplers)if(n.containsAt(i,e)&&(t=n.elevationAt(i,e),t!==n.noDataValue))return t;return t??(J.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${i}, ${e}) is outside of the sampler`),this.noDataValue)}};y([R({constructOnly:!0})],T.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],T.prototype,"samplers",void 0),T=y([b("esri.layers.support.TileElevationSampler")],T);let g=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(i){super(i);const e=i.tile.key.extent;this.extent=ee(e,i.tileInfo.spatialReference),this.extent.zmin=i.tile.zmin,this.extent.zmax=i.tile.zmax;const t=_(i.tileInfo.spatialReference),n=i.tileInfo.lodAt(i.tile.key.level).resolution*t;this.demResolution={min:n,max:n}}contains(i){const e=this.projectIfRequired(i,this.spatialReference);return e!=null&&this.containsAt(e.x,e.y)}containsAt(i,e){return me(this.tile.key.extent,i,e)}elevationAt(i,e){return this.containsAt(i,e)?this.tile.sample(i,e)??this.noDataValue:this.noDataValue}};y([R({constructOnly:!0})],g.prototype,"tile",void 0),y([R({constructOnly:!0})],g.prototype,"noDataValue",void 0),y([R({constructOnly:!0})],g.prototype,"tileInfo",void 0),g=y([b("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],g);async function Ie(i,e,t){if(i=t?.ignoreInvisibleLayers?i.filter(r=>r.visible):i.slice(),!i.length)throw new v(A,"Elevation queries require at least one elevation layer to fetch tiles from");const n=x.fromGeometry(e),a={...D,...t,returnSampleInfo:!0},o=i.pop(),s=await j(o,n,a),l=await se(i,s,a);return l.geometry=l.geometry.export(),t?.returnSampleInfo||delete l.sampleInfo,l}async function j(i,e,t){if(!i)throw new v(A,"Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof x)&&e.type!=="point"&&e.type!=="multipoint"&&e.type!=="polyline")throw new v("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const n={...D,...t},a=new Te(i,e.spatialReference,n),o=n.signal;return await i.load({signal:o}),await Ae(a,e,o),await oe(a,o),await $(a,o),be(a),Ce(a,o)}async function _e(i,e,t){if(i=Array.isArray(i)?i:[i],(i=t?.ignoreInvisibleLayers?i.filter(o=>o.visible):i.slice()).length===0)throw new v(A,"Elevation queries require at least one elevation layer to fetch tiles from");if(!e||e.type!=="extent")throw new v("elevation-query:invalid-extent","Invalid or undefined extent");const n={...D,...t,returnSampleInfo:!0},a=ne(i[i.length-1],e,n);return i.length===1?a:ae(i,e,await a,n)}async function ne(i,e,t,n){const a=t.signal;await i.load({signal:a});const o=e.spatialReference,s=i.tileInfo.spatialReference;o.equals(s)||(await F([{source:o,dest:s}],{signal:a}),e=k(e,s));const l=new Re(i,e,t,n);await oe(l,a),await $(l,a);const r=l.elevationTiles,u=l.layer.tileInfo,c=l.parameters.noDataValue;return new T({noDataValue:c,tiles:r,tileInfo:u})}async function ae(i,e,t,n){if(i.pop(),!i.length)return t;const a=t.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>de(r.extent)),o=await ne(i[i.length-1],e,n,a);if(o.samplers.length===0)return t;const s=t.samplers.concat(o.samplers),l=n.noDataValue;return ae(i,e,new T({samplers:s,noDataValue:l}),n)}async function se(i,e,t){const n=e.geometry.coordinates,a=e.sampleInfo;K(a);const o=new Array,s=new Array;for(let f=0;f<n.length;f++)a[f].demResolution<0&&i.length&&(o.push(n[f]),s.push(f));const l=i.pop();if(l==null||o.length===0)return e;const r=e.geometry.clone(o),u=await j(l,r,t),c=u.sampleInfo;if(!c)throw new Error("no sampleInfo");return s.forEach((f,m)=>{n[f].z=u.geometry.coordinates[m].z,a[f].demResolution=c[m].demResolution,a[f].source=c[m].source}),se(i,e,t)}async function oe(i,e){i.type==="geometry"&&qe(i);const t=i.parameters.demResolution;if(typeof t=="number")Ve(i,t);else if(t==="finest-contiguous")await De(i,e);else{if(t!=="auto")throw new v("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${t}', expected a number, "finest-contiguous" or "auto"`);await $e(i,e)}}async function De(i,e){const{tileInfo:t,tilemapCache:n}=i.layer,a=Z(t,n,i.parameters.minDemResolution);await le(i,a,e)}async function le(i,e,t){const n=i.layer;if(i.selectTilesAtLOD(e),e<0)return;const a=n.tilemapCache,o=i.getTilesToFetch();try{if(a&&!L(a))await C(Promise.all(o.map(s=>a.fetchAvailability(s.level,s.row,s.col,{signal:t}))),t);else if(await $(i,t),!i.allElevationTilesFetched())throw i.clearElevationTiles(),new v("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){X(s),await le(i,e-1,t)}}async function $e(i,e){Me(i),Se(i);const t=i.layer.tilemapCache;if(!t||L(t))return re(i,e);const n=i.getTilesToFetch(),a={},o=n.map(async s=>{const l=new O(0,0,0),r=await ce(t.fetchAvailabilityUpsample(s.level,s.row,s.col,l,{signal:e}));r.ok!==!1?s.id!=null&&(a[s.id]=l):X(r.error)});await C(Promise.all(o),e),i.remapTiles(a)}async function re(i,e){const t=i.layer.tileInfo;await $(i,e);let n=!1;i.forEachTileToFetch((a,o)=>{t.upsampleTile(a)?n=!0:o()}),n&&await re(i,e)}function Z(i,e,t=0){const n=E(i,e);let a=n.length-1;if(t>0){const o=t/_(i.spatialReference),s=n.findIndex(l=>l.resolution<o);s===0?a=0:s>0&&(a=s-1)}return a}const D={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function Ae(i,e,t){let n;const a=i.layer.tileInfo.spatialReference;if(e instanceof x?n=await e.project(a,t):(await F([{source:e.spatialReference,dest:a}],{signal:t}),n=k(e,a)),!n)throw new v("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${a.wkid}'`);i.geometry=x.fromGeometry(n)}function qe(i){if(i.layer.fullExtent==null)return;const e=new ie(new O(-1,-1,-1));e.sample=()=>i.parameters.noDataValue,i.outsideExtentTile=e;const t=i.layer.fullExtent;i.geometry.coordinates.forEach(n=>{const a=n.x,o=n.y;(a<t.xmin||a>t.xmax||o<t.ymin||o>t.ymax)&&(n.elevationTile=e)})}function ze(i,e){const{tileInfo:t,tilemapCache:n}=i.layer,a=e/_(t.spatialReference),o=E(t,n);let s=o[0],l=0;for(let r=1;r<o.length;r++){const u=o[r];Math.abs(u.resolution-a)<Math.abs(s.resolution-a)&&(s=u,l=r)}return l}function Ve(i,e){const t=ze(i,e);i.selectTilesAtLOD(t)}function Me(i){const{tileInfo:e,tilemapCache:t}=i.layer,n=Z(e,t,i.parameters.minDemResolution);i.selectTilesAtLOD(n,i.parameters.maximumAutoTileRequests)}async function $(i,e){const t=i.getTilesToFetch(),n={},a=i.parameters.cache,o=i.parameters.noDataValue,s={noDataValue:o,signal:e},l=t.map(async r=>{if(r.id==null)return;const u=`${i.layer.uid}:${r.id}:${o}`,c=a?.get(u),f=c??await i.layer.fetchTile(r.level,r.row,r.col,s);a?.put(u,f),n[r.id]=new ie(r,f)});await C(Promise.allSettled(l),e),i.populateElevationTiles(n)}function Se(i){const e=i.layer.tileInfo;let t=0;const n={},a=l=>{l.id!=null&&(l.id in n?n[l.id]++:(n[l.id]=1,t++))},o=l=>{if(l.id==null)return;const r=n[l.id];r===1?(delete n[l.id],t--):n[l.id]=r-1};i.forEachTileToFetch(a,o);let s=!0;for(;s&&(s=!1,i.forEachTileToFetch(l=>{t<=i.parameters.maximumAutoTileRequests||(o(l),e.upsampleTile(l)&&(s=!0),a(l))},o),s););}function be(i){i.geometry.coordinates.forEach(e=>{const t=e.elevationTile;let n=i.parameters.noDataValue;if(t){const a=t.sample(e.x,e.y);a==null?e.elevationTile=null:n=a}e.z=n})}async function Ce(i,e){const t=await i.geometry.project(i.outSpatialReference,e);K(t);const n={geometry:t.export(),noDataValue:i.parameters.noDataValue};return i.parameters.returnSampleInfo&&(n.sampleInfo=Fe(i)),i.geometry.coordinates.forEach(a=>{a.tile=null,a.elevationTile=null}),n}function Fe(i){const e=i.layer.tileInfo,t=_(e.spatialReference);return i.geometry.coordinates.map(n=>{let a=-1;return n.elevationTile&&n.elevationTile!==i.outsideExtentTile&&(a=e.lodAt(n.elevationTile.key.level).resolution*t),{demResolution:a,source:a===-1?void 0:i.layer}})}const A="elevation-query:invalid-layer",Qe=Object.freeze(Object.defineProperty({__proto__:null,InvalidLayerError:A,createSampler:_e,defaultOptions:D,getFinestLodIndex:Z,query:j,queryAll:Ie},Symbol.toStringTag,{value:"Module"}));export{Qe as E,A as G,I as i,x as r,Ee as t};
