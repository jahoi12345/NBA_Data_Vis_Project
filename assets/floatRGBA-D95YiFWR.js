import{i as H,s as T,h as J,F as Q,o as R,w as ee,a4 as te,a5 as se,a6 as L,W as re,a7 as oe,_ as $,m as x,a as ie,l as ne,u as le,e as ae,bs as ce}from"./jsonMap-Bs3hmeCU.js";import{a0 as ue,I as he,g as O,a1 as fe,J as de,p as me,G as pe}from"./lengthUtils-Cm-zragw.js";import{b as ge,N as _e}from"./date-IqUzANpt.js";import{c as ye}from"./intl-BIQN36K8.js";import{x as we,_ as ve}from"./labelUtils-BtizwBfq.js";import{d as Ie}from"./ArcadeExpression-BKKJxDUn.js";import{a8 as Y}from"./Point-62ir3Nzl.js";import{e as M}from"./TileKey-C44YQC4_.js";import{aj as Se}from"./Polygon-BbQMC1ht.js";import{s as $e}from"./Queue-CYlrXMwB.js";import{s as b}from"./ReactiveMap-B0by2bYu.js";import{r as Fe}from"./signal-BX9ezF8a.js";import{r as X}from"./mathUtils-PIGhLnI9.js";import"./Extent-Cs-ESnE1.js";const z=()=>H.getLogger("esri.layers.support.labelFormatUtils"),B={type:"simple",evaluate:()=>null},xe={getAttribute:(i,e)=>i.field(e)};async function et(i,e,t){if(!i||!i.symbol||!e)return B;const s=i.where,r=we(i);let o;if(r.type==="arcade"){const l=fe(r.expression),n=e.get(l);if(n&&(de(n)||O(n)||me(n)))o={type:"simple",evaluate(a){const c="attributes"in a?a.attributes?.[n.name]:a.field(n.name);return c==null?"":c.toString()}};else{const a=await Ie(r.expression,t);if(a==null)return B;o={type:"arcade",evaluate(c,u){try{const h="attributes"in c?a.repurposeFeature(c,e):c;h.contextTimeZone=u??null;const g=a.evaluate(h,{$view:{timeZone:u}});if(g!=null)return g.toString()}catch(h){z().error(new T("arcade-expression-error","Encountered an error when evaluating label expression for feature",{error:h,feature:c,expression:r}))}return null},needsHydrationToEvaluate:()=>ve(r.expression)==null}}}else o={type:"simple",evaluate:l=>r.expression.replaceAll(/{[^}]*}/g,n=>{const a=n.slice(1,-1),c=e.get(a);if(!c)return n;let u=null;return u="attributes"in l?l?.attributes?.[c.name]:l.field(c.name),u==null?"":Ce(u,c)})};if(s){let l;try{l=await pe(s,e)}catch(a){return z().error(new T("bad-where-clause","Encountered an error when evaluating where clause, ignoring",{where:s,error:a})),B}const n=o.evaluate;o.evaluate=(a,c)=>{const u="attributes"in a?void 0:xe;try{if(l.testFeature(a,u))return n(a,c)}catch(h){z().error(new T("bad-where-clause","Encountered an error when evaluating where clause for feature",{where:s,feature:a,error:h}))}return null}}return o}function Ce(i,e){if(i==null)return"";const t=e.domain;if(t){if(t.type==="codedValue"||t.type==="coded-value"){const r=i;for(const o of t.codedValues)if(o.code===r)return o.name}else if(t.type==="range"){const{max:r,min:o}=ue(e),l=+i;if(o!=null&&r!=null&&o<=l&&l<=r)return t.name}}let s=i;return he(e)?s=ge(s,_e("short-date")):O(e)&&(s=ye(+s)),s||""}const j="arial-unicode-ms",A="woff2",N=new Map,W=new Set;let Me=class{constructor(e,t){this.fontFace=e,this.promise=t}};async function st(i){const e=ze(i),t=be(i),s=N.get(e);if(s)return s.promise;const r=new FontFace(i.family,`url('${J.fontsUrl}/woff2/${t}.${A}') format('${A}')`,{style:i.style,weight:i.weight}),o=document.fonts;if(o.has(r)&&r.status==="loading")return r.loaded;const l=r.load().then(()=>(o.add(r),r));return N.set(e,new Me(r,l)),W.add(r),l}function rt(i){return W.has(i)}function Te(i){if(!i)return j;const e=i.toLowerCase().split(" ").join("-");switch(e){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return e}}function be(i){const e=V(i)+P(i);return Te(i.family)+(e.length>0?e:"-regular")}function ze(i){const e=V(i)+P(i);return(i.family||j)+(e.length>0?e:"-regular")}function V(i){if(!i.weight)return"";switch(i.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}function P(i){if(!i.style)return"";switch(i.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}function C(i,e){return[i,e]}function F(i,e,t){return i[0]=e,i[1]=t,i}function Be(i,e,t,s,r){return i[0]=e,i[1]=t,i[2]=s,i[3]=r,i}const w=new M("0/0/0/0");let qe=class D{static create(e,t,s=null){const r=Y(e.spatialReference),o=t.origin||C(e.origin.x,e.origin.y),l=C(e.size[0]*t.resolution,e.size[1]*t.resolution),n=C(-1/0,-1/0),a=C(1/0,1/0),c=C(1/0,1/0);s!=null&&(F(n,Math.max(0,Math.floor((s.xmin-o[0])/l[0])),Math.max(0,Math.floor((o[1]-s.ymax)/l[1]))),F(a,Math.max(0,Math.floor((s.xmax-o[0])/l[0])),Math.max(0,Math.floor((o[1]-s.ymin)/l[1]))),F(c,a[0]-n[0]+1,a[1]-n[1]+1));const{cols:u,rows:h}=t;let g,I,v,m;return!s&&u&&h&&(F(n,u[0],h[0]),F(a,u[1],h[1]),F(c,u[1]-u[0]+1,h[1]-h[0]+1)),e.isWrappable?(g=C(Math.ceil(Math.round((r.valid[1]-r.valid[0])/t.resolution)/e.size[0]),c[1]),I=!0,v=r.origin,m=r.valid):(g=c,I=!1),new D(t.level,t.resolution,t.scale,o,n,a,c,l,g,I,v,m)}constructor(e,t,s,r,o,l,n,a,c,u,h,g){this.level=e,this.resolution=t,this.scale=s,this.origin=r,this.first=o,this.last=l,this.size=n,this.norm=a,this.worldSize=c,this.wrap=u,this._spatialReferenceOrigin=h,this._spatialReferenceValid=g}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}normalizeKey(e){if(!this.wrap)return;const t=this.worldSize[0],s=e.col;s<0?(e.col=s+t,e.world-=1):s>=t&&(e.col=s-t,e.world+=1)}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const t=this.origin[0]+e*this.norm[0],s=this._spatialReferenceOrigin,r=this._spatialReferenceValid;return this.wrap&&s&&r?t===s[0]?r[0]:this.origin[0]===s[0]&&e===this.worldSize[0]?r[1]:t:t}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,s=!1){w.set(t);const r=s?w.col:this.denormalizeCol(w.col,w.world),o=w.row;return Be(e,this.getXForColumn(r),this.getYForRow(o+1),this.getXForColumn(r+1),this.getYForRow(o)),e}getTileCoords(e,t,s=!1){w.set(t);const r=s?w.col:this.denormalizeCol(w.col,w.world);return Array.isArray(e)?F(e,this.getXForColumn(r),this.getYForRow(w.row)):(e.x=this.getXForColumn(r),e.y=this.getYForRow(w.row)),e}};class k{constructor(){this.spans=[]}static{this.pool=new Q(()=>new k)}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:t,colFrom:s,colTo:r}of this.spans)for(let o=s;o<=r;o++){const l=e.getWorldForColumn(o);yield new M(e.level,t,e.normalizeCol(o),l)}}forEach(e,t){const{spans:s,lodInfo:r}=this,{level:o}=r;if(s.length!==0)for(const{row:l,colFrom:n,colTo:a}of s)for(let c=n;c<=a;c++)e.call(t,o,l,r.normalizeCol(c),r.getWorldForColumn(c))}}let q=class{constructor(e,t,s){this.row=e,this.colFrom=t,this.colTo=s}};const f=new M("0/0/0/0");let ke=class U{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[s,r]=e,[o,l]=t,n=o-s,a=l-r,c=a!==0?n/a:0,u=(Math.ceil(r)-r)*c,h=(Math.floor(r)-r)*c;return new U(s,Math.floor(r),Math.ceil(l),c,n<0?u:h,n<0?h:u,n<0?o:s,n<0?s:o)}constructor(e,t,s,r,o,l,n,a){this.x=e,this.ymin=t,this.ymax=s,this.invM=r,this.leftAdjust=o,this.rightAdjust=l,this.leftBound=n,this.rightBound=a}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}};const _=[[0,0],[0,0],[0,0],[0,0]],Re=1e-6;let it=class{constructor(e,t=null,s=e.lods[0].level,r=e.lods[e.lods.length-1].level){this.tileInfo=e,this.fullExtent=t,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=e.lods.filter(n=>n.level>=s&&n.level<=r);this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const l=this._lodInfos=o.map(n=>qe.create(e,n,t));o.forEach((n,a)=>{this._infoByLevel[n.level]=l[a],this._infoByScale[n.scale]=l[a],this.scales[a]=n.scale},this),this._wrap=e.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(e){return this._infoByLevel[typeof e=="number"?e:e.level]}getTileBounds(e,t,s=!1){f.set(t);const r=this._infoByLevel[f.level];return r?r.getTileBounds(e,f,s):e}getTileCoords(e,t,s=!1){f.set(t);const r=this._infoByLevel[f.level];return r?r.getTileCoords(e,f,s):e}getTileCoverage(e,t=192,s=!0,r="closest"){if(!s&&(e.scale>this.minScale||e.scale<this.maxScale))return null;const o=r==="closest"?this.getClosestInfoForScale(e.scale):this.getSmallestInfoForScale(e.scale),l=k.pool.acquire(o),n=this._wrap;let a,c,u,h=1/0,g=-1/0;const I=l.spans;_[0][0]=_[0][1]=_[1][1]=_[3][0]=-t,_[1][0]=_[2][0]=e.size[0]+t,_[2][1]=_[3][1]=e.size[1]+t;for(const d of _)e.toMap(d,d),d[0]=o.getColumnForX(d[0]),d[1]=o.getRowForY(d[1]);const v=[];let m=3;for(let d=0;d<4;d++){if(_[d][1]===_[m][1]){m=d;continue}const p=ke.create(_[d],_[m]);h=Math.min(p.ymin,h),g=Math.max(p.ymax,g),v[p.ymin]===void 0&&(v[p.ymin]=[]),v[p.ymin].push(p),m=d}if(h==null||g==null||g-h>100)return null;let y=[];for(a=h;a<g;){v[a]!=null&&(y=y.concat(v[a])),c=1/0,u=-1/0;for(let d=y.length-1;d>=0;d--){const p=y[d];c=Math.min(c,p.getLeftCol()),u=Math.max(u,p.getRightCol())}if(c=Math.floor(c),u=Math.floor(u),a>=o.first[1]&&a<=o.last[1])if(n)if(o.size[0]<o.worldSize[0]){const d=Math.floor(u/o.worldSize[0]);for(let p=Math.floor(c/o.worldSize[0]);p<=d;p++)I.push(new q(a,Math.max(o.getFirstColumnForWorld(p),c),Math.min(o.getLastColumnForWorld(p),u)))}else I.push(new q(a,c,u));else c>o.last[0]||u<o.first[0]||(c=Math.max(c,o.first[0]),u=Math.min(u,o.last[0]),I.push(new q(a,c,u)));a+=1;for(let d=y.length-1;d>=0;d--){const p=y[d];p.ymax>=a?p.incrRow():y.splice(d,1)}}return l}getTileParentId(e){f.set(e);const t=this._infoByLevel[f.level],s=this._lodInfos.indexOf(t)-1;return s<0?null:(this._getTileIdAtLOD(f,this._lodInfos[s],f),f.id)}getTileResolution(e){const t=this._infoByLevel[typeof e=="object"?e.level:e];return t?t.resolution:-1}getTileScale(e){const t=this._infoByLevel[e.level];return t?t.scale:-1}intersects(e,t){f.set(t);const s=this._infoByLevel[f.level],r=e.lodInfo;if(r.resolution>s.resolution){this._getTileIdAtLOD(f,r,f);const l=r.denormalizeCol(f.col,f.world);for(const n of e.spans)if(n.row===f.row&&n.colFrom<=l&&n.colTo>=l)return!0}if(r.resolution<s.resolution){const[l,n,a,c]=e.spans.reduce((m,y)=>(m[0]=Math.min(m[0],y.row),m[1]=Math.max(m[1],y.row),m[2]=Math.min(m[2],y.colFrom),m[3]=Math.max(m[3],y.colTo),m),[1/0,-1/0,1/0,-1/0]),u=s.denormalizeCol(f.col,f.world),h=r.getColumnForX(s.getXForColumn(u)),g=r.getRowForY(s.getYForRow(f.row)),I=r.getColumnForX(s.getXForColumn(u+1))-1,v=r.getRowForY(s.getYForRow(f.row+1))-1;return!(h>c||I<a||g>n||v<l)}const o=r.denormalizeCol(f.col,f.world);return e.spans.some(l=>l.row===f.row&&l.colFrom<=o&&l.colTo>=o)}normalizeBounds(e,t,s){if(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],this._wrap){const r=Y(this.tileInfo.spatialReference),o=-s*(r.valid[1]-r.valid[0]);e[0]+=o,e[2]+=o}return e}getSmallestInfoForScale(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e];if(e>t[0])return this._infoByScale[t[0]];for(let s=1;s<t.length-1;s++)if(e>t[s]+Re)return this._infoByScale[t[s-1]];return this._infoByScale[t[t.length-1]]}getClosestInfoForScale(e){const t=this.scales;return this._infoByScale[e]||(e=t.reduce((s,r)=>Math.abs(r-e)<Math.abs(s-e)?r:s,t[0])),this._infoByScale[e]}scaleToLevel(e){const t=this.scales;if(this._infoByScale[e])return this._infoByScale[e].level;for(let s=t.length-1;s>=0;s--)if(e<t[s])return s===t.length-1?this._infoByScale[t[t.length-1]].level:this._infoByScale[t[s]].level+(t[s]-e)/(t[s]-t[s+1]);return this._infoByScale[t[0]].level}scaleToZoom(e){return this.tileInfo.scaleToZoom(e)}zoomToScale(e){return this.tileInfo.zoomToScale(e)}_getTileIdAtLOD(e,t,s){const r=this._infoByLevel[s.level];return e.set(s),t.resolution<r.resolution?null:(t.resolution===r.resolution||(e.level=t.level,e.col=Math.floor(s.col*r.resolution/t.resolution+.01),e.row=Math.floor(s.row*r.resolution/t.resolution+.01)),e)}};class Le{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class Ae{constructor(e){this._schedule=null,this._task=null,this._deferreds=new b,this._controllers=new b,this._processingItems=new b,this._pausedSignal=Fe(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new $e(e.peeker),this.process=e.process;const t=e.scheduler;e.priority&&t&&(this._task=t.registerTask(e.priority,this))}destroy(){this.clear(),this._schedule=R(this._schedule),this._task=R(this._task)}get updating(){return!!this._task?.updating||this.readyToRun}get length(){return this._processingItems.size+this._queue.length}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach(t=>e.push(t)),this._controllers.clear(),e.forEach(t=>t.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((t,s)=>e(s))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const s=this.get(e);if(s)return s;const r=new AbortController;let o=null;t&&(o=ee(t,()=>r.abort()));const l=()=>{const u=this._processingItems.get(e);u&&u.controller.abort(),n(),c.reject(L())},n=()=>{a.remove(),o?.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},a=te(r.signal,l),c=se();return this._deferreds.set(e,c),this._controllers.set(e,r),c.promise.then(n,n),this._queue.push(e),this._scheduleNext(),c.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject(L()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}get readyToRun(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(e){for(;!e.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),e.madeProgress()}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._task||this._pausedSignal.value||this._schedule||(this._schedule=re(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(e==null)return;let t;const s=new AbortController,r=new Le(e,s);this._processingItems.set(e,r);try{t=this.process(e,s.signal)}catch(o){this._processError(r,o)}oe(t)?(r.promise=t,t.then(o=>this._processResult(r,o),o=>this._processError(r,o))):this._processResult(r,t)}get test(){}}const E=[0,0];let S=class extends ne{constructor(i){super(i),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:i,process:e,scheduler:t,priority:s}=this;this._queue=new Ae({concurrency:i,scheduler:t,priority:s,process:(r,o)=>{const l=this._keyToItem.get(r);return e(l,{signal:o})},peeker:r=>this._peek(r)})}destroy(){this.clear(),this._queue=le(this._queue)}get length(){return this._queue?this._queue.length:0}abort(i){const e=typeof i=="string"?i:i.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(i){return typeof i=="string"?this._keyToItem.has(i):this._keyToItem.has(i.id)}pause(){this._queue.pause()}push(i){const e=i.key.id;if(this._queue.has(e))return this._queue.get(e);const t=this._queue.push(e),s=this.tileInfoView.getTileScale(i.key),r=ae(this._tilesByScale,s,()=>new Set),o=()=>{r.delete(i.key),r.size===0&&this._tilesByScale.delete(s),this._keyToItem.delete(e)};return r.add(i.key),this._keyToItem.set(e,i),t.then(o,o),t}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(i){if(!this.state)return i.values().next().value;const e=new Set;for(const o of i)e.add(this._keyToItem.get(o).key);const t=this.state.scale;let s,r=Number.POSITIVE_INFINITY;for(const[o,l]of this._tilesByScale)if(ce(l,n=>e.has(n))){const n=Math.abs(o-t);n<r&&(s=l,r=n)}return this._getClosestTileKey(s,i).id}_getClosestTileKey(i,e){const t=this.tileInfoView,s=this.state.center;let r,o=Number.POSITIVE_INFINITY;for(const l of i)if(e.has(l.id)){t.getTileCoords(E,l);const n=Se(E,s);n<o&&(o=n,r=l)}return r}};$([x({constructOnly:!0})],S.prototype,"concurrency",void 0),$([x({constructOnly:!0})],S.prototype,"priority",void 0),$([x({constructOnly:!0})],S.prototype,"process",void 0),$([x({constructOnly:!0})],S.prototype,"scheduler",void 0),$([x()],S.prototype,"state",void 0),$([x({constructOnly:!0})],S.prototype,"tileInfoView",void 0),S=$([ie("esri.views.2d.tiling.TileQueue")],S);new M(0,0,0,0);function lt(i,e,t=0){const s=X(i,0,Ee);for(let r=0;r<4;r++)e[t+r]=Math.floor(256*G(s*K[r]))}function at(i,e,t=0){const s=X(i,0,Oe);for(let r=0;r<3;r++)e[t+r]=Math.floor(256*G(s*K[r]))}function Z(i,e=0){let t=0;for(let s=0;s<4;s++)t+=i[e+s]*Ne[s];return t}const K=[1,256,65536,16777216],Ne=[1/256,1/65536,1/16777216,1/4294967296],Ee=Z(new Uint8ClampedArray([255,255,255,255])),Oe=Z(new Uint8ClampedArray([255,255,255,0]));function G(i){return i-Math.floor(i)}export{Ae as _,Ce as a,et as b,st as c,it as h,rt as i,at as n,lt as o,Z as r,j as t};
